<?php

namespace AlingAi\Services\Security;

use AlingAi\Utils\Logger;
use AlingAi\Utils\Database;

/**
 * 漏洞扫描服务
 * 提供系统漏洞扫描、分析和报告功能
 *
 * @package AlingAi\Services\Security
 */
class VulnerabilityScanner
{
    /**
     * 数据库连接
     *
     * @var Database
     */
    protected $db;
    
    /**
     * 日志记录器
     *
     * @var Logger
     */
    protected $logger;
    
    /**
     * 构造函数
     */
    public function __construct()
    {
        $this->db = new Database();
        $this->logger = new Logger('vulnerability_scanner');
    }
    
    /**
     * 启动漏洞扫描
     * 
     * @param string $scanType 扫描类型
     * @param string|null $target 扫描目标
     * @return string 扫描ID
     */
    public function startScan($scanType = 'full', $target = null)
    {
        // 生成唯一扫描ID
        $scanId = $this->generateScanId();
        
        // 记录扫描开始
        $this->logger->info('开始漏洞扫描', [
            'scan_id' => $scanId,
            'scan_type' => $scanType,
            'target' => $target
        ]);
        
        // 保存扫描信息
        $scanData = [
            'scan_id' => $scanId,
            'scan_type' => $scanType,
            'target' => $target,
            'status' => 'running',
            'progress' => 0,
            'started_at' => time(),
            'completed_at' => null
        ];
        
        $this->db->insert('vulnerability_scans', $scanData);
        
        // 异步启动扫描
        $this->runAsyncScan($scanId, $scanType, $target);
        
        return $scanId;
    }
    
    /**
     * 获取扫描结果
     * 
     * @param string $scanId 扫描ID
     * @return array|null 扫描结果
     */
    public function getScanResults($scanId)
    {
        try {
            // 获取扫描信息
            $scan = $this->db->query(
                "SELECT * FROM vulnerability_scans WHERE scan_id = ?",
                [$scanId]
            )->fetch();
            
            if (!$scan) {
                return null;
            }
            
            // 获取扫描发现的漏洞
            $vulnerabilities = $this->db->query(
                "SELECT * FROM vulnerabilities WHERE scan_id = ? ORDER BY severity DESC",
                [$scanId]
            )->fetchAll();
            
            return [
                'scan_id' => $scan['scan_id'],
                'scan_type' => $scan['scan_type'],
                'target' => $scan['target'],
                'status' => $scan['status'],
                'progress' => $scan['progress'],
                'started_at' => $scan['started_at'],
                'completed_at' => $scan['completed_at'],
                'vulnerabilities' => $vulnerabilities
            ];
        } catch (\Exception $e) {
            $this->logger->error('获取扫描结果失败', [
                'scan_id' => $scanId,
                'error' => $e->getMessage()
            ]);
            return null;
        }
    }
    
    /**
     * 获取最近的漏洞
     * 
     * @param int $limit 限制数量
     * @return array 漏洞列表
     */
    public function getRecentVulnerabilities($limit = 100)
    {
        try {
            $vulnerabilities = $this->db->query(
                "SELECT * FROM vulnerabilities ORDER BY detected_at DESC LIMIT ?",
                [$limit]
            )->fetchAll();
            
            return $vulnerabilities;
        } catch (\Exception $e) {
            $this->logger->error('获取最近漏洞失败', ['error' => $e->getMessage()]);
            return [];
        }
    }
    
    /**
     * 获取扫描历史
     * 
     * @param int $limit 限制数量
     * @return array 扫描历史
     */
    public function getScanHistory($limit = 10)
    {
        try {
            $scans = $this->db->query(
                "SELECT * FROM vulnerability_scans ORDER BY started_at DESC LIMIT ?",
                [$limit]
            )->fetchAll();
            
            return $scans;
        } catch (\Exception $e) {
            $this->logger->error('获取扫描历史失败', ['error' => $e->getMessage()]);
            return [];
        }
    }
    
    /**
     * 取消扫描
     * 
     * @param string $scanId 扫描ID
     * @return bool 是否成功
     */
    public function cancelScan($scanId)
    {
        try {
            // 检查扫描是否存在且正在运行
            $scan = $this->db->query(
                "SELECT * FROM vulnerability_scans WHERE scan_id = ? AND status = 'running'",
                [$scanId]
            )->fetch();
            
            if (!$scan) {
                return false;
            }
            
            // 更新扫描状态
            $this->db->update('vulnerability_scans', [
                'status' => 'cancelled',
                'completed_at' => time()
            ], ['scan_id' => $scanId]);
            
            // 尝试终止扫描进程
            $this->terminateScanProcess($scanId);
            
            $this->logger->info('扫描已取消', ['scan_id' => $scanId]);
            
            return true;
        } catch (\Exception $e) {
            $this->logger->error('取消扫描失败', [
                'scan_id' => $scanId,
                'error' => $e->getMessage()
            ]);
            return false;
        }
    }
    
    /**
     * 生成漏洞报告
     * 
     * @param string $scanId 扫描ID
     * @param string $format 报告格式
     * @return array 报告数据
     */
    public function generateReport($scanId, $format = 'html')
    {
        // 获取扫描结果
        $scanResults = $this->getScanResults($scanId);
        
        if (!$scanResults) {
            throw new \Exception('扫描结果不存在');
        }
        
        // 准备报告数据
        $reportData = [
            'scan_id' => $scanId,
            'scan_type' => $scanResults['scan_type'],
            'target' => $scanResults['target'],
            'started_at' => $scanResults['started_at'],
            'completed_at' => $scanResults['completed_at'],
            'duration' => $scanResults['completed_at'] ? ($scanResults['completed_at'] - $scanResults['started_at']) : null,
            'vulnerabilities_count' => count($scanResults['vulnerabilities']),
            'vulnerabilities_by_severity' => $this->countVulnerabilitiesBySeverity($scanResults['vulnerabilities']),
            'vulnerabilities' => $scanResults['vulnerabilities'],
            'summary' => $this->generateSummary($scanResults['vulnerabilities']),
            'recommendations' => $this->generateRecommendations($scanResults['vulnerabilities'])
        ];
        
        // 根据格式生成报告
        switch ($format) {
            case 'html':
                return $this->generateHtmlReport($reportData);
            case 'pdf':
                return $this->generatePdfReport($reportData);
            case 'json':
                return $reportData;
            default:
                throw new \Exception('不支持的报告格式: ' . $format);
        }
    }
    
    /**
     * 生成唯一扫描ID
     * 
     * @return string 扫描ID
     */
    protected function generateScanId()
    {
        return 'scan_' . uniqid() . '_' . time();
    }
    
    /**
     * 异步运行扫描
     * 
     * @param string $scanId 扫描ID
     * @param string $scanType 扫描类型
     * @param string|null $target 扫描目标
     */
    protected function runAsyncScan($scanId, $scanType, $target)
    {
        // 在实际应用中，这里应该使用队列或后台进程来运行扫描
        // 这里使用简化的实现，模拟异步扫描过程
        
        // 创建一个后台任务来执行扫描
        $this->logger->info('启动异步扫描', [
            'scan_id' => $scanId,
            'scan_type' => $scanType
        ]);
        
        // 这里可以使用队列系统或后台进程
        // 简化实现：直接运行扫描（实际应用中应该是异步的）
        $this->performScan($scanId, $scanType, $target);
    }
    
    /**
     * 执行扫描
     * 
     * @param string $scanId 扫描ID
     * @param string $scanType 扫描类型
     * @param string|null $target 扫描目标
     */
    protected function performScan($scanId, $scanType, $target)
    {
        try {
            // 更新进度
            $this->updateScanProgress($scanId, 10);
            
            // 根据扫描类型执行不同的扫描
            switch ($scanType) {
                case 'quick':
                    $this->performQuickScan($scanId, $target);
                    break;
                case 'full':
                    $this->performFullScan($scanId, $target);
                    break;
                case 'targeted':
                    $this->performTargetedScan($scanId, $target);
                    break;
                default:
                    throw new \Exception('不支持的扫描类型: ' . $scanType);
            }
            
            // 更新扫描状态为已完成
            $this->db->update('vulnerability_scans', [
                'status' => 'completed',
                'progress' => 100,
                'completed_at' => time()
            ], ['scan_id' => $scanId]);
            
            $this->logger->info('扫描完成', ['scan_id' => $scanId]);
        } catch (\Exception $e) {
            // 更新扫描状态为失败
            $this->db->update('vulnerability_scans', [
                'status' => 'failed',
                'completed_at' => time()
            ], ['scan_id' => $scanId]);
            
            $this->logger->error('扫描失败', [
                'scan_id' => $scanId,
                'error' => $e->getMessage()
            ]);
        }
    }
    
    /**
     * 更新扫描进度
     * 
     * @param string $scanId 扫描ID
     * @param int $progress 进度百分比
     */
    protected function updateScanProgress($scanId, $progress)
    {
        $this->db->update('vulnerability_scans', [
            'progress' => $progress
        ], ['scan_id' => $scanId]);
        
        $this->logger->debug('更新扫描进度', [
            'scan_id' => $scanId,
            'progress' => $progress
        ]);
    }
    
    /**
     * 终止扫描进程
     * 
     * @param string $scanId 扫描ID
     */
    protected function terminateScanProcess($scanId)
    {
        // 在实际应用中，这里应该终止正在运行的扫描进程
        // 这里使用简化的实现
        $this->logger->info('尝试终止扫描进程', ['scan_id' => $scanId]);
    }
    
    /**
     * 按严重程度统计漏洞
     * 
     * @param array $vulnerabilities 漏洞列表
     * @return array 统计结果
     */
    protected function countVulnerabilitiesBySeverity($vulnerabilities)
    {
        $counts = [
            'critical' => 0,
            'high' => 0,
            'medium' => 0,
            'low' => 0,
            'info' => 0
        ];
        
        foreach ($vulnerabilities as $vulnerability) {
            if (isset($vulnerability['severity']) && isset($counts[$vulnerability['severity']])) {
                $counts[$vulnerability['severity']]++;
            }
        }
        
        return $counts;
    }
    
    /**
     * 生成漏洞摘要
     * 
     * @param array $vulnerabilities 漏洞列表
     * @return string 摘要
     */
    protected function generateSummary($vulnerabilities)
    {
        $counts = $this->countVulnerabilitiesBySeverity($vulnerabilities);
        
        $summary = '扫描发现了 ' . count($vulnerabilities) . ' 个漏洞，';
        $summary .= '其中包括 ' . $counts['critical'] . ' 个严重漏洞，';
        $summary .= $counts['high'] . ' 个高风险漏洞，';
        $summary .= $counts['medium'] . ' 个中风险漏洞，';
        $summary .= $counts['low'] . ' 个低风险漏洞，';
        $summary .= '以及 ' . $counts['info'] . ' 个信息性问题。';
        
        return $summary;
    }
    
    /**
     * 生成安全建议
     * 
     * @param array $vulnerabilities 漏洞列表
     * @return array 建议列表
     */
    protected function generateRecommendations($vulnerabilities)
    {
        $recommendations = [];
        
        // 收集所有建议
        foreach ($vulnerabilities as $vulnerability) {
            if (isset($vulnerability['recommendation']) && !empty($vulnerability['recommendation'])) {
                $recommendations[] = [
                    'title' => $vulnerability['title'] ?? '未知漏洞',
                    'recommendation' => $vulnerability['recommendation'],
                    'severity' => $vulnerability['severity'] ?? 'medium'
                ];
            }
        }
        
        // 按严重程度排序
        usort($recommendations, function($a, $b) {
            $severityOrder = ['critical' => 0, 'high' => 1, 'medium' => 2, 'low' => 3, 'info' => 4];
            $severityA = isset($a['severity']) && isset($severityOrder[$a['severity']]) ? $severityOrder[$a['severity']] : 5;
            $severityB = isset($b['severity']) && isset($severityOrder[$b['severity']]) ? $severityOrder[$b['severity']] : 5;
            
            return $severityA - $severityB;
        });
        
        return $recommendations;
    }
    
    /**
     * 生成HTML格式报告
     * 
     * @param array $reportData 报告数据
     * @return array 包含HTML内容的报告
     */
    protected function generateHtmlReport($reportData)
    {
        // 在实际应用中，这里应该使用模板引擎生成HTML报告
        // 这里使用简化的实现
        
        $reportData['format'] = 'html';
        $reportData['html_content'] = '<!-- HTML报告内容 -->';
        
        return $reportData;
    }
    
    /**
     * 生成PDF格式报告
     * 
     * @param array $reportData 报告数据
     * @return array 包含PDF内容的报告
     */
    protected function generatePdfReport($reportData)
    {
        // 在实际应用中，这里应该使用PDF生成库生成PDF报告
        // 这里使用简化的实现
        
        $reportData['format'] = 'pdf';
        $reportData['pdf_content'] = '<!-- PDF报告内容 -->';
        
        return $reportData;
    }
} 