 class FloatingButtonsDiagnostic { constructor() { this.diagnosticResults = {}; this.issues = []; this.recommendations = []; this.runDiagnostic(); } runDiagnostic() { console.log('ğŸ” å¼€å§‹æµ®åŠ¨æŒ‰é’®ç³»ç»Ÿè¯Šæ–­...'); this.checkManagerAvailability(); this.checkButtonPositions(); this.checkZIndexHierarchy(); this.checkButtonOverlaps(); this.checkResponsiveDesign(); this.checkPerformance(); this.generateReport(); } checkManagerAvailability() { const managerExists = window.FloatingButtonManager !== undefined; const managerInstance = window.floatingButtonManager !== undefined; this.diagnosticResults.manager = { classAvailable: managerExists, instanceAvailable: managerInstance, status: managerExists && managerInstance ? 'âœ… æ­£å¸¸' : 'âŒ å¼‚å¸¸' }; if (!managerExists || !managerInstance) { this.issues.push('æµ®åŠ¨æŒ‰é’®ç®¡ç†å™¨æœªæ­£ç¡®åŠ è½½'); this.recommendations.push('ç¡®ä¿ floating-buttons-manager.js æ­£ç¡®åŠ è½½'); } } checkButtonPositions() { const buttons = document.querySelectorAll('.floating-button, [data-floating-button]'); const positions = []; buttons.forEach(button => { const rect = button.getBoundingClientRect(); const style = window.getComputedStyle(button); positions.push({ element: button.id || button.className, position: style.position, top: style.top, right: style.right, bottom: style.bottom, left: style.left, zIndex: style.zIndex, rect: { x: rect.x, y: rect.y, width: rect.width, height: rect.height } }); }); this.diagnosticResults.positions = positions; // æ£€æŸ¥æ˜¯å¦æœ‰æŒ‰é’®ä½ç½®å†²çª this.checkPositionConflicts(positions); } checkPositionConflicts(positions) { const conflicts = []; for (let i = 0; i < positions.length; i++) { for (let j = i + 1; j < positions.length; j++) { const button1 = positions[i]; const button2 = positions[j]; // æ£€æŸ¥æ˜¯å¦é‡å  if (this.isOverlapping(button1.rect, button2.rect)) { conflicts.push({ button1: button1.element, button2: button2.element, overlap: this.calculateOverlapArea(button1.rect, button2.rect) }); } } } if (conflicts.length > 0) { this.issues.push(`å‘ç° ${conflicts.length} ä¸ªæŒ‰é’®ä½ç½®å†²çª`); this.diagnosticResults.conflicts = conflicts; } } isOverlapping(rect1, rect2) { return !(rect1.x + rect1.width <= rect2.x || rect2.x + rect2.width <= rect1.x || rect1.y + rect1.height <= rect2.y || rect2.y + rect2.height <= rect1.y); } calculateOverlapArea(rect1, rect2) { const left = Math.max(rect1.x, rect2.x); const right = Math.min(rect1.x + rect1.width, rect2.x + rect2.width); const top = Math.max(rect1.y, rect2.y); const bottom = Math.min(rect1.y + rect1.height, rect2.y + rect2.height); if (right > left && bottom > top) { return (right - left) * (bottom - top); } return 0; } checkZIndexHierarchy() { const buttons = document.querySelectorAll('.floating-button, [data-floating-button]'); const zIndexValues = []; buttons.forEach(button => { const zIndex = parseInt(window.getComputedStyle(button).zIndex) || 0; zIndexValues.push({ element: button.id || button.className, zIndex: zIndex }); }); // æ£€æŸ¥æ˜¯å¦æœ‰é‡å¤çš„ z-index const duplicates = zIndexValues.filter((item, index, arr) => arr.findIndex(other => other.zIndex === item.zIndex && other.element !== item.element) !== -1 ); if (duplicates.length > 0) { this.issues.push(`å‘ç°é‡å¤çš„ z-index å€¼: ${duplicates.map(d => `${d.element}(${d.zIndex})`).join(', ')}`); } this.diagnosticResults.zIndexHierarchy = zIndexValues.sort((a, b) => b.zIndex - a.zIndex); } checkButtonOverlaps() { const buttons = document.querySelectorAll('.floating-button, [data-floating-button]'); let overlappingButtons = 0; buttons.forEach(button => { const rect = button.getBoundingClientRect(); const isOutOfViewport = rect.right > window.innerWidth || rect.bottom > window.innerHeight || rect.left < 0 || rect.top < 0; if (isOutOfViewport) { overlappingButtons++; this.issues.push(`æŒ‰é’® ${button.id || button.className} è¶…å‡ºäº†è§†çª—èŒƒå›´`); } }); this.diagnosticResults.viewportOverlaps = overlappingButtons; } checkResponsiveDesign() { const breakpoints = [ { name: 'mobile', width: 480 }, { name: 'tablet', width: 768 }, { name: 'desktop', width: 1024 } ]; const responsiveTests = []; breakpoints.forEach(bp => { // æ¨¡æ‹Ÿä¸åŒå±å¹•å°ºå¯¸ const originalWidth = window.innerWidth; // è¿™é‡Œåº”è¯¥æµ‹è¯•å“åº”å¼è¡Œä¸ºï¼Œä½†ç”±äºæµè§ˆå™¨é™åˆ¶ï¼Œæˆ‘ä»¬åªèƒ½æ£€æŸ¥CSS const mediaQuery = window.matchMedia(`(max-width: ${bp.width}px)`); responsiveTests.push({ breakpoint: bp.name, matches: mediaQuery.matches, width: bp.width }); }); this.diagnosticResults.responsive = responsiveTests; } checkPerformance() { const startTime = performance.now(); // æµ‹è¯•æµ®åŠ¨æŒ‰é’®ç®¡ç†å™¨çš„æ€§èƒ½ if (window.floatingButtonManager) { const testOperations = 100; const performanceStart = performance.now(); for (let i = 0; i < testOperations; i++) { // æ¨¡æ‹Ÿé¢‘ç¹çš„æ“ä½œ window.floatingButtonManager.getAvailableSlots(); } const performanceEnd = performance.now(); const avgOperationTime = (performanceEnd - performanceStart) / testOperations; this.diagnosticResults.performance = { averageOperationTime: avgOperationTime, totalTestTime: performanceEnd - performanceStart, operationsPerSecond: 1000 / avgOperationTime }; if (avgOperationTime > 1) { this.issues.push(`æµ®åŠ¨æŒ‰é’®ç®¡ç†å™¨æ€§èƒ½è¾ƒä½ï¼Œå¹³å‡æ“ä½œæ—¶é—´: ${avgOperationTime.toFixed(2)}ms`); } } const endTime = performance.now(); this.diagnosticResults.diagnosticTime = endTime - startTime; } generateReport() { const report = { timestamp: new Date().toISOString(), summary: { totalIssues: this.issues.length, systemStatus: this.issues.length === 0 ? 'âœ… å¥åº·' : 'âš ï¸ éœ€è¦å…³æ³¨', buttonsDetected: document.querySelectorAll('.floating-button, [data-floating-button]').length }, details: this.diagnosticResults, issues: this.issues, recommendations: this.recommendations }; console.log('ğŸ“Š æµ®åŠ¨æŒ‰é’®ç³»ç»Ÿè¯Šæ–­æŠ¥å‘Š:', report); // åœ¨é¡µé¢ä¸Šæ˜¾ç¤ºæŠ¥å‘Š this.displayReport(report); return report; } displayReport(report) { let reportElement = document.getElementById('diagnosticReport'); if (!reportElement) { reportElement = document.createElement('div'); reportElement.id = 'diagnosticReport'; reportElement.className = 'fixed top-4 left-4 bg-gray-900 text-white p-4 rounded-lg shadow-lg max-w-md z-50'; document.body.appendChild(reportElement); } reportElement.innerHTML = ` <div class="mb-2 font-bold">ğŸ” ç³»ç»Ÿè¯Šæ–­æŠ¥å‘Š</div> <div class="text-sm space-y-1"> <div>çŠ¶æ€: ${report.summary.systemStatus}</div> <div>æŒ‰é’®æ•°é‡: ${report.summary.buttonsDetected}</div> <div>é—®é¢˜æ•°é‡: ${report.summary.totalIssues}</div> ${report.issues.length > 0 ? ` <div class="mt-2"> <div class="font-semibold">é—®é¢˜:</div> <ul class="text-xs"> ${report.issues.map(issue => `<li>â€¢ ${issue}</li>`).join('')} </ul> </div> ` : ''} </div> <button onclick="this.parentElement.remove()" class="mt-2 text-xs bg-red-600 px-2 py-1 rounded"> å…³é—­ </button> `; } } // è‡ªåŠ¨è¿è¡Œè¯Šæ–­ï¼ˆå»¶è¿Ÿæ‰§è¡Œç¡®ä¿æ‰€æœ‰ç»„ä»¶åŠ è½½å®Œæˆï¼‰ setTimeout(() => { window.floatingButtonsDiagnostic = new FloatingButtonsDiagnostic(); }, 2000); // æä¾›å…¨å±€è®¿é—® window.FloatingButtonsDiagnostic = FloatingButtonsDiagnostic; 