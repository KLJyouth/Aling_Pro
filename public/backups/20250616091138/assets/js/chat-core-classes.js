// èŠå¤©æ ¸å¿ƒç±»å®šä¹‰ - ä¿®å¤ç¼ºå¤±çš„ç±»å’Œå…¨å±€å¯¹è±¡ // åˆ›å»ºæ—¶é—´: 2025-05-30 // æ›´æ–°: 2025-06-06 - é›†æˆçœŸå®APIåŠŸèƒ½ console.log('ğŸ”§ åŠ è½½èŠå¤©æ ¸å¿ƒç±»æ¨¡å—...'); // MessageProcessor ç±» - å¤„ç†æ¶ˆæ¯ï¼ˆçœŸå®APIé›†æˆç‰ˆæœ¬ï¼‰ class MessageProcessor { constructor() { this.messageHistory = []; this.filters = []; this.processors = new Map(); this.apiEndpoints = { sendMessage: '/api/v1/chat/sessions', saveMessage: '/api/v1/chat/messages', getMessages: '/api/v1/chat/sessions/{id}/messages' }; this.initializeDefaultProcessors(); console.log('ğŸ“¨ MessageProcessor åˆå§‹åŒ–å®Œæˆ - çœŸå®APIæ¨¡å¼'); } initializeDefaultProcessors() { // é»˜è®¤å¤„ç†å™¨ this.processors.set('text', this.processTextMessage.bind(this)); this.processors.set('emoji', this.processEmojiMessage.bind(this)); this.processors.set('link', this.processLinkMessage.bind(this)); this.processors.set('file', this.processFileMessage.bind(this)); } async processMessage(message, type = 'text', sessionId = null) { try { const timestamp = new Date().toISOString(); const processedMessage = { id: this.generateMessageId(), content: message, type: type, timestamp: timestamp, processed: true, sessionId: sessionId }; // åº”ç”¨å¤„ç†å™¨ if (this.processors.has(type)) { processedMessage.content = this.processors.get(type)(message); } // åº”ç”¨è¿‡æ»¤å™¨ this.filters.forEach(filter => { processedMessage.content = filter(processedMessage.content); }); this.messageHistory.push(processedMessage); // ä¿å­˜åˆ°æ•°æ®åº“ï¼ˆå¦‚æœæœ‰ä¼šè¯IDï¼‰ if (sessionId) { await this.saveMessageToAPI(processedMessage); } return processedMessage; } catch (error) { console.error('âŒ æ¶ˆæ¯å¤„ç†å¤±è´¥:', error); return { id: this.generateMessageId(), content: message, type: 'error', timestamp: new Date().toISOString(), error: error.message }; } } processTextMessage(text) { // åŸºæœ¬æ–‡æœ¬å¤„ç† return text.trim() .replace(/\n{3,}/g, '\n\n') // é™åˆ¶è¿ç»­æ¢è¡Œ .replace(/\s{2,}/g, ' '); // å‹ç¼©å¤šä½™ç©ºæ ¼ } processEmojiMessage(text) { // è¡¨æƒ…ç¬¦å·å¤„ç† return text.replace(/:\w+:/g, (match) => { const emojiMap = { ':smile:': 'ğŸ˜Š', ':heart:': 'â¤ï¸', ':thumbs_up:': 'ğŸ‘', ':fire:': 'ğŸ”¥' }; return emojiMap[match] || match; }); } processLinkMessage(text) { // é“¾æ¥å¤„ç† const urlRegex = /(https?:\/\/[^\s]+)/g; return text.replace(urlRegex, '<a href="$1" target="_blank" rel="noopener">$1</a>'); } processFileMessage(fileInfo) { // æ–‡ä»¶ä¿¡æ¯å¤„ç† return { type: 'file', name: fileInfo.name || 'unknown', size: fileInfo.size || 0, url: fileInfo.url || '', processed: true }; } addFilter(filterFn) { if (typeof filterFn === 'function') { this.filters.push(filterFn); } } generateMessageId() { return 'msg_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9); } getMessageHistory(limit = 50) { return this.messageHistory.slice(-limit); } async saveMessageToAPI(message) { try { const token = localStorage.getItem('auth_token'); if (!token) return false; const response = await fetch(this.apiEndpoints.saveMessage, { method: 'POST', headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` }, body: JSON.stringify({ session_id: message.sessionId, role: message.type === 'user' ? 'user' : 'assistant', content: message.content, metadata: { processed: message.processed, messageId: message.id } }) }); if (!response.ok) { console.warn('Failed to save message to API'); return false; } const result = await response.json(); return result.success || false; } catch (error) { console.error('Error saving message to API:', error); return false; } } async loadMessagesFromAPI(sessionId, limit = 50) { try { const token = localStorage.getItem('auth_token'); if (!token) return []; const url = this.apiEndpoints.getMessages.replace('{id}', sessionId) + `?limit=${limit}`; const response = await fetch(url, { headers: { 'Authorization': `Bearer ${token}` } }); if (!response.ok) { console.warn('Failed to load messages from API'); return []; } const result = await response.json(); if (result.success && result.data) { // è½¬æ¢APIæ ¼å¼åˆ°æœ¬åœ°æ ¼å¼ const messages = result.data.map(msg => ({ id: msg.id, content: msg.content, type: msg.role === 'user' ? 'user' : 'assistant', timestamp: msg.created_at, processed: true, sessionId: sessionId })); this.messageHistory = messages; return messages; } return []; } catch (error) { console.error('Error loading messages from API:', error); return []; } } clearHistory() { this.messageHistory = []; console.log('ğŸ§¹ æ¶ˆæ¯å†å²å·²æ¸…ç©º'); } } // MessageRenderer ç±» - æ¸²æŸ“æ¶ˆæ¯ class MessageRenderer { constructor(containerElement) { this.container = containerElement; this.templates = new Map(); this.animations = true; this.initializeTemplates(); console.log('ğŸ¨ MessageRenderer åˆå§‹åŒ–å®Œæˆ'); } initializeTemplates() { // é»˜è®¤æ¶ˆæ¯æ¨¡æ¿ this.templates.set('text', this.createTextTemplate.bind(this)); this.templates.set('system', this.createSystemTemplate.bind(this)); this.templates.set('error', this.createErrorTemplate.bind(this)); this.templates.set('file', this.createFileTemplate.bind(this)); } renderMessage(message) { try { const messageElement = this.createMessageElement(message); if (this.container) { this.container.appendChild(messageElement); if (this.animations) { this.animateMessageIn(messageElement); } this.scrollToBottom(); } return messageElement; } catch (error) { console.error('âŒ æ¶ˆæ¯æ¸²æŸ“å¤±è´¥:', error); return this.createErrorMessage('æ¸²æŸ“å¤±è´¥: ' + error.message); } } createMessageElement(message) { const messageDiv = document.createElement('div'); messageDiv.className = `message message-${message.type}`; messageDiv.setAttribute('data-message-id', message.id); // åº”ç”¨æ¨¡æ¿ const template = this.templates.get(message.type) || this.templates.get('text'); messageDiv.innerHTML = template(message); return messageDiv; } createTextTemplate(message) { return ` <div class="message-content"> <div class="message-text">${this.escapeHtml(message.content)}</div> <div class="message-time">${this.formatTime(message.timestamp)}</div> </div> `; } createSystemTemplate(message) { return ` <div class="message-content system"> <i class="bi bi-info-circle"></i> <span class="message-text">${this.escapeHtml(message.content)}</span> <div class="message-time">${this.formatTime(message.timestamp)}</div> </div> `; } createErrorTemplate(message) { return ` <div class="message-content error"> <i class="bi bi-exclamation-triangle"></i> <span class="message-text">${this.escapeHtml(message.content)}</span> <div class="message-time">${this.formatTime(message.timestamp)}</div> </div> `; } createFileTemplate(message) { const fileInfo = typeof message.content === 'object' ? message.content : { name: message.content }; return ` <div class="message-content file"> <i class="bi bi-file-earmark"></i> <div class="file-info"> <div class="file-name">${this.escapeHtml(fileInfo.name)}</div> <div class="file-size">${this.formatFileSize(fileInfo.size)}</div> </div> <div class="message-time">${this.formatTime(message.timestamp)}</div> </div> `; } createErrorMessage(errorText) { const errorDiv = document.createElement('div'); errorDiv.className = 'message message-error'; errorDiv.innerHTML = this.createErrorTemplate({ content: errorText, timestamp: new Date().toISOString() }); return errorDiv; } animateMessageIn(element) { element.style.opacity = '0'; element.style.transform = 'translateY(20px)'; requestAnimationFrame(() => { element.style.transition = 'all 0.3s ease'; element.style.opacity = '1'; element.style.transform = 'translateY(0)'; }); } scrollToBottom() { if (this.container) { this.container.scrollTop = this.container.scrollHeight; } } clearMessages() { if (this.container) { this.container.innerHTML = ''; } } escapeHtml(text) { const div = document.createElement('div'); div.textContent = text; return div.innerHTML; } formatTime(timestamp) { const date = new Date(timestamp); return date.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' }); } formatFileSize(bytes) { if (!bytes) return 'Unknown size'; const sizes = ['Bytes', 'KB', 'MB', 'GB']; const i = Math.floor(Math.log(bytes) / Math.log(1024)); return Math.round(bytes / Math.pow(1024, i) * 100) / 100 + ' ' + sizes[i]; } } // ChatCore ç±» - èŠå¤©æ ¸å¿ƒåŠŸèƒ½ class ChatCore { constructor() { this.processor = new MessageProcessor(); this.renderer = null; this.isInitialized = false; this.eventHandlers = new Map(); console.log('ğŸ’¬ ChatCore åˆå§‹åŒ–å®Œæˆ'); } initialize(chatContainer) { try { if (chatContainer) { this.renderer = new MessageRenderer(chatContainer); } this.isInitialized = true; this.emit('initialized'); console.log('âœ… ChatCore å®Œå…¨åˆå§‹åŒ–æˆåŠŸ'); return true; } catch (error) { console.error('âŒ ChatCore åˆå§‹åŒ–å¤±è´¥:', error); return false; } } sendMessage(content, type = 'text') { if (!this.isInitialized) { console.warn('âš ï¸ ChatCore æœªåˆå§‹åŒ–'); return false; } const processedMessage = this.processor.processMessage(content, type); if (this.renderer) { this.renderer.renderMessage(processedMessage); } this.emit('messageSent', processedMessage); return processedMessage; } receiveMessage(content, type = 'text') { return this.sendMessage(content, type); } on(event, handler) { if (!this.eventHandlers.has(event)) { this.eventHandlers.set(event, []); } this.eventHandlers.get(event).push(handler); } emit(event, data) { if (this.eventHandlers.has(event)) { this.eventHandlers.get(event).forEach(handler => { try { handler(data); } catch (error) { console.error(`âŒ äº‹ä»¶å¤„ç†å™¨é”™è¯¯ (${event}):`, error); } }); } } getMessageHistory() { return this.processor.getMessageHistory(); } clearChat() { this.processor.clearHistory(); if (this.renderer) { this.renderer.clearMessages(); } this.emit('chatCleared'); } isReady() { return this.isInitialized && this.processor && this.renderer; } } // åˆ›å»ºå…¨å±€å®ä¾‹ window.MessageProcessor = MessageProcessor; window.MessageRenderer = MessageRenderer; window.ChatCore = ChatCore; // åˆ›å»ºå…¨å±€èŠå¤©å®ä¾‹ window.chatInstance = { core: new ChatCore(), processor: new MessageProcessor(), renderer: null, ui: { initialize: function(container) { return window.chatInstance.core.initialize(container); }, sendMessage: function(content, type) { return window.chatInstance.core.sendMessage(content, type); }, clearChat: function() { return window.chatInstance.core.clearChat(); } }, api: { sendRequest: async function(message) { // æ¨¡æ‹ŸAPIè¯·æ±‚ return new Promise((resolve) => { setTimeout(() => { resolve({ success: true, response: `å›å¤: ${message}`, timestamp: new Date().toISOString() }); }, 1000); }); }, getHistory: function() { return window.chatInstance.core.getMessageHistory(); } } }; console.log('âœ… èŠå¤©æ ¸å¿ƒç±»æ¨¡å—åŠ è½½å®Œæˆ'); console.log('ğŸ“¦ å¯ç”¨ç±»: MessageProcessor, MessageRenderer, ChatCore'); console.log('ğŸŒ å…¨å±€å®ä¾‹: chatInstance, MessageProcessor, MessageRenderer, ChatCore'); 