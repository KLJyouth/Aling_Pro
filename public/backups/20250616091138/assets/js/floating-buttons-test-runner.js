 class FloatingButtonsTestRunner { constructor() { this.testResults = []; this.passedTests = 0; this.failedTests = 0; this.totalTests = 0; this.init(); } init() { console.log('ğŸ§ª å¯åŠ¨æµ®åŠ¨æŒ‰é’®ç³»ç»Ÿæµ‹è¯•...'); this.runAllTests(); } async runAllTests() { // ç­‰å¾…æ‰€æœ‰ç³»ç»ŸåŠ è½½å®Œæˆ await this.waitForSystemReady(); // è¿è¡Œæµ‹è¯•å¥—ä»¶ await this.testManagerAvailability(); await this.testButtonPositioning(); await this.testZIndexHierarchy(); await this.testButtonOverlaps(); await this.testResponsiveDesign(); await this.testButtonInteractions(); await this.testPerformance(); // ç”Ÿæˆæµ‹è¯•æŠ¥å‘Š this.generateTestReport(); } async waitForSystemReady() { return new Promise((resolve) => { const checkReady = () => { const managerReady = window.FloatingButtonManager && window.floatingButtonManager; const diagnosticReady = window.FloatingButtonsDiagnostic; if (managerReady && diagnosticReady) { console.log('âœ… ç³»ç»Ÿå°±ç»ªï¼Œå¼€å§‹æµ‹è¯•'); resolve(); } else { console.log('â³ ç­‰å¾…ç³»ç»ŸåŠ è½½...'); setTimeout(checkReady, 500); } }; checkReady(); }); } async testManagerAvailability() { this.startTest('æµ®åŠ¨æŒ‰é’®ç®¡ç†å™¨å¯ç”¨æ€§æµ‹è¯•'); try { const managerExists = window.FloatingButtonManager !== undefined; const instanceExists = window.floatingButtonManager !== undefined; this.assert(managerExists, 'æµ®åŠ¨æŒ‰é’®ç®¡ç†å™¨ç±»åº”è¯¥å­˜åœ¨'); this.assert(instanceExists, 'æµ®åŠ¨æŒ‰é’®ç®¡ç†å™¨å®ä¾‹åº”è¯¥å­˜åœ¨'); if (instanceExists) { const registeredButtons = window.floatingButtonManager.registeredButtons; this.assert(registeredButtons.size > 0, 'åº”è¯¥æœ‰å·²æ³¨å†Œçš„æŒ‰é’®'); console.log(`ğŸ“Š å·²æ³¨å†ŒæŒ‰é’®æ•°é‡: ${registeredButtons.size}`); } this.passTest('æµ®åŠ¨æŒ‰é’®ç®¡ç†å™¨å¯ç”¨æ€§æµ‹è¯•'); } catch (error) { this.failTest('æµ®åŠ¨æŒ‰é’®ç®¡ç†å™¨å¯ç”¨æ€§æµ‹è¯•', error.message); } } async testButtonPositioning() { this.startTest('æŒ‰é’®å®šä½æµ‹è¯•'); try { const buttons = document.querySelectorAll('.floating-button, [data-floating-button]'); const expectedPositions = { 'performance-dashboard-toggle': { right: '20px', top: '20px' }, 'social-customization-toggle': { right: '20px', bottom: '80px' }, 'debug-console-toggle': { right: '20px', bottom: '20px' } }; let positionCorrect = 0; let totalChecked = 0; buttons.forEach(button => { const buttonId = button.id; if (expectedPositions[buttonId]) { totalChecked++; const computedStyle = window.getComputedStyle(button); const expected = expectedPositions[buttonId]; const rightMatch = computedStyle.right === expected.right; const positionMatch = (expected.top && computedStyle.top === expected.top) || (expected.bottom && computedStyle.bottom === expected.bottom); if (rightMatch && positionMatch) { positionCorrect++; console.log(`âœ… ${buttonId} ä½ç½®æ­£ç¡®`); } else { console.log(`âŒ ${buttonId} ä½ç½®é”™è¯¯:`, { expected, actual: { right: computedStyle.right, top: computedStyle.top, bottom: computedStyle.bottom } }); } } }); this.assert(totalChecked > 0, 'åº”è¯¥æ£€æŸ¥åˆ°ä¸€äº›æŒ‰é’®çš„ä½ç½®'); this.assert(positionCorrect === totalChecked, `æ‰€æœ‰æ£€æŸ¥çš„æŒ‰é’®ä½ç½®éƒ½åº”è¯¥æ­£ç¡® (${positionCorrect}/${totalChecked})`); this.passTest('æŒ‰é’®å®šä½æµ‹è¯•'); } catch (error) { this.failTest('æŒ‰é’®å®šä½æµ‹è¯•', error.message); } } async testZIndexHierarchy() { this.startTest('Z-Indexå±‚çº§æµ‹è¯•'); try { const buttons = document.querySelectorAll('.floating-button, [data-floating-button]'); const zIndexValues = []; buttons.forEach(button => { const zIndex = parseInt(window.getComputedStyle(button).zIndex) || 0; if (zIndex > 0) { zIndexValues.push({ element: button.id || button.className, zIndex: zIndex }); } }); // æ£€æŸ¥æ˜¯å¦æœ‰é‡å¤çš„z-index const uniqueZIndexes = new Set(zIndexValues.map(item => item.zIndex)); this.assert(uniqueZIndexes.size === zIndexValues.length, 'ä¸åº”è¯¥æœ‰é‡å¤çš„z-indexå€¼'); // æ£€æŸ¥z-indexæ˜¯å¦åœ¨åˆç†èŒƒå›´å†… (1000-1040) const validRange = zIndexValues.every(item => item.zIndex >= 1000 && item.zIndex <= 1040); this.assert(validRange, 'Z-indexå€¼åº”è¯¥åœ¨1000-1040èŒƒå›´å†…'); console.log('ğŸ“Š Z-Indexå±‚çº§:', zIndexValues.sort((a, b) => b.zIndex - a.zIndex)); this.passTest('Z-Indexå±‚çº§æµ‹è¯•'); } catch (error) { this.failTest('Z-Indexå±‚çº§æµ‹è¯•', error.message); } } async testButtonOverlaps() { this.startTest('æŒ‰é’®é‡å æ£€æµ‹æµ‹è¯•'); try { const buttons = document.querySelectorAll('.floating-button, [data-floating-button]'); const buttonRects = Array.from(buttons).map(button => ({ element: button.id || button.className, rect: button.getBoundingClientRect() })); let overlaps = 0; for (let i = 0; i < buttonRects.length; i++) { for (let j = i + 1; j < buttonRects.length; j++) { const rect1 = buttonRects[i].rect; const rect2 = buttonRects[j].rect; if (this.isOverlapping(rect1, rect2)) { overlaps++; console.warn(`âŒ é‡å æ£€æµ‹: ${buttonRects[i].element} ä¸ ${buttonRects[j].element}`); } } } this.assert(overlaps === 0, `ä¸åº”è¯¥æœ‰æŒ‰é’®é‡å  (å‘ç°${overlaps}ä¸ªé‡å )`); this.passTest('æŒ‰é’®é‡å æ£€æµ‹æµ‹è¯•'); } catch (error) { this.failTest('æŒ‰é’®é‡å æ£€æµ‹æµ‹è¯•', error.message); } } isOverlapping(rect1, rect2) { return !(rect1.right <= rect2.left || rect2.right <= rect1.left || rect1.bottom <= rect2.top || rect2.bottom <= rect1.top); } async testResponsiveDesign() { this.startTest('å“åº”å¼è®¾è®¡æµ‹è¯•'); try { const originalWidth = window.innerWidth; // æ¨¡æ‹Ÿç§»åŠ¨è®¾å¤‡å±å¹• const mobileMediaQuery = window.matchMedia('(max-width: 768px)'); const isMobile = mobileMediaQuery.matches; console.log(`ğŸ“± å½“å‰å±å¹•: ${originalWidth}px, ç§»åŠ¨è®¾å¤‡: ${isMobile}`); const buttons = document.querySelectorAll('.floating-button, [data-floating-button]'); let responsiveIssues = 0; buttons.forEach(button => { const rect = button.getBoundingClientRect(); const computedStyle = window.getComputedStyle(button); // æ£€æŸ¥æŒ‰é’®æ˜¯å¦è¶…å‡ºè§†çª— if (rect.right > window.innerWidth || rect.bottom > window.innerHeight) { responsiveIssues++; console.warn(`âŒ æŒ‰é’®è¶…å‡ºè§†çª—: ${button.id || button.className}`); } // æ£€æŸ¥ç§»åŠ¨è®¾å¤‡ä¼˜åŒ– if (isMobile) { const size = parseInt(computedStyle.width); if (size < 44) { // iOS Human Interface Guidelines æœ€å°è§¦æ‘¸ç›®æ ‡ console.warn(`âš ï¸ ç§»åŠ¨è®¾å¤‡æŒ‰é’®å¯èƒ½å¤ªå°: ${button.id || button.className} (${size}px)`); } } }); this.assert(responsiveIssues === 0, `æ‰€æœ‰æŒ‰é’®éƒ½åº”è¯¥åœ¨è§†çª—å†… (å‘ç°${responsiveIssues}ä¸ªé—®é¢˜)`); this.passTest('å“åº”å¼è®¾è®¡æµ‹è¯•'); } catch (error) { this.failTest('å“åº”å¼è®¾è®¡æµ‹è¯•', error.message); } } async testButtonInteractions() { this.startTest('æŒ‰é’®äº¤äº’æµ‹è¯•'); try { const buttons = document.querySelectorAll('.floating-button, [data-floating-button]'); let interactiveButtons = 0; buttons.forEach(button => { const hasClickHandler = button.onclick || button.getAttribute('onclick') || button.hasAttribute('data-click-action'); const hasHoverStyles = window.getComputedStyle(button, ':hover').transform !== 'none' || button.classList.contains('hover:scale-110') || button.classList.contains('touch-feedback'); if (hasClickHandler || hasHoverStyles) { interactiveButtons++; } // æ£€æŸ¥æŒ‰é’®çš„å¯è®¿é—®æ€§ const hasAriaLabel = button.hasAttribute('aria-label') || button.hasAttribute('title') || button.textContent.trim().length > 0; if (!hasAriaLabel) { console.warn(`âš ï¸ æŒ‰é’®ç¼ºå°‘å¯è®¿é—®æ€§æ ‡ç­¾: ${button.id || button.className}`); } }); this.assert(interactiveButtons > 0, 'åº”è¯¥æœ‰å¯äº¤äº’çš„æŒ‰é’®'); console.log(`ğŸ“Š å¯äº¤äº’æŒ‰é’®æ•°é‡: ${interactiveButtons}/${buttons.length}`); this.passTest('æŒ‰é’®äº¤äº’æµ‹è¯•'); } catch (error) { this.failTest('æŒ‰é’®äº¤äº’æµ‹è¯•', error.message); } } async testPerformance() { this.startTest('æ€§èƒ½æµ‹è¯•'); try { const startTime = performance.now(); // æµ‹è¯•ç®¡ç†å™¨æ“ä½œæ€§èƒ½ if (window.floatingButtonManager) { const manager = window.floatingButtonManager; // æµ‹è¯•æŒ‰é’®æ³¨å†Œæ€§èƒ½ const registrationStart = performance.now(); for (let i = 0; i < 100; i++) { manager.getAvailableSlots(); } const registrationTime = performance.now() - registrationStart; this.assert(registrationTime < 100, `æŒ‰é’®æ“ä½œåº”è¯¥å¿«é€Ÿå®Œæˆ (${registrationTime.toFixed(2)}ms)`); // æµ‹è¯•å†…å­˜ä½¿ç”¨ const registeredCount = manager.registeredButtons.size; console.log(`ğŸ“Š å·²æ³¨å†ŒæŒ‰é’®: ${registeredCount}`); console.log(`ğŸ“Š æ“ä½œæ€§èƒ½: ${registrationTime.toFixed(2)}ms`); } const totalTime = performance.now() - startTime; console.log(`ğŸ“Š æ€§èƒ½æµ‹è¯•æ€»æ—¶é—´: ${totalTime.toFixed(2)}ms`); this.passTest('æ€§èƒ½æµ‹è¯•'); } catch (error) { this.failTest('æ€§èƒ½æµ‹è¯•', error.message); } } startTest(testName) { this.currentTest = testName; this.totalTests++; console.log(`ğŸ§ª å¼€å§‹æµ‹è¯•: ${testName}`); } assert(condition, message) { if (!condition) { throw new Error(message); } } passTest(testName) { this.passedTests++; this.testResults.push({ name: testName, status: 'PASSED', message: 'æµ‹è¯•é€šè¿‡' }); console.log(`âœ… ${testName}: é€šè¿‡`); } failTest(testName, error) { this.failedTests++; this.testResults.push({ name: testName, status: 'FAILED', message: error }); console.error(`âŒ ${testName}: å¤±è´¥ - ${error}`); } generateTestReport() { const report = { timestamp: new Date().toISOString(), summary: { total: this.totalTests, passed: this.passedTests, failed: this.failedTests, successRate: ((this.passedTests / this.totalTests) * 100).toFixed(2) + '%' }, results: this.testResults, systemInfo: { userAgent: navigator.userAgent, screenSize: `${window.innerWidth}x${window.innerHeight}`, devicePixelRatio: window.devicePixelRatio } }; console.log('ğŸ“Š æµ®åŠ¨æŒ‰é’®ç³»ç»Ÿæµ‹è¯•æŠ¥å‘Š:', report); // åœ¨é¡µé¢ä¸Šæ˜¾ç¤ºæŠ¥å‘Š this.displayTestReport(report); return report; } displayTestReport(report) { let reportElement = document.getElementById('testReport'); if (!reportElement) { reportElement = document.createElement('div'); reportElement.id = 'testReport'; reportElement.className = 'fixed top-4 left-4 bg-gray-900 text-white p-6 rounded-lg shadow-lg max-w-lg z-50 max-h-96 overflow-y-auto'; document.body.appendChild(reportElement); } const statusColor = report.summary.failed === 0 ? 'text-green-400' : 'text-red-400'; reportElement.innerHTML = ` <div class="mb-4"> <h3 class="text-lg font-bold mb-2">ğŸ§ª æµ‹è¯•æŠ¥å‘Š</h3> <div class="text-sm space-y-1"> <div>æ€»æµ‹è¯•æ•°: ${report.summary.total}</div> <div class="text-green-400">é€šè¿‡: ${report.summary.passed}</div> <div class="text-red-400">å¤±è´¥: ${report.summary.failed}</div> <div class="${statusColor}">æˆåŠŸç‡: ${report.summary.successRate}</div> </div> </div> <div class="mb-4"> <h4 class="font-semibold mb-2">æµ‹è¯•ç»“æœè¯¦æƒ…:</h4> <div class="space-y-1 text-xs"> ${report.results.map(result => ` <div class="flex items-center space-x-2"> <span class="${result.status === 'PASSED' ? 'text-green-400' : 'text-red-400'}"> ${result.status === 'PASSED' ? 'âœ…' : 'âŒ'} </span> <span class="truncate">${result.name}</span> </div> `).join('')} </div> </div> <div class="flex space-x-2"> <button onclick="this.parentElement.parentElement.remove()" class="px-3 py-1 bg-gray-700 rounded text-xs hover:bg-gray-600"> å…³é—­ </button> <button onclick="window.location.reload()" class="px-3 py-1 bg-blue-600 rounded text-xs hover:bg-blue-500"> é‡æ–°æµ‹è¯• </button> </div> `; } } // è‡ªåŠ¨è¿è¡Œæµ‹è¯•ï¼ˆå»¶è¿Ÿæ‰§è¡Œç¡®ä¿é¡µé¢åŠ è½½å®Œæˆï¼‰ setTimeout(() => { window.floatingButtonsTestRunner = new FloatingButtonsTestRunner(); }, 3000); // æä¾›å…¨å±€è®¿é—® window.FloatingButtonsTestRunner = FloatingButtonsTestRunner; 