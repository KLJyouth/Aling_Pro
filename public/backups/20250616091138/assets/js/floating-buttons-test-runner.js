 class FloatingButtonsTestRunner { constructor() { this.testResults = []; this.passedTests = 0; this.failedTests = 0; this.totalTests = 0; this.init(); } init() { console.log('🧪 启动浮动按钮系统测试...'); this.runAllTests(); } async runAllTests() { // 等待所有系统加载完成 await this.waitForSystemReady(); // 运行测试套件 await this.testManagerAvailability(); await this.testButtonPositioning(); await this.testZIndexHierarchy(); await this.testButtonOverlaps(); await this.testResponsiveDesign(); await this.testButtonInteractions(); await this.testPerformance(); // 生成测试报告 this.generateTestReport(); } async waitForSystemReady() { return new Promise((resolve) => { const checkReady = () => { const managerReady = window.FloatingButtonManager && window.floatingButtonManager; const diagnosticReady = window.FloatingButtonsDiagnostic; if (managerReady && diagnosticReady) { console.log('✅ 系统就绪，开始测试'); resolve(); } else { console.log('⏳ 等待系统加载...'); setTimeout(checkReady, 500); } }; checkReady(); }); } async testManagerAvailability() { this.startTest('浮动按钮管理器可用性测试'); try { const managerExists = window.FloatingButtonManager !== undefined; const instanceExists = window.floatingButtonManager !== undefined; this.assert(managerExists, '浮动按钮管理器类应该存在'); this.assert(instanceExists, '浮动按钮管理器实例应该存在'); if (instanceExists) { const registeredButtons = window.floatingButtonManager.registeredButtons; this.assert(registeredButtons.size > 0, '应该有已注册的按钮'); console.log(`📊 已注册按钮数量: ${registeredButtons.size}`); } this.passTest('浮动按钮管理器可用性测试'); } catch (error) { this.failTest('浮动按钮管理器可用性测试', error.message); } } async testButtonPositioning() { this.startTest('按钮定位测试'); try { const buttons = document.querySelectorAll('.floating-button, [data-floating-button]'); const expectedPositions = { 'performance-dashboard-toggle': { right: '20px', top: '20px' }, 'social-customization-toggle': { right: '20px', bottom: '80px' }, 'debug-console-toggle': { right: '20px', bottom: '20px' } }; let positionCorrect = 0; let totalChecked = 0; buttons.forEach(button => { const buttonId = button.id; if (expectedPositions[buttonId]) { totalChecked++; const computedStyle = window.getComputedStyle(button); const expected = expectedPositions[buttonId]; const rightMatch = computedStyle.right === expected.right; const positionMatch = (expected.top && computedStyle.top === expected.top) || (expected.bottom && computedStyle.bottom === expected.bottom); if (rightMatch && positionMatch) { positionCorrect++; console.log(`✅ ${buttonId} 位置正确`); } else { console.log(`❌ ${buttonId} 位置错误:`, { expected, actual: { right: computedStyle.right, top: computedStyle.top, bottom: computedStyle.bottom } }); } } }); this.assert(totalChecked > 0, '应该检查到一些按钮的位置'); this.assert(positionCorrect === totalChecked, `所有检查的按钮位置都应该正确 (${positionCorrect}/${totalChecked})`); this.passTest('按钮定位测试'); } catch (error) { this.failTest('按钮定位测试', error.message); } } async testZIndexHierarchy() { this.startTest('Z-Index层级测试'); try { const buttons = document.querySelectorAll('.floating-button, [data-floating-button]'); const zIndexValues = []; buttons.forEach(button => { const zIndex = parseInt(window.getComputedStyle(button).zIndex) || 0; if (zIndex > 0) { zIndexValues.push({ element: button.id || button.className, zIndex: zIndex }); } }); // 检查是否有重复的z-index const uniqueZIndexes = new Set(zIndexValues.map(item => item.zIndex)); this.assert(uniqueZIndexes.size === zIndexValues.length, '不应该有重复的z-index值'); // 检查z-index是否在合理范围内 (1000-1040) const validRange = zIndexValues.every(item => item.zIndex >= 1000 && item.zIndex <= 1040); this.assert(validRange, 'Z-index值应该在1000-1040范围内'); console.log('📊 Z-Index层级:', zIndexValues.sort((a, b) => b.zIndex - a.zIndex)); this.passTest('Z-Index层级测试'); } catch (error) { this.failTest('Z-Index层级测试', error.message); } } async testButtonOverlaps() { this.startTest('按钮重叠检测测试'); try { const buttons = document.querySelectorAll('.floating-button, [data-floating-button]'); const buttonRects = Array.from(buttons).map(button => ({ element: button.id || button.className, rect: button.getBoundingClientRect() })); let overlaps = 0; for (let i = 0; i < buttonRects.length; i++) { for (let j = i + 1; j < buttonRects.length; j++) { const rect1 = buttonRects[i].rect; const rect2 = buttonRects[j].rect; if (this.isOverlapping(rect1, rect2)) { overlaps++; console.warn(`❌ 重叠检测: ${buttonRects[i].element} 与 ${buttonRects[j].element}`); } } } this.assert(overlaps === 0, `不应该有按钮重叠 (发现${overlaps}个重叠)`); this.passTest('按钮重叠检测测试'); } catch (error) { this.failTest('按钮重叠检测测试', error.message); } } isOverlapping(rect1, rect2) { return !(rect1.right <= rect2.left || rect2.right <= rect1.left || rect1.bottom <= rect2.top || rect2.bottom <= rect1.top); } async testResponsiveDesign() { this.startTest('响应式设计测试'); try { const originalWidth = window.innerWidth; // 模拟移动设备屏幕 const mobileMediaQuery = window.matchMedia('(max-width: 768px)'); const isMobile = mobileMediaQuery.matches; console.log(`📱 当前屏幕: ${originalWidth}px, 移动设备: ${isMobile}`); const buttons = document.querySelectorAll('.floating-button, [data-floating-button]'); let responsiveIssues = 0; buttons.forEach(button => { const rect = button.getBoundingClientRect(); const computedStyle = window.getComputedStyle(button); // 检查按钮是否超出视窗 if (rect.right > window.innerWidth || rect.bottom > window.innerHeight) { responsiveIssues++; console.warn(`❌ 按钮超出视窗: ${button.id || button.className}`); } // 检查移动设备优化 if (isMobile) { const size = parseInt(computedStyle.width); if (size < 44) { // iOS Human Interface Guidelines 最小触摸目标 console.warn(`⚠️ 移动设备按钮可能太小: ${button.id || button.className} (${size}px)`); } } }); this.assert(responsiveIssues === 0, `所有按钮都应该在视窗内 (发现${responsiveIssues}个问题)`); this.passTest('响应式设计测试'); } catch (error) { this.failTest('响应式设计测试', error.message); } } async testButtonInteractions() { this.startTest('按钮交互测试'); try { const buttons = document.querySelectorAll('.floating-button, [data-floating-button]'); let interactiveButtons = 0; buttons.forEach(button => { const hasClickHandler = button.onclick || button.getAttribute('onclick') || button.hasAttribute('data-click-action'); const hasHoverStyles = window.getComputedStyle(button, ':hover').transform !== 'none' || button.classList.contains('hover:scale-110') || button.classList.contains('touch-feedback'); if (hasClickHandler || hasHoverStyles) { interactiveButtons++; } // 检查按钮的可访问性 const hasAriaLabel = button.hasAttribute('aria-label') || button.hasAttribute('title') || button.textContent.trim().length > 0; if (!hasAriaLabel) { console.warn(`⚠️ 按钮缺少可访问性标签: ${button.id || button.className}`); } }); this.assert(interactiveButtons > 0, '应该有可交互的按钮'); console.log(`📊 可交互按钮数量: ${interactiveButtons}/${buttons.length}`); this.passTest('按钮交互测试'); } catch (error) { this.failTest('按钮交互测试', error.message); } } async testPerformance() { this.startTest('性能测试'); try { const startTime = performance.now(); // 测试管理器操作性能 if (window.floatingButtonManager) { const manager = window.floatingButtonManager; // 测试按钮注册性能 const registrationStart = performance.now(); for (let i = 0; i < 100; i++) { manager.getAvailableSlots(); } const registrationTime = performance.now() - registrationStart; this.assert(registrationTime < 100, `按钮操作应该快速完成 (${registrationTime.toFixed(2)}ms)`); // 测试内存使用 const registeredCount = manager.registeredButtons.size; console.log(`📊 已注册按钮: ${registeredCount}`); console.log(`📊 操作性能: ${registrationTime.toFixed(2)}ms`); } const totalTime = performance.now() - startTime; console.log(`📊 性能测试总时间: ${totalTime.toFixed(2)}ms`); this.passTest('性能测试'); } catch (error) { this.failTest('性能测试', error.message); } } startTest(testName) { this.currentTest = testName; this.totalTests++; console.log(`🧪 开始测试: ${testName}`); } assert(condition, message) { if (!condition) { throw new Error(message); } } passTest(testName) { this.passedTests++; this.testResults.push({ name: testName, status: 'PASSED', message: '测试通过' }); console.log(`✅ ${testName}: 通过`); } failTest(testName, error) { this.failedTests++; this.testResults.push({ name: testName, status: 'FAILED', message: error }); console.error(`❌ ${testName}: 失败 - ${error}`); } generateTestReport() { const report = { timestamp: new Date().toISOString(), summary: { total: this.totalTests, passed: this.passedTests, failed: this.failedTests, successRate: ((this.passedTests / this.totalTests) * 100).toFixed(2) + '%' }, results: this.testResults, systemInfo: { userAgent: navigator.userAgent, screenSize: `${window.innerWidth}x${window.innerHeight}`, devicePixelRatio: window.devicePixelRatio } }; console.log('📊 浮动按钮系统测试报告:', report); // 在页面上显示报告 this.displayTestReport(report); return report; } displayTestReport(report) { let reportElement = document.getElementById('testReport'); if (!reportElement) { reportElement = document.createElement('div'); reportElement.id = 'testReport'; reportElement.className = 'fixed top-4 left-4 bg-gray-900 text-white p-6 rounded-lg shadow-lg max-w-lg z-50 max-h-96 overflow-y-auto'; document.body.appendChild(reportElement); } const statusColor = report.summary.failed === 0 ? 'text-green-400' : 'text-red-400'; reportElement.innerHTML = ` <div class="mb-4"> <h3 class="text-lg font-bold mb-2">🧪 测试报告</h3> <div class="text-sm space-y-1"> <div>总测试数: ${report.summary.total}</div> <div class="text-green-400">通过: ${report.summary.passed}</div> <div class="text-red-400">失败: ${report.summary.failed}</div> <div class="${statusColor}">成功率: ${report.summary.successRate}</div> </div> </div> <div class="mb-4"> <h4 class="font-semibold mb-2">测试结果详情:</h4> <div class="space-y-1 text-xs"> ${report.results.map(result => ` <div class="flex items-center space-x-2"> <span class="${result.status === 'PASSED' ? 'text-green-400' : 'text-red-400'}"> ${result.status === 'PASSED' ? '✅' : '❌'} </span> <span class="truncate">${result.name}</span> </div> `).join('')} </div> </div> <div class="flex space-x-2"> <button onclick="this.parentElement.parentElement.remove()" class="px-3 py-1 bg-gray-700 rounded text-xs hover:bg-gray-600"> 关闭 </button> <button onclick="window.location.reload()" class="px-3 py-1 bg-blue-600 rounded text-xs hover:bg-blue-500"> 重新测试 </button> </div> `; } } // 自动运行测试（延迟执行确保页面加载完成） setTimeout(() => { window.floatingButtonsTestRunner = new FloatingButtonsTestRunner(); }, 3000); // 提供全局访问 window.FloatingButtonsTestRunner = FloatingButtonsTestRunner; 