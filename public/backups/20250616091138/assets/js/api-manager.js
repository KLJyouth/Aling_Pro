 class APIManager { constructor(options = {}) { this.options = { baseURL: '/api', timeout: 30000, maxRetries: 3, retryDelay: 1000, enableCache: true, cacheExpiry: 300000, // 5åˆ†é’Ÿ enableOffline: true, ...options }; this.cache = new Map(); this.requestQueue = new Map(); this.abortControllers = new Map(); this.isOnline = navigator.onLine; this.offlineQueue = []; this.init(); } init() { // ç›‘å¬ç½‘ç»œçŠ¶æ€ window.addEventListener('online', () => { this.isOnline = true; this.processOfflineQueue(); }); window.addEventListener('offline', () => { this.isOnline = false; }); console.log('âœ… APIç®¡ç†å™¨åˆå§‹åŒ–å®Œæˆ'); } async get(endpoint, options = {}) { return this.request('GET', endpoint, null, options); } async post(endpoint, data = null, options = {}) { return this.request('POST', endpoint, data, options); } async put(endpoint, data = null, options = {}) { return this.request('PUT', endpoint, data, options); } async delete(endpoint, options = {}) { return this.request('DELETE', endpoint, null, options); } async patch(endpoint, data = null, options = {}) { return this.request('PATCH', endpoint, data, options); } async request(method, endpoint, data = null, options = {}) { const requestOptions = { cache: this.options.enableCache, timeout: this.options.timeout, maxRetries: this.options.maxRetries, retryDelay: this.options.retryDelay, ...options }; const url = this.buildURL(endpoint); const cacheKey = this.getCacheKey(method, url, data); // æ£€æŸ¥ç¼“å­˜ if (method === 'GET' && requestOptions.cache) { const cached = this.getFromCache(cacheKey); if (cached) { return cached; } } // æ£€æŸ¥æ˜¯å¦æœ‰ç›¸åŒçš„è¯·æ±‚æ­£åœ¨è¿›è¡Œ if (this.requestQueue.has(cacheKey)) { return this.requestQueue.get(cacheKey); } // åˆ›å»ºè¯·æ±‚Promise const requestPromise = this.executeRequest(method, url, data, requestOptions); // æ·»åŠ åˆ°è¯·æ±‚é˜Ÿåˆ— this.requestQueue.set(cacheKey, requestPromise); try { const response = await requestPromise; // ç¼“å­˜GETè¯·æ±‚çš„å“åº” if (method === 'GET' && requestOptions.cache && response.success) { this.setCache(cacheKey, response); } return response; } finally { // ä»è¯·æ±‚é˜Ÿåˆ—ä¸­ç§»é™¤ this.requestQueue.delete(cacheKey); } } async executeRequest(method, url, data, options) { // å¦‚æœç¦»çº¿ä¸”å¯ç”¨ç¦»çº¿æ¨¡å¼ï¼Œæ·»åŠ åˆ°ç¦»çº¿é˜Ÿåˆ— if (!this.isOnline && this.options.enableOffline && method !== 'GET') { return this.queueOfflineRequest(method, url, data, options); } const abortController = new AbortController(); const requestId = this.generateRequestId(); this.abortControllers.set(requestId, abortController); // è®¾ç½®è¶…æ—¶ const timeoutId = setTimeout(() => { abortController.abort(); }, options.timeout); try { const response = await this.fetchWithRetry(method, url, data, { ...options, signal: abortController.signal }); clearTimeout(timeoutId); return response; } catch (error) { clearTimeout(timeoutId); if (error.name === 'AbortError') { throw new APIError('è¯·æ±‚è¶…æ—¶', 'TIMEOUT', { url, method }); } throw error; } finally { this.abortControllers.delete(requestId); } } async fetchWithRetry(method, url, data, options, retryCount = 0) { try { const fetchOptions = this.buildFetchOptions(method, data, options); const response = await fetch(url, fetchOptions); if (!response.ok) { const errorData = await this.parseErrorResponse(response); throw new APIError( errorData.message || `HTTP ${response.status}`, errorData.code || 'HTTP_ERROR', { status: response.status, statusText: response.statusText, url, method, ...errorData } ); } const responseData = await this.parseResponse(response); return this.formatResponse(responseData, response); } catch (error) { // ç½‘ç»œé”™è¯¯æˆ–è¶…æ—¶ï¼Œå°è¯•é‡è¯• if (this.shouldRetry(error, retryCount, options.maxRetries)) { const delay = this.calculateRetryDelay(retryCount, options.retryDelay); await this.sleep(delay); return this.fetchWithRetry(method, url, data, options, retryCount + 1); } throw error; } } buildFetchOptions(method, data, options) { const fetchOptions = { method, headers: { 'Content-Type': 'application/json', 'Accept': 'application/json', ...this.getDefaultHeaders(), ...options.headers }, signal: options.signal }; // æ·»åŠ è®¤è¯å¤´ const authHeader = this.getAuthHeader(); if (authHeader) { fetchOptions.headers.Authorization = authHeader; } // æ·»åŠ CSRF token const csrfToken = this.getCSRFToken(); if (csrfToken) { fetchOptions.headers['X-CSRF-Token'] = csrfToken; } // æ·»åŠ è¯·æ±‚ä½“ if (data && !['GET', 'HEAD'].includes(method)) { if (data instanceof FormData) { delete fetchOptions.headers['Content-Type']; fetchOptions.body = data; } else { fetchOptions.body = JSON.stringify(data); } } return fetchOptions; } async parseResponse(response) { const contentType = response.headers.get('content-type') || ''; if (contentType.includes('application/json')) { return response.json(); } else if (contentType.includes('text/')) { return response.text(); } else { return response.blob(); } } async parseErrorResponse(response) { try { const contentType = response.headers.get('content-type') || ''; if (contentType.includes('application/json')) { return await response.json(); } else { const text = await response.text(); return { message: text }; } } catch (error) { return { message: `HTTP ${response.status}: ${response.statusText}`, code: 'PARSE_ERROR' }; } } formatResponse(data, response) { // å¦‚æœå“åº”å·²ç»æ˜¯æ ‡å‡†æ ¼å¼ï¼Œç›´æ¥è¿”å› if (typeof data === 'object' && data !== null && 'success' in data) { return data; } // å¦åˆ™åŒ…è£…æˆæ ‡å‡†æ ¼å¼ return { success: true, data: data, timestamp: new Date().toISOString(), status: response.status, headers: Object.fromEntries(response.headers.entries()) }; } shouldRetry(error, retryCount, maxRetries) { if (retryCount >= maxRetries) { return false; } // ç½‘ç»œé”™è¯¯ã€è¶…æ—¶é”™è¯¯æˆ–5xxæœåŠ¡å™¨é”™è¯¯å¯ä»¥é‡è¯• if (error.name === 'TypeError' || error.name === 'AbortError') { return true; } if (error instanceof APIError) { const status = error.details?.status; return status >= 500 || status === 429; // æœåŠ¡å™¨é”™è¯¯æˆ–é™æµ } return false; } calculateRetryDelay(retryCount, baseDelay) { // æŒ‡æ•°é€€é¿ç®—æ³• return baseDelay * Math.pow(2, retryCount) + Math.random() * 1000; } getCacheKey(method, url, data) { const key = `${method}:${url}`; if (data) { const dataStr = typeof data === 'string' ? data : JSON.stringify(data); return `${key}:${this.hashString(dataStr)}`; } return key; } getFromCache(key) { const cached = this.cache.get(key); if (cached && Date.now() - cached.timestamp < this.options.cacheExpiry) { return cached.data; } if (cached) { this.cache.delete(key); } return null; } setCache(key, data) { this.cache.set(key, { data: data, timestamp: Date.now() }); // æ¸…ç†è¿‡æœŸç¼“å­˜ this.cleanExpiredCache(); } cleanExpiredCache() { const now = Date.now(); for (const [key, cached] of this.cache.entries()) { if (now - cached.timestamp >= this.options.cacheExpiry) { this.cache.delete(key); } } } clearCache() { this.cache.clear(); } queueOfflineRequest(method, url, data, options) { return new Promise((resolve, reject) => { this.offlineQueue.push({ method, url, data, options, resolve, reject, timestamp: Date.now() }); // è¿”å›ç¦»çº¿çŠ¶æ€å“åº” resolve({ success: false, error: 'å½“å‰ç¦»çº¿ï¼Œè¯·æ±‚å·²åŠ å…¥é˜Ÿåˆ—', code: 'OFFLINE', queued: true }); }); } async processOfflineQueue() { console.log(`ğŸ”„ å¤„ç†ç¦»çº¿é˜Ÿåˆ—ï¼Œå…± ${this.offlineQueue.length} ä¸ªè¯·æ±‚`); const queue = [...this.offlineQueue]; this.offlineQueue = []; for (const request of queue) { try { const response = await this.executeRequest( request.method, request.url, request.data, request.options ); request.resolve(response); } catch (error) { request.reject(error); } } } buildURL(endpoint) { if (endpoint.startsWith('http')) { return endpoint; } const baseURL = this.options.baseURL.replace(/\/$/, ''); const path = endpoint.replace(/^\//, ''); return `${baseURL}/${path}`; } getDefaultHeaders() { return { 'X-Requested-With': 'XMLHttpRequest', 'X-Client-Version': '1.0.0', 'X-Client-Platform': navigator.platform, 'X-Timestamp': Date.now().toString() }; } getAuthHeader() { const token = this.getToken(); return token ? `Bearer ${token}` : null; } getToken() { return localStorage.getItem('auth_token') || sessionStorage.getItem('auth_token'); } getCSRFToken() { return window.APP_CONFIG?.csrfToken || document.querySelector('meta[name="csrf-token"]')?.getAttribute('content'); } generateRequestId() { return `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`; } hashString(str) { let hash = 0; for (let i = 0; i < str.length; i++) { const char = str.charCodeAt(i); hash = ((hash << 5) - hash) + char; hash = hash & hash; // è½¬æ¢ä¸º32ä½æ•´æ•° } return hash.toString(36); } sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); } cancelRequest(requestId) { const controller = this.abortControllers.get(requestId); if (controller) { controller.abort(); this.abortControllers.delete(requestId); return true; } return false; } cancelAllRequests() { for (const [id, controller] of this.abortControllers.entries()) { controller.abort(); } this.abortControllers.clear(); } setToken(token) { localStorage.setItem('auth_token', token); } removeToken() { localStorage.removeItem('auth_token'); sessionStorage.removeItem('auth_token'); } isAuthenticated() { return !!this.getToken(); } getStats() { return { cacheSize: this.cache.size, activeRequests: this.requestQueue.size, offlineQueueSize: this.offlineQueue.length, abortControllersCount: this.abortControllers.size, isOnline: this.isOnline }; } } class APIError extends Error { constructor(message, code = 'UNKNOWN_ERROR', details = {}) { super(message); this.name = 'APIError'; this.code = code; this.details = details; this.timestamp = new Date().toISOString(); } toJSON() { return { name: this.name, message: this.message, code: this.code, details: this.details, timestamp: this.timestamp, stack: this.stack }; } } class ChatAPI extends APIManager { constructor(options = {}) { super({ baseURL: '/api/chat', ...options }); this.conversationId = null; this.messageHistory = []; } async sendMessage(message, options = {}) { const requestData = { message, conversation_id: this.conversationId, context: this.getContext(), ...options }; try { const response = await this.post('/send', requestData, { timeout: 60000, // èŠå¤©è¯·æ±‚å¯èƒ½éœ€è¦æ›´é•¿æ—¶é—´ cache: false // èŠå¤©æ¶ˆæ¯ä¸ç¼“å­˜ }); // æ›´æ–°æ¶ˆæ¯å†å² this.addToHistory('user', message); if (response.success && response.data?.content) { this.addToHistory('assistant', response.data.content); } return response; } catch (error) { console.error('å‘é€æ¶ˆæ¯å¤±è´¥:', error); throw error; } } async getConversations(page = 1, limit = 20) { return this.get('/conversations', { params: { page, limit } }); } async getConversation(conversationId) { return this.get(`/conversations/${conversationId}`); } async createConversation(title = null) { const response = await this.post('/conversations', { title }); if (response.success) { this.conversationId = response.data.id; this.messageHistory = []; } return response; } async deleteConversation(conversationId) { return this.delete(`/conversations/${conversationId}`); } async updateConversationTitle(conversationId, title) { return this.patch(`/conversations/${conversationId}`, { title }); } getContext() { return { history: this.messageHistory.slice(-10), // æœ€è¿‘10æ¡æ¶ˆæ¯ timestamp: new Date().toISOString(), user_agent: navigator.userAgent, timezone: Intl.DateTimeFormat().resolvedOptions().timeZone }; } addToHistory(role, content) { this.messageHistory.push({ role, content, timestamp: new Date().toISOString() }); // é™åˆ¶å†å²è®°å½•é•¿åº¦ if (this.messageHistory.length > 50) { this.messageHistory = this.messageHistory.slice(-40); } } clearHistory() { this.messageHistory = []; } setConversationId(id) { this.conversationId = id; } getMessageHistory() { return [...this.messageHistory]; } } class UserAPI extends APIManager { constructor(options = {}) { super({ baseURL: '/api/user', ...options }); } async login(email, password, remember = false) { const response = await this.post('/login', { email, password, remember }, { cache: false }); if (response.success && response.data?.token) { this.setToken(response.data.token); } return response; } async register(userData) { return this.post('/register', userData, { cache: false }); } async logout() { try { await this.post('/logout', {}, { cache: false }); } finally { this.removeToken(); } } async getProfile() { return this.get('/profile'); } async updateProfile(userData) { return this.patch('/profile', userData, { cache: false }); } async changePassword(currentPassword, newPassword) { return this.post('/change-password', { current_password: currentPassword, new_password: newPassword }, { cache: false }); } async forgotPassword(email) { return this.post('/forgot-password', { email }, { cache: false }); } async resetPassword(token, password) { return this.post('/reset-password', { token, password }, { cache: false }); } async verifyEmail(token) { return this.post('/verify-email', { token }, { cache: false }); } async getSettings() { return this.get('/settings'); } async updateSettings(settings) { return this.patch('/settings', settings, { cache: false }); } } class DocumentAPI extends APIManager { constructor(options = {}) { super({ baseURL: '/api/documents', ...options }); } async getDocuments(filters = {}) { return this.get('/', { params: filters }); } async getDocument(documentId) { return this.get(`/${documentId}`); } async uploadDocument(file, metadata = {}) { const formData = new FormData(); formData.append('file', file); Object.keys(metadata).forEach(key => { formData.append(key, metadata[key]); }); return this.post('/upload', formData, { timeout: 300000, // 5åˆ†é’Ÿä¸Šä¼ è¶…æ—¶ cache: false }); } async deleteDocument(documentId) { return this.delete(`/${documentId}`); } async updateDocument(documentId, data) { return this.patch(`/${documentId}`, data, { cache: false }); } async searchDocuments(query, filters = {}) { return this.post('/search', { query, filters }); } async getDocumentContent(documentId) { return this.get(`/${documentId}/content`); } async analyzeDocument(documentId, analysisType = 'summary') { return this.post(`/${documentId}/analyze`, { type: analysisType }, { timeout: 120000 // 2åˆ†é’Ÿåˆ†æè¶…æ—¶ }); } } // å¯¼å‡ºç±» window.APIManager = APIManager; window.APIError = APIError; window.ChatAPI = ChatAPI; window.UserAPI = UserAPI; window.DocumentAPI = DocumentAPI; // åˆ›å»ºå…¨å±€APIå®ä¾‹ window.api = { chat: new ChatAPI(), user: new UserAPI(), document: new DocumentAPI(), general: new APIManager() }; console.log('âœ… APIç®¡ç†æ¨¡å—å·²åŠ è½½'); 