class QuantumChatIntegrator { constructor() { this.wsConnection = null; this.quantumBallSystem = null; this.chatSystem = null; this.isConnected = false; this.reconnectAttempts = 0; this.maxReconnectAttempts = 5; this.reconnectInterval = 3000; this.quantumSphereRef = null; this.currentAnimation = null; this.animationQueue = []; this.isAnimating = false; this.eventListeners = new Map(); this.init(); } setQuantumSphereReference(quantumSphereObjects) { this.quantumSphereRef = quantumSphereObjects; console.log('ğŸ¯ é‡å­çƒç³»ç»Ÿå¼•ç”¨å·²è®¾ç½®', Object.keys(quantumSphereObjects)); } async init() { console.log('ğŸŒŠ åˆå§‹åŒ–é‡å­çƒ-èŠå¤©é›†æˆç³»ç»Ÿ...'); await this.waitForQuantumBallSystem(); await this.initWebSocketConnection(); this.setupChatEventListeners(); this.setupPageEventListeners(); console.log('âœ… é‡å­çƒ-èŠå¤©é›†æˆç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ'); } async waitForQuantumBallSystem() { return new Promise((resolve) => { const checkQuantumSystem = () => { const hasQuantumParticleSystem = window.quantumParticleSystem || document.getElementById('backgroundContainer') || window.QuantumParticleSystem; const hasQuantumAnimationSystem = window.quantumAnimation || window.QuantumAnimationSystem; if (hasQuantumParticleSystem && hasQuantumAnimationSystem) { this.quantumBallSystem = window.quantumParticleSystem || window.QuantumParticleSystem || this.createQuantumBallProxy(); console.log('ğŸ¯ é‡å­çƒç³»ç»Ÿå’ŒåŠ¨ç”»ç³»ç»Ÿå·²å°±ç»ª'); resolve(); } else { console.log('â³ ç­‰å¾…é‡å­ç³»ç»Ÿåˆå§‹åŒ–...', { quantumParticleSystem: !!hasQuantumParticleSystem, quantumAnimationSystem: !!hasQuantumAnimationSystem }); setTimeout(checkQuantumSystem, 500); } }; checkQuantumSystem(); }); } createQuantumBallProxy() { return { updateState: (state) => { console.log('ğŸ“Š é‡å­çƒçŠ¶æ€æ›´æ–°:', state); this.triggerVisualFeedback(state); }, triggerAnimation: (type, data) => { console.log('ğŸ¬ è§¦å‘é‡å­çƒåŠ¨ç”»:', type, data); this.triggerChatEvent(type, data); } }; } triggerVisualFeedback(state) { console.log('ğŸ¨ åº”ç”¨è§†è§‰åé¦ˆ:', state); const container = document.getElementById('backgroundContainer'); if (container && state.mode) { container.className = `quantum-${state.mode}`; if (state.colors && state.colors.length > 0) { this.applyColorAnimation(container, state.colors); } if (state.effects && state.effects.length > 0) { this.applyEffectAnimation(container, state.effects); } } const quantumLoader = document.getElementById('quantumLoader'); if (quantumLoader && state.visible) { quantumLoader.style.display = 'flex'; setTimeout(() => { quantumLoader.style.display = 'none'; }, state.duration || 2000); } } async initWebSocketConnection() { try { const wsUrl = `ws: console.log('ğŸ”Œ è¿æ¥WebSocket:', wsUrl); this.wsConnection = new WebSocket(wsUrl); this.wsConnection.onopen = () => { console.log('âœ… WebSocketè¿æ¥å·²å»ºç«‹'); this.isConnected = true; this.reconnectAttempts = 0; this.sendWebSocketMessage({ type: 'quantumBallSync', action: 'init', data: { page: window.location.pathname, timestamp: new Date().toISOString() } }); this.emit('connected'); }; this.wsConnection.onmessage = (event) => { this.handleWebSocketMessage(event); }; this.wsConnection.onclose = () => { console.log('ğŸ”Œ WebSocketè¿æ¥å·²å…³é—­'); this.isConnected = false; this.scheduleReconnect(); this.emit('disconnected'); }; this.wsConnection.onerror = (error) => { console.error('âŒ WebSocketè¿æ¥é”™è¯¯:', error); this.emit('error', error); }; } catch (error) { console.error('âŒ WebSocketåˆå§‹åŒ–å¤±è´¥:', error); this.scheduleReconnect(); } } scheduleReconnect() { if (this.reconnectAttempts < this.maxReconnectAttempts) { this.reconnectAttempts++; console.log(`ğŸ”„ å°è¯•ç¬¬${this.reconnectAttempts}æ¬¡é‡è¿...`); setTimeout(() => { this.initWebSocketConnection(); }, this.reconnectInterval * this.reconnectAttempts); } else { console.error('âŒ WebSocketé‡è¿å¤±è´¥ï¼Œå·²è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°'); this.emit('reconnectFailed'); } } handleWebSocketMessage(event) { try { const message = JSON.parse(event.data); console.log('ğŸ“¨ æ”¶åˆ°WebSocketæ¶ˆæ¯:', message.type); switch (message.type) { case 'quantumBallUpdate': this.handleQuantumBallUpdate(message.data); break; case 'quantumBallAnimation': this.handleQuantumBallAnimation(message); break; case 'chatResponse': this.handleChatResponse(message.data); break; case 'welcome': console.log('ğŸ‰ WebSocketæ¬¢è¿æ¶ˆæ¯:', message.message); break; case 'pong': break; default: console.log('ğŸ“¨ æœªå¤„ç†çš„æ¶ˆæ¯ç±»å‹:', message.type); } } catch (error) { console.error('âŒ å¤„ç†WebSocketæ¶ˆæ¯å¤±è´¥:', error); } } handleQuantumBallUpdate(data) { console.log('ğŸŒŠ é‡å­çƒçŠ¶æ€æ›´æ–°:', data); if (this.quantumBallSystem && this.quantumBallSystem.updateState) { this.quantumBallSystem.updateState(data); } else { this.applyQuantumBallStyles(data); } this.emit('quantumBallUpdate', data); } handleQuantumBallAnimation(message) { console.log('ğŸ¬ é‡å­çƒåŠ¨ç”»:', message.eventType); const { eventType, animation, chatData } = message; this.applyAnimationToQuantumSphere(eventType, animation); this.animationQueue.push({ type: eventType, animation: animation, data: chatData, timestamp: Date.now() }); this.processAnimationQueue(); this.emit('quantumBallAnimation', { eventType, animation, chatData }); } async processAnimationQueue() { if (this.isAnimating || this.animationQueue.length === 0) { return; } this.isAnimating = true; while (this.animationQueue.length > 0) { const animationItem = this.animationQueue.shift(); await this.executeAnimation(animationItem); } this.isAnimating = false; } async executeAnimation(animationItem) { const { type, animation, data } = animationItem; console.log(`ğŸ­ æ‰§è¡ŒåŠ¨ç”»: ${type}`, animation); try { if (this.quantumBallSystem && this.quantumBallSystem.triggerAnimation) { this.quantumBallSystem.triggerAnimation(type, animation); } else { await this.executeAnimationFallback(type, animation); } if (animation.duration) { await new Promise(resolve => setTimeout(resolve, animation.duration)); } } catch (error) { console.error('âŒ æ‰§è¡ŒåŠ¨ç”»å¤±è´¥:', error); } } async executeAnimationFallback(type, animation) { const container = document.getElementById('backgroundContainer'); if (!container) return; const animationClass = `quantum-animation-${type}`; container.classList.add(animationClass); if (animation.colors) { this.applyColorAnimation(container, animation.colors); } if (animation.effects) { this.applyEffectAnimation(container, animation.effects); } setTimeout(() => { container.classList.remove(animationClass); }, animation.duration || 2000); } applyColorAnimation(container, colors) { const colorMappings = { 'tech-blue': '#0ea5e9', 'quantum': '#6b46c1', 'longling': '#8b5cf6', 'red': '#ef4444', 'orange': '#f97316' }; const cssColors = colors.map(color => colorMappings[color] || color).join(', '); container.style.background = `linear-gradient(45deg, ${cssColors})`; container.style.opacity = '0.3'; setTimeout(() => { container.style.background = ''; container.style.opacity = ''; }, 2000); } applyEffectAnimation(container, effects) { effects.forEach(effect => { switch (effect) { case 'pulse': container.style.animation = 'pulse 1s ease-in-out infinite'; break; case 'shake': container.style.animation = 'shake 0.5s ease-in-out infinite'; break; case 'glow': container.style.boxShadow = '0 0 20px rgba(107, 70, 193, 0.5)'; break; } }); setTimeout(() => { container.style.animation = ''; container.style.boxShadow = ''; }, 2000); } setupChatEventListeners() { console.log('ğŸ“¡ è®¾ç½®èŠå¤©äº‹ä»¶ç›‘å¬å™¨...'); document.addEventListener('chatMessageSent', (event) => { this.handleChatMessageSent(event.detail); }); document.addEventListener('chatResponseReceived', (event) => { this.handleChatResponseReceived(event.detail); }); document.addEventListener('chatError', (event) => { this.handleChatError(event.detail); }); if (window.chatInstance) { this.integrateChatInstance(window.chatInstance); } document.addEventListener('chatInstanceCreated', (event) => { this.integrateChatInstance(event.detail); }); } integrateChatInstance(chatInstance) { console.log('ğŸ”— é›†æˆèŠå¤©å®ä¾‹...'); this.chatSystem = chatInstance; if (chatInstance.core && chatInstance.core.on) { chatInstance.core.on('messageSent', (data) => { this.triggerChatEvent('userMessageSent', data); }); chatInstance.core.on('responseReceived', (data) => { this.triggerChatEvent('aiResponseReceived', data); }); chatInstance.core.on('error', (data) => { this.triggerChatEvent('chatError', data); }); } if (chatInstance.api && chatInstance.api.sendMessage) { const originalSendMessage = chatInstance.api.sendMessage.bind(chatInstance.api); chatInstance.api.sendMessage = async (message, options = {}) => { this.triggerChatEvent('userMessageSent', { message, options }); try { this.triggerChatEvent('aiThinking', { message }); const result = await originalSendMessage(message, options); this.triggerChatEvent('aiResponseReceived', { message, response: result, options }); return result; } catch (error) { this.triggerChatEvent('chatError', { message, error, options }); throw error; } }; } } handleChatMessageSent(data) { console.log('ğŸ’¬ ç”¨æˆ·æ¶ˆæ¯å‘é€:', data); this.triggerChatEvent('userMessageSent', data); } handleChatResponseReceived(data) { console.log('ğŸ¤– AIå“åº”æ¥æ”¶:', data); this.triggerChatEvent('aiResponseReceived', data); } handleChatError(data) { console.log('âŒ èŠå¤©é”™è¯¯:', data); this.triggerChatEvent('chatError', data); } triggerChatEvent(eventType, data) { console.log(`ğŸš€ è§¦å‘èŠå¤©äº‹ä»¶: ${eventType}`, data); if (this.quantumSphereRef) { this.applyAnimationToQuantumSphere(eventType, data); } if (this.isConnected && this.wsConnection) { this.sendWebSocketMessage({ type: 'chatEvent', eventType: eventType, data: data, timestamp: new Date().toISOString() }); } else { console.log('ğŸ¨ ä½¿ç”¨æœ¬åœ°åŠ¨ç”»æ•ˆæœ (WebSocketæœªè¿æ¥)'); this.applyLocalAnimationEffect(eventType, data); } document.dispatchEvent(new CustomEvent(`quantumChatEvent:${eventType}`, { detail: { eventType, data, timestamp: new Date().toISOString() } })); } applyLocalAnimationEffect(eventType, data) { const backgroundContainer = document.getElementById('backgroundContainer') || document.getElementById('minimalistBackground'); if (!backgroundContainer) { console.warn('âš ï¸ æœªæ‰¾åˆ°èƒŒæ™¯å®¹å™¨ï¼Œè·³è¿‡åŠ¨ç”»æ•ˆæœ'); return; } const animationClass = `chat-event-${eventType}`; backgroundContainer.classList.add(animationClass); switch (eventType) { case 'userMessageSent': backgroundContainer.style.filter = 'hue-rotate(30deg) brightness(1.1)'; break; case 'aiThinking': backgroundContainer.style.filter = 'hue-rotate(180deg) brightness(0.9)'; break; case 'aiResponseReceived': backgroundContainer.style.filter = 'hue-rotate(120deg) brightness(1.2)'; break; case 'chatError': backgroundContainer.style.filter = 'hue-rotate(0deg) brightness(1.3) saturate(1.5)'; break; } setTimeout(() => { backgroundContainer.classList.remove(animationClass); backgroundContainer.style.filter = ''; }, 2000); } setupPageEventListeners() { document.addEventListener('visibilitychange', () => { if (document.hidden) { this.triggerQuantumBallMode('idle'); } else { this.triggerQuantumBallMode('active'); } }); window.addEventListener('beforeunload', () => { if (this.wsConnection) { this.wsConnection.close(); } }); } triggerQuantumBallMode(mode) { this.sendWebSocketMessage({ type: 'quantumBallSync', data: { mode: mode, timestamp: new Date().toISOString() } }); } sendWebSocketMessage(message) { if (this.wsConnection && this.wsConnection.readyState === WebSocket.OPEN) { this.wsConnection.send(JSON.stringify(message)); } else { console.warn('âš ï¸ WebSocketæœªè¿æ¥ï¼Œæ¶ˆæ¯å‘é€å¤±è´¥:', message); } } on(event, callback) { if (!this.eventListeners.has(event)) { this.eventListeners.set(event, []); } this.eventListeners.get(event).push(callback); } off(event, callback) { if (this.eventListeners.has(event)) { const callbacks = this.eventListeners.get(event); const index = callbacks.indexOf(callback); if (index > -1) { callbacks.splice(index, 1); } } } emit(event, data) { if (this.eventListeners.has(event)) { this.eventListeners.get(event).forEach(callback => { try { callback(data); } catch (error) { console.error(`âŒ äº‹ä»¶å¤„ç†å™¨é”™è¯¯ (${event}):`, error); } }); } } async callQuantumAPI(endpoint, method = 'GET', data = null) { try { const url = `/api/quantum${endpoint}`; const options = { method: method, headers: { 'Content-Type': 'application/json' } }; if (data && method !== 'GET') { options.body = JSON.stringify(data); } const response = await fetch(url, options); const result = await response.json(); console.log(`ğŸ“¡ é‡å­çƒAPIè°ƒç”¨: ${endpoint}`, result); return result; } catch (error) { console.error(`âŒ é‡å­çƒAPIè°ƒç”¨å¤±è´¥: ${endpoint}`, error); throw error; } } async triggerUserMessageAnimation(message) { console.log('ğŸ—¨ï¸ è§¦å‘ç”¨æˆ·æ¶ˆæ¯åŠ¨ç”»', message); return this.triggerChatEvent('userMessageSent', { message }); } async triggerAIThinkingAnimation() { console.log('ğŸ¤” è§¦å‘AIæ€è€ƒåŠ¨ç”»'); return this.triggerChatEvent('aiThinking', {}); } async triggerAIResponseAnimation(response) { console.log('ğŸ¤– è§¦å‘AIå“åº”åŠ¨ç”»', response); return this.triggerChatEvent('aiResponseReceived', { response }); } async triggerErrorAnimation(error) { console.log('âŒ è§¦å‘é”™è¯¯åŠ¨ç”»', error); return this.triggerChatEvent('chatError', { error }); } applyAnimationToQuantumSphere(animationType, animationData) { if (!this.quantumSphereRef) { console.warn('âš ï¸ é¦–é¡µé‡å­çƒç³»ç»Ÿå¼•ç”¨æœªè®¾ç½®'); return; } const { quantumSphere, particleCloud, waveForm, connectionLines, lightBeams } = this.quantumSphereRef; switch (animationType) { case 'userMessageSent': this.applyUserMessageAnimation(quantumSphere, particleCloud); break; case 'aiThinking': this.applyAIThinkingAnimation(waveForm, connectionLines); break; case 'aiResponseReceived': this.applyAIResponseAnimation(quantumSphere, lightBeams); break; case 'chatError': this.applyErrorAnimation(quantumSphere, particleCloud); break; } } applyUserMessageAnimation(quantumSphere, particleCloud) { if (quantumSphere && quantumSphere.mesh) { quantumSphere.mesh.material.color.setHex(0x0ea5e9); quantumSphere.mesh.scale.setScalar(1.2); setTimeout(() => { quantumSphere.mesh.material.color.setHex(0x6C13FF); quantumSphere.mesh.scale.setScalar(1.0); }, 1000); } if (particleCloud && particleCloud.particles) { particleCloud.particles.forEach(particle => { particle.material.color.setHex(0x0ea5e9); particle.userData.speed *= 1.5; }); setTimeout(() => { particleCloud.particles.forEach(particle => { particle.material.color.setHex(Math.random() > 0.5 ? 0x6C13FF : 0x00D4FF); particle.userData.speed /= 1.5; }); }, 2000); } } applyAIThinkingAnimation(waveForm, connectionLines) { if (waveForm && waveForm.waveMesh) { waveForm.time += 0.1; waveForm.waveMesh.material.color.setHex(0x6b46c1); waveForm.waveMesh.material.opacity = 0.8; } if (connectionLines && connectionLines.lines) { connectionLines.lines.forEach(line => { line.material.color.setHex(0x8b5cf6); line.userData.rotationSpeed *= 2; }); } } applyAIResponseAnimation(quantumSphere, lightBeams) { if (quantumSphere && quantumSphere.mesh) { quantumSphere.mesh.material.color.setHex(0x10b981); if (quantumSphere.core) { quantumSphere.core.material.color.setHex(0x34d399); } setTimeout(() => { quantumSphere.mesh.material.color.setHex(0x6C13FF); if (quantumSphere.core) { quantumSphere.core.material.color.setHex(0xFF2B75); } }, 2000); } if (lightBeams && lightBeams.beams) { lightBeams.beams.forEach(beam => { beam.material.color.setHex(0x10b981); beam.material.opacity = 1.0; }); setTimeout(() => { lightBeams.beams.forEach(beam => { beam.material.color.setHex(0x00D4FF); beam.material.opacity = 0.6; }); }, 1500); } } applyErrorAnimation(quantumSphere, particleCloud) { if (quantumSphere && quantumSphere.mesh) { quantumSphere.mesh.material.color.setHex(0xef4444); let shakeCount = 0; const shakeInterval = setInterval(() => { quantumSphere.mesh.position.x += (Math.random() - 0.5) * 0.2; quantumSphere.mesh.position.y += (Math.random() - 0.5) * 0.2; shakeCount++; if (shakeCount > 10) { clearInterval(shakeInterval); quantumSphere.mesh.position.set(0, 0, -5); quantumSphere.mesh.material.color.setHex(0x6C13FF); } }, 100); } if (particleCloud && particleCloud.particles) { particleCloud.particles.forEach(particle => { particle.material.color.setHex(0xef4444); particle.userData.speed *= 0.5; }); setTimeout(() => { particleCloud.particles.forEach(particle => { particle.material.color.setHex(Math.random() > 0.5 ? 0x6C13FF : 0x00D4FF); particle.userData.speed *= 2; }); }, 3000); } } testIntegration() { console.log('ğŸ§ª æµ‹è¯•é‡å­çƒ-èŠå¤©é›†æˆ...'); const testAnimations = [ 'userMessageSent', 'aiThinking', 'aiResponseReceived', 'chatError' ]; testAnimations.forEach((animation, index) => { setTimeout(() => { this.triggerChatEvent(animation, { test: true, message: `æµ‹è¯•åŠ¨ç”»: ${animation}`, timestamp: new Date().toISOString() }); }, index * 3000); }); } getSystemStatus() { return { isConnected: this.isConnected, reconnectAttempts: this.reconnectAttempts, hasQuantumBallSystem: !!this.quantumBallSystem, hasChatSystem: !!this.chatSystem, animationQueueLength: this.animationQueue.length, isAnimating: this.isAnimating, currentPage: window.location.pathname }; } async initialize() { console.log('ğŸš€ QuantumChatIntegrator å…¬å…±åˆå§‹åŒ–å¼€å§‹...'); try { if (this.isConnected) { console.log('âœ… QuantumChatIntegrator å·²ç»åˆå§‹åŒ–ï¼Œè·³è¿‡é‡å¤åˆå§‹åŒ–'); return Promise.resolve(); } await this.init(); console.log('âœ… QuantumChatIntegrator å…¬å…±åˆå§‹åŒ–å®Œæˆ'); return Promise.resolve(); } catch (error) { console.error('âŒ QuantumChatIntegrator åˆå§‹åŒ–å¤±è´¥:', error); throw error; } } } let quantumChatIntegrator = null; document.addEventListener('DOMContentLoaded', () => { setTimeout(() => { try { quantumChatIntegrator = new QuantumChatIntegrator(); window.quantumChatIntegrator = quantumChatIntegrator; console.log('ğŸŒŠ é‡å­çƒ-èŠå¤©é›†æˆå™¨å·²å…¨å±€åˆå§‹åŒ–'); document.dispatchEvent(new CustomEvent('quantumChatIntegratorReady', { detail: quantumChatIntegrator })); } catch (error) { console.error('âŒ é‡å­çƒ-èŠå¤©é›†æˆå™¨åˆå§‹åŒ–å¤±è´¥:', error); } }, 1000); }); if (typeof window !== 'undefined') { window.initializeQuantumChatIntegrator = function() { if (window.quantumChatIntegrator) { console.log('ğŸŒŠ é‡å­çƒ-èŠå¤©é›†æˆå™¨æ‰‹åŠ¨åˆå§‹åŒ–...'); return window.quantumChatIntegrator; } else { console.warn('âš ï¸ é‡å­çƒ-èŠå¤©é›†æˆå™¨å°šæœªå°±ç»ªï¼Œè¯·ç¨åé‡è¯•'); return null; } } handleQuantumBallClick(event) { console.log('ğŸ¯ é‡å­çƒç‚¹å‡»äº‹ä»¶è§¦å‘', event); if (event) { event.preventDefault(); event.stopPropagation(); } this.triggerQuantumAnimation('click', { position: event ? { x: event.clientX, y: event.clientY } : null, intensity: 'high', duration: 2000 }); this.showChatInterface(); if (this.wsConnection && this.wsConnection.readyState === WebSocket.OPEN) { this.wsConnection.send(JSON.stringify({ type: 'quantum_ball_interaction', timestamp: Date.now(), data: { action: 'click', position: event ? { x: event.clientX, y: event.clientY } : null } })); } return true; } async initializeChatSystem() { console.log('ğŸ’¬ åˆå§‹åŒ–èŠå¤©ç³»ç»Ÿ...'); try { const chatContainer = document.getElementById('chat-container'); const floatingButton = document.getElementById('floating-chat-button'); const quantumOrb = document.getElementById('quantum-orb-container'); if (!chatContainer || !floatingButton) { console.warn('âš ï¸ èŠå¤©ç•Œé¢å…ƒç´ æœªæ‰¾åˆ°ï¼Œåˆ›å»ºåŸºç¡€ç»“æ„...'); this.createChatInterface(); } this.setupChatInterfaceEvents(); await this.loadChatHistory(); await this.connectToChatService(); if (quantumOrb) { quantumOrb.style.display = 'block'; setTimeout(() => { quantumOrb.style.opacity = '1'; }, 100); } console.log('âœ… èŠå¤©ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ'); return true; } catch (error) { console.error('âŒ èŠå¤©ç³»ç»Ÿåˆå§‹åŒ–å¤±è´¥:', error); return false; } } connectToQuantumOrb() { console.log('ğŸ”— è¿æ¥é‡å­çƒç³»ç»Ÿ...'); const quantumOrb = document.getElementById('quantum-orb-container'); if (quantumOrb) { quantumOrb.addEventListener('click', (event) => { this.handleQuantumBallClick(event); }); quantumOrb.addEventListener('mouseenter', () => { this.triggerQuantumAnimation('hover', { intensity: 'medium' }); }); quantumOrb.addEventListener('mouseleave', () => { this.triggerQuantumAnimation('idle', { intensity: 'low' }); }); quantumOrb.style.display = 'block'; console.log('âœ… é‡å­çƒè¿æ¥æˆåŠŸ'); return true; } else { console.warn('âš ï¸ é‡å­çƒå®¹å™¨æœªæ‰¾åˆ°'); return false; } } createChatInterface() { console.log('ğŸ—ï¸ åˆ›å»ºèŠå¤©ç•Œé¢...'); if (document.getElementById('chat-container')) { return; } const chatHTML = ` <div id="floating-chat-button" class="fixed bottom-6 right-6 z-50 w-14 h-14 bg-gradient-to-br from-tech-blue to-purple-500 rounded-full shadow-lg cursor-pointer hover:scale-110 transition-all duration-300 flex items-center justify-center"> <i class="fas fa-comments text-white text-xl"></i> <div class="absolute -top-1 -right-1 w-4 h-4 bg-green-400 rounded-full animate-pulse"></div> </div> <div id="chat-container" class="fixed bottom-6 right-6 z-40 w-80 h-96 bg-gradient-to-br from-gray-900 to-gray-800 rounded-lg shadow-2xl border border-tech-blue opacity-0 transform translate-y-8 transition-all duration-300" style="display: none;"> <div class="chat-header p-4 border-b border-gray-700 flex justify-between items-center"> <h3 class="text-white font-semibold">æ™ºèƒ½åŠ©æ‰‹</h3> <button id="close-chat" class="text-gray-400 hover:text-white transition-colors"> <i class="fas fa-times"></i> </button> </div> <div class="chat-messages p-4 h-64 overflow-y-auto"> <div class="message bot-message mb-3"> <div class="message-content bg-gray-700 p-3 rounded-lg text-white text-sm"> æ‚¨å¥½ï¼æˆ‘æ˜¯ç‘å‡Œç§‘æŠ€çš„æ™ºèƒ½åŠ©æ‰‹ï¼Œæœ‰ä»€ä¹ˆå¯ä»¥å¸®åŠ©æ‚¨çš„å—ï¼Ÿ </div> </div> </div> <div class="chat-input p-4 border-t border-gray-700"> <div class="flex gap-2"> <input type="text" id="chat-input" placeholder="è¾“å…¥æ¶ˆæ¯..." class="flex-1 bg-gray-700 text-white p-2 rounded border border-gray-600 focus:border-tech-blue focus:outline-none"> <button id="send-chat" class="bg-tech-blue text-white px-4 py-2 rounded hover:bg-blue-600 transition-colors"> <i class="fas fa-paper-plane"></i> </button> </div> </div> </div> `; document.body.insertAdjacentHTML('beforeend', chatHTML); console.log('âœ… èŠå¤©ç•Œé¢åˆ›å»ºå®Œæˆ'); } setupChatInterfaceEvents() { const floatingButton = document.getElementById('floating-chat-button'); const chatContainer = document.getElementById('chat-container'); const closeButton = document.getElementById('close-chat'); const sendButton = document.getElementById('send-chat'); const chatInput = document.getElementById('chat-input'); if (floatingButton) { floatingButton.addEventListener('click', () => { this.showChatInterface(); }); } if (closeButton) { closeButton.addEventListener('click', () => { this.hideChatInterface(); }); } if (sendButton) { sendButton.addEventListener('click', () => { this.sendMessage(); }); } if (chatInput) { chatInput.addEventListener('keypress', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); this.sendMessage(); } }); } } showChatInterface() { const chatContainer = document.getElementById('chat-container'); const floatingButton = document.getElementById('floating-chat-button'); if (chatContainer) { chatContainer.style.display = 'block'; setTimeout(() => { chatContainer.style.opacity = '1'; chatContainer.style.transform = 'translateY(0)'; }, 10); } if (floatingButton) { floatingButton.style.display = 'none'; } this.triggerQuantumAnimation('chat_open', { intensity: 'high' }); } hideChatInterface() { const chatContainer = document.getElementById('chat-container'); const floatingButton = document.getElementById('floating-chat-button'); if (chatContainer) { chatContainer.style.opacity = '0'; chatContainer.style.transform = 'translateY(8px)'; setTimeout(() => { chatContainer.style.display = 'none'; }, 300); } if (floatingButton) { floatingButton.style.display = 'flex'; } this.triggerQuantumAnimation('chat_close', { intensity: 'medium' }); } sendMessage() { const chatInput = document.getElementById('chat-input'); const messagesContainer = document.querySelector('.chat-messages'); if (!chatInput || !messagesContainer) return; const message = chatInput.value.trim(); if (!message) return; this.addMessageToChat('user', message); chatInput.value = ''; if (this.wsConnection && this.wsConnection.readyState === WebSocket.OPEN) { this.wsConnection.send(JSON.stringify({ type: 'chat_message', message: message, timestamp: Date.now() })); } this.triggerQuantumAnimation('message_sent', { intensity: 'medium', message: message }); } addMessageToChat(sender, message) { const messagesContainer = document.querySelector('.chat-messages'); if (!messagesContainer) return; const messageElement = document.createElement('div'); messageElement.className = `message ${sender}-message mb-3`; const isUser = sender === 'user'; messageElement.innerHTML = ` <div class="message-content ${isUser ? 'bg-tech-blue ml-8' : 'bg-gray-700 mr-8'} p-3 rounded-lg text-white text-sm"> ${message} </div> `; messagesContainer.appendChild(messageElement); messagesContainer.scrollTop = messagesContainer.scrollHeight; } async loadChatHistory() { try { const history = localStorage.getItem('chat_history'); if (history) { const messages = JSON.parse(history); const messagesContainer = document.querySelector('.chat-messages'); if (messagesContainer && messages.length > 0) { messagesContainer.innerHTML = ''; messages.forEach(msg => { this.addMessageToChat(msg.sender, msg.message); }); } } } catch (error) { console.error('åŠ è½½èŠå¤©å†å²å¤±è´¥:', error); } } async connectToChatService() { try { console.log('ğŸ”— è¿æ¥åˆ°èŠå¤©æœåŠ¡...'); } catch (error) { console.error('è¿æ¥èŠå¤©æœåŠ¡å¤±è´¥:', error); } } triggerQuantumAnimation(type, data = {}) { console.log('ğŸ¬ è§¦å‘é‡å­åŠ¨ç”»:', type, data); const quantumOrb = document.getElementById('quantum-orb-container'); if (quantumOrb) { const core = quantumOrb.querySelector('.orb-core'); const ring = quantumOrb.querySelector('.orb-ring'); const glow = quantumOrb.querySelector('.orb-glow'); switch (type) { case 'click': if (core) core.style.animation = 'pulse 0.5s ease-in-out'; if (ring) ring.style.animation = 'spin 1s linear infinite'; break; case 'hover': if (glow) glow.style.opacity = '0.4'; break; case 'idle': if (glow) glow.style.opacity = '0.2'; break; case 'message_sent': if (core) { core.style.background = 'linear-gradient(45deg, #00ff88, #0088ff)'; setTimeout(() => { core.style.background = ''; }, 1000); } break; } } if (window.quantumParticleSystem) { try { window.quantumParticleSystem.triggerAnimation(type, data); } catch (error) { console.warn('é‡å­ç²’å­ç³»ç»ŸåŠ¨ç”»è§¦å‘å¤±è´¥:', error); } } } triggerChatEvent(eventType, data = {}) { console.log('ğŸ“¡ è§¦å‘èŠå¤©äº‹ä»¶:', eventType, data); switch (eventType) { case 'click': case 'quantum_ball_click': this.handleQuantumBallClick(data.event); break; case 'message_sent': this.triggerQuantumAnimation('message_sent', data); break; case 'chat_open': this.showChatInterface(); break; case 'chat_close': this.hideChatInterface(); break; case 'animation': this.triggerQuantumAnimation(data.type || 'pulse', data); break; default: console.log('ğŸ”„ é€šç”¨èŠå¤©äº‹ä»¶:', eventType, data); this.triggerQuantumAnimation(eventType, data); } if (this.wsConnection && this.wsConnection.readyState === WebSocket.OPEN) { this.wsConnection.send(JSON.stringify({ type: 'chat_event', eventType: eventType, data: data, timestamp: Date.now() })); } return true; } } if (typeof module !== 'undefined' && module.exports) { module.exports = QuantumChatIntegrator; } console.log('ğŸ“¦ é‡å­çƒ-èŠå¤©é›†æˆæ¨¡å—å·²åŠ è½½');