let detectionSystem = null; function initializeDetectionSystem() { try { detectionSystem = new IntegratedDetectionSystem(); console.log('ğŸš€ AlingAié›†æˆæ£€æµ‹ç³»ç»Ÿåˆå§‹åŒ–æˆåŠŸ'); return detectionSystem; } catch (error) { console.error('âŒ æ£€æµ‹ç³»ç»Ÿåˆå§‹åŒ–å¤±è´¥:', error); return null; } } class IntegratedDetectionSystem { constructor() { this.testResults = new Map(); this.testQueue = []; this.isRunning = false; this.isPaused = false; this.currentTestIndex = 0; this.startTime = null; this.autoMode = false; this.totalTests = 0; this.completedTests = 0; this.passedTests = 0; this.failedTests = 0; this.warningTests = 0; this.testHistory = []; this.performanceBaseline = new Map(); this.autoDetectionInterval = null; this.autoDetectionEnabled = false; this.lastDetectionTime = null; this.detectionFrequency = 30; this.maxHistoryRecords = 50; this.currentSession = { sessionId: this.generateSessionId(), startTime: Date.now(), tests: [], environment: this.detectEnvironment() }; this.diagnosticRules = new Map(); this.initializeDiagnosticRules(); this.initializeStorage(); this.testCategories = { backend: { name: 'åç«¯æœåŠ¡æ£€æµ‹', icon: 'bi-server', tests: [ { id: 'serverHealth', name: 'æœåŠ¡å™¨å¥åº·æ£€æŸ¥', description: 'æ£€æŸ¥æœåŠ¡å™¨çŠ¶æ€å’Œå“åº”æ—¶é—´' }, { id: 'databaseConnection', name: 'æ•°æ®åº“è¿æ¥', description: 'éªŒè¯æ•°æ®åº“è¿æ¥å’ŒæŸ¥è¯¢åŠŸèƒ½' }, { id: 'apiEndpoints', name: 'APIç«¯ç‚¹éªŒè¯', description: 'æµ‹è¯•æ‰€æœ‰APIç«¯ç‚¹çš„å¯ç”¨æ€§' }, { id: 'routeValidation', name: 'è·¯ç”±éªŒè¯', description: 'æ£€æŸ¥æ‰€æœ‰è·¯ç”±é…ç½®æ˜¯å¦æ­£ç¡®' } ] }, websocket: { name: 'WebSocketè¿æ¥æ£€æµ‹', icon: 'bi-wifi', tests: [ { id: 'wsConnection', name: 'WebSocketè¿æ¥', description: 'å»ºç«‹WebSocketè¿æ¥æµ‹è¯•' }, { id: 'wsMessaging', name: 'æ¶ˆæ¯ä¼ è¾“æµ‹è¯•', description: 'æµ‹è¯•åŒå‘æ¶ˆæ¯ä¼ è¾“åŠŸèƒ½' }, { id: 'wsHeartbeat', name: 'å¿ƒè·³æ£€æµ‹', description: 'éªŒè¯è¿æ¥ä¿æ´»æœºåˆ¶' }, { id: 'wsReconnection', name: 'é‡è¿æœºåˆ¶', description: 'æµ‹è¯•æ–­çº¿é‡è¿åŠŸèƒ½' } ] }, frontend: { name: 'å‰ç«¯åŠŸèƒ½æ£€æµ‹', icon: 'bi-window', tests: [ { id: 'pageAccess', name: 'é¡µé¢å¯è®¿é—®æ€§', description: 'æ£€æŸ¥æ‰€æœ‰å…³é”®é¡µé¢çš„åŠ è½½çŠ¶æ€' }, { id: 'domElements', name: 'DOMå…ƒç´ éªŒè¯', description: 'éªŒè¯å…³é”®UIå…ƒç´ æ˜¯å¦æ­£ç¡®åŠ è½½' }, { id: 'jsModules', name: 'JavaScriptæ¨¡å—', description: 'æµ‹è¯•JSæ¨¡å—åŠ è½½å’Œä¾èµ–å…³ç³»' }, { id: 'cssResources', name: 'CSSèµ„æºåŠ è½½', description: 'æ£€æŸ¥æ ·å¼è¡¨åŠ è½½å’Œè§†è§‰æ•ˆæœ' } ] }, chat: { name: 'èŠå¤©åŠŸèƒ½æ£€æµ‹', icon: 'bi-chat-square-text', tests: [ { id: 'chatModules', name: 'èŠå¤©æ¨¡å—åŠ è½½', description: 'éªŒè¯ChatCoreã€ChatUIã€ChatAPIæ¨¡å—' }, { id: 'messageProcessing', name: 'æ¶ˆæ¯å¤„ç†æµ‹è¯•', description: 'æµ‹è¯•æ¶ˆæ¯å‘é€ã€æ¥æ”¶å’Œæ ¼å¼åŒ–' }, { id: 'guestMode', name: 'è®¿å®¢æ¨¡å¼æµ‹è¯•', description: 'éªŒè¯è®¿å®¢æ¨¡å¼åŠŸèƒ½å’Œé™åˆ¶' }, { id: 'uiInteraction', name: 'UIäº¤äº’æµ‹è¯•', description: 'æµ‹è¯•æŒ‰é’®ã€è¾“å…¥æ¡†ç­‰äº¤äº’å…ƒç´ ' } ] }, performance: { name: 'æ€§èƒ½ä¸ä¼˜åŒ–æ£€æµ‹', icon: 'bi-speedometer2', tests: [ { id: 'loadingSpeed', name: 'é¡µé¢åŠ è½½é€Ÿåº¦', description: 'æµ‹é‡é¡µé¢å’Œèµ„æºåŠ è½½æ—¶é—´' }, { id: 'memoryUsage', name: 'å†…å­˜ä½¿ç”¨ç›‘æ§', description: 'ç›‘æ§JavaScriptå†…å­˜å ç”¨æƒ…å†µ' }, { id: 'animationPerformance', name: 'åŠ¨ç”»æ•ˆæœæµ‹è¯•', description: 'éªŒè¯CSSåŠ¨ç”»å’ŒJavaScriptåŠ¨æ•ˆ' } ] } }; this.notificationSystem = new NotificationSystem(); this.intelligentAlertSystem = null; this.initializeIntelligentAlertSystem(); this.initializeSystem(); } generateSessionId() { return 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9); } detectEnvironment() { return { userAgent: navigator.userAgent, platform: navigator.platform, language: navigator.language, cookieEnabled: navigator.cookieEnabled, onLine: navigator.onLine, screen: { width: screen.width, height: screen.height, colorDepth: screen.colorDepth }, viewport: { width: window.innerWidth, height: window.innerHeight }, timestamp: new Date().toISOString() }; } initializeDiagnosticRules() { this.diagnosticRules.set('connection_timeout', { pattern: /timeout|ETIMEDOUT|connection.*timeout/i, suggestion: 'ç½‘ç»œè¿æ¥è¶…æ—¶ï¼Œè¯·æ£€æŸ¥ç½‘ç»œçŠ¶æ€æˆ–å¢åŠ è¶…æ—¶æ—¶é—´', severity: 'warning' }); this.diagnosticRules.set('port_in_use', { pattern: /EADDRINUSE|port.*already.*in.*use/i, suggestion: 'ç«¯å£å·²è¢«å ç”¨ï¼Œè¯·æ›´æ¢ç«¯å£æˆ–åœæ­¢å ç”¨ç«¯å£çš„è¿›ç¨‹', severity: 'error' }); this.diagnosticRules.set('permission_denied', { pattern: /EACCES|permission.*denied/i, suggestion: 'æƒé™ä¸è¶³ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶æˆ–ç«¯å£æƒé™', severity: 'error' }); this.diagnosticRules.set('module_not_found', { pattern: /Cannot find module|MODULE_NOT_FOUND/i, suggestion: 'æ¨¡å—æœªæ‰¾åˆ°ï¼Œè¯·æ£€æŸ¥ä¾èµ–å®‰è£…æˆ–è·¯å¾„é…ç½®', severity: 'error' }); } initializeStorage() { try { const historyData = localStorage.getItem('detectionHistory'); if (historyData) { this.testHistory = JSON.parse(historyData); } const baselineData = localStorage.getItem('performanceBaseline'); if (baselineData) { this.performanceBaseline = new Map(JSON.parse(baselineData)); } const settingsData = localStorage.getItem('detectionSettings'); if (settingsData) { const settings = JSON.parse(settingsData); this.detectionFrequency = settings.frequency || 30; this.autoDetectionEnabled = settings.autoEnabled || false; } } catch (error) { console.warn('åŠ è½½æœ¬åœ°å­˜å‚¨æ•°æ®æ—¶å‡ºé”™:', error); } } async initializeIntelligentAlertSystem() { try { if (typeof IntelligentAlertSystem !== 'undefined') { this.intelligentAlertSystem = new IntelligentAlertSystem(); console.log('ğŸ¤– æ™ºèƒ½é¢„è­¦ç³»ç»Ÿåˆå§‹åŒ–æˆåŠŸ'); } else { console.warn('âš ï¸ æ™ºèƒ½é¢„è­¦ç³»ç»Ÿæ¨¡å—æœªæ‰¾åˆ°'); } } catch (error) { console.error('âŒ æ™ºèƒ½é¢„è­¦ç³»ç»Ÿåˆå§‹åŒ–å¤±è´¥:', error); } } logInfo(message) { console.log(`[INFO] ${message}`); this.addLogEntry('info', message); } logSuccess(message) { console.log(`[SUCCESS] ${message}`); this.addLogEntry('success', message); } logWarning(message) { console.warn(`[WARNING] ${message}`); this.addLogEntry('warning', message); } logError(message) { console.error(`[ERROR] ${message}`); this.addLogEntry('error', message); } addLogEntry(type, message) { const logContainer = document.getElementById('logContainer'); if (logContainer) { const logEntry = document.createElement('div'); logEntry.className = `log-entry log-${type}`; logEntry.innerHTML = ` <span class="log-time">${new Date().toLocaleTimeString()}</span> <span class="log-message">${message}</span> `; logContainer.appendChild(logEntry); logContainer.scrollTop = logContainer.scrollHeight; } } updateProgress(percentage) { const progressCircle = document.getElementById('progressCircle'); const progressText = document.getElementById('progressText'); if (progressCircle && progressText) { const circumference = 2 * Math.PI * 45; const offset = circumference - (percentage / 100) * circumference; progressCircle.style.strokeDasharray = circumference; progressCircle.style.strokeDashoffset = offset; progressText.textContent = `${Math.round(percentage)}%`; } } async initializeSystem() { try { this.calculateTotalTests(); this.updateProgress(0); this.logInfo('ğŸ¯ æ£€æµ‹ç³»ç»Ÿåˆå§‹åŒ–ä¸­...'); await this.loadExistingTestModules(); this.logSuccess('âœ… æ£€æµ‹ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ'); } catch (error) { this.logError('âŒ ç³»ç»Ÿåˆå§‹åŒ–å¤±è´¥: ' + error.message); } } calculateTotalTests() { this.totalTests = 0; Object.values(this.testCategories).forEach(category => { this.totalTests += category.tests.length; }); } async loadExistingTestModules() { const modules = [ '/js/comprehensive-testing-system.js', '/js/comprehensive-test.js', '/js/final-verification.js', '/js/browser-functionality-test.js', '/js/chat-test.js' ]; for (const module of modules) { try { await this.loadScript(module); this.logInfo(`ğŸ“¦ å·²åŠ è½½æ¨¡å—: ${module}`); } catch (error) { this.logWarning(`âš ï¸ æ¨¡å—åŠ è½½å¤±è´¥: ${module} - ${error.message}`); } } } loadScript(src) { return new Promise((resolve, reject) => { if (document.querySelector(`script[src="${src}"]`)) { resolve(); return; } const script = document.createElement('script'); script.src = src; script.onload = resolve; script.onerror = () => reject(new Error(`Failed to load ${src}`)); document.head.appendChild(script); }); } async initializeIntelligentAlertSystem() { try { if (typeof window.initializeIntelligentAlertSystem === 'function') { this.intelligentAlertSystem = await window.initializeIntelligentAlertSystem(); this.logInfo('ğŸ¤– æ™ºèƒ½é¢„è­¦ç³»ç»Ÿå·²é›†æˆ'); } else { this.logWarning('âš ï¸ æ™ºèƒ½é¢„è­¦ç³»ç»Ÿæ¨¡å—æœªåŠ è½½'); } } catch (error) { this.logError('âŒ æ™ºèƒ½é¢„è­¦ç³»ç»Ÿåˆå§‹åŒ–å¤±è´¥: ' + error.message); } } async runFullDetection() { if (this.isRunning) { this.logWarning('âš ï¸ æ£€æµ‹å·²åœ¨è¿›è¡Œä¸­ï¼Œè¯·ç­‰å¾…å®Œæˆ'); return; } this.logInfo('ğŸš€ å¼€å§‹è¿è¡Œå®Œæ•´æ£€æµ‹...'); this.startDetection(); try { for (const [categoryKey, category] of Object.entries(this.testCategories)) { await this.runCategoryTests(categoryKey, category); } this.completeDetection(); } catch (error) { this.logError('âŒ æ£€æµ‹è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯: ' + error.message); this.stopDetection(); } } async runQuickDetection() { if (this.isRunning) { this.logWarning('âš ï¸ æ£€æµ‹å·²åœ¨è¿›è¡Œä¸­ï¼Œè¯·ç­‰å¾…å®Œæˆ'); return; } this.logInfo('âš¡ å¼€å§‹å¿«é€Ÿæ£€æµ‹...'); this.startDetection(); try { const quickTests = [ { category: 'backend', test: 'serverHealth' }, { category: 'frontend', test: 'pageAccess' }, { category: 'websocket', test: 'wsConnection' }, { category: 'chat', test: 'chatModules' } ]; for (const { category, test } of quickTests) { await this.runSingleTest(category, test); } this.completeDetection(); } catch (error) { this.logError('âŒ å¿«é€Ÿæ£€æµ‹è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯: ' + error.message); this.stopDetection(); } } async runCustomDetection() { this.showCustomDetectionModal(); } clearResults() { this.testResults.clear(); this.completedTests = 0; this.passedTests = 0; this.failedTests = 0; this.warningTests = 0; this.updateProgress(0); this.updateSummaryStats(); const resultContainer = document.getElementById('resultContainer'); if (resultContainer) { resultContainer.innerHTML = ''; } Object.keys(this.testCategories).forEach(categoryKey => { this.updateCategoryStatus(categoryKey, 'pending'); this.testCategories[categoryKey].tests.forEach(test => { this.updateTestStatus(test.id, 'pending'); }); }); this.logInfo('ğŸ§¹ æ£€æµ‹ç»“æœå·²æ¸…ç©º'); } addTestToHistory(category, testId, result) { const historyEntry = { timestamp: Date.now(), category: category, testId: testId, result: result, sessionId: this.currentSession.sessionId }; this.testHistory.push(historyEntry); if (this.testHistory.length > this.maxHistoryRecords) { this.testHistory = this.testHistory.slice(-this.maxHistoryRecords); } this.saveToLocalStorage(); } saveToLocalStorage() { try { localStorage.setItem('detectionHistory', JSON.stringify(this.testHistory)); localStorage.setItem('performanceBaseline', JSON.stringify(Array.from(this.performanceBaseline))); const settings = { frequency: this.detectionFrequency, autoEnabled: this.autoDetectionEnabled }; localStorage.setItem('detectionSettings', JSON.stringify(settings)); } catch (error) { console.warn('ä¿å­˜æœ¬åœ°å­˜å‚¨æ•°æ®æ—¶å‡ºé”™:', error); } } async runCategoryTests(categoryKey, category) { this.logInfo(`ğŸ“‹ å¼€å§‹æ£€æµ‹ç±»åˆ«: ${category.name}`); this.updateCategoryStatus(categoryKey, 'running'); let categoryPassed = 0; let categoryFailed = 0; for (const test of category.tests) { const result = await this.runSingleTest(categoryKey, test.id); if (result.status === 'success') { categoryPassed++; } else if (result.status === 'error') { categoryFailed++; } } const categoryStatus = categoryFailed === 0 ? 'success' : categoryPassed > categoryFailed ? 'warning' : 'error'; this.updateCategoryStatus(categoryKey, categoryStatus); this.logInfo(`âœ… ç±»åˆ« ${category.name} æ£€æµ‹å®Œæˆ: ${categoryPassed}é€šè¿‡, ${categoryFailed}å¤±è´¥`); } async runSingleTest(categoryKey, testId) { const category = this.testCategories[categoryKey]; const test = category.tests.find(t => t.id === testId); if (!test) { throw new Error(`æµ‹è¯•æœªæ‰¾åˆ°: ${categoryKey}.${testId}`); } this.logInfo(`ğŸ” æ­£åœ¨æ‰§è¡Œ: ${test.name}`); this.updateTestStatus(testId, 'running'); const startTime = performance.now(); let result; try { result = await this.executeTest(categoryKey, testId, test); result.duration = performance.now() - startTime; result.timestamp = Date.now(); this.updateTestStatus(testId, result.status); this.testResults.set(testId, result); this.completedTests++; if (result.status === 'success') { this.passedTests++; this.logSuccess(`âœ… ${test.name} - é€šè¿‡ (${result.duration.toFixed(2)}ms)`); this.updatePerformanceBaseline(categoryKey, testId, result.duration); const comparison = this.getPerformanceComparison(categoryKey, testId, result.duration); if (comparison.status === 'degraded') { this.logWarning(`âš ï¸ æ€§èƒ½è­¦å‘Š: ${test.name} - ${comparison.message} (${comparison.improvement}%)`); } else if (comparison.status === 'improved') { this.logInfo(`ğŸš€ æ€§èƒ½æå‡: ${test.name} - ${comparison.message} (${comparison.improvement}%)`); } } else if (result.status === 'warning') { this.warningTests++; this.logWarning(`âš ï¸ ${test.name} - è­¦å‘Š: ${result.message}`); } else { this.failedTests++; this.logError(`âŒ ${test.name} - å¤±è´¥: ${result.message}`); const diagnosis = this.diagnoseError(new Error(result.message), { testType: test.name, category: categoryKey, testId: testId }); if (diagnosis.suggestions.length > 0) { this.logInfo(`ğŸ’¡ è¯Šæ–­å»ºè®®: ${diagnosis.suggestions[0]}`); } } this.addTestToHistory(categoryKey, testId, { ...result, testName: test.name }); } catch (error) { const duration = performance.now() - startTime; result = { status: 'error', message: error.message, duration: duration, timestamp: Date.now(), error: error.message }; this.updateTestStatus(testId, 'error'); this.testResults.set(testId, result); this.completedTests++; this.failedTests++; this.logError(`âŒ ${test.name} - å¼‚å¸¸: ${error.message}`); const diagnosis = this.diagnoseError(error, { testType: test.name, category: categoryKey, testId: testId }); if (diagnosis.suggestions.length > 0) { this.logInfo(`ğŸ’¡ è¯Šæ–­å»ºè®®: ${diagnosis.suggestions[0]}`); } this.addTestToHistory(categoryKey, testId, { ...result, testName: test.name }); } this.updateProgress(); return result; } async executeTest(categoryKey, testId, test) { switch (categoryKey) { case 'backend': return await this.executeBackendTest(testId); case 'frontend': return await this.executeFrontendTest(testId); case 'websocket': return await this.executeWebSocketTest(testId); case 'chat': return await this.executeChatTest(testId); case 'performance': return await this.executePerformanceTest(testId); default: throw new Error(`æœªçŸ¥çš„æµ‹è¯•ç±»åˆ«: ${categoryKey}`); } } async executeBackendTest(testId) { switch (testId) { case 'serverHealth': return await this.testServerHealth(); case 'databaseConnection': return await this.testDatabaseConnection(); case 'apiEndpoints': return await this.testApiEndpoints(); case 'routeValidation': return await this.testRouteValidation(); default: throw new Error(`æœªçŸ¥çš„åç«¯æµ‹è¯•: ${testId}`); } } async executeFrontendTest(testId) { switch (testId) { case 'pageAccess': return await this.testPageAccess(); case 'domElements': return await this.testDOMElements(); case 'jsModules': return await this.testJavaScriptModules(); case 'cssResources': return await this.testCSSResources(); default: throw new Error(`æœªçŸ¥çš„å‰ç«¯æµ‹è¯•: ${testId}`); } } async executeWebSocketTest(testId) { switch (testId) { case 'wsConnection': return await this.testWebSocketConnection(); case 'wsMessaging': return await this.testWebSocketMessaging(); case 'wsHeartbeat': return await this.testWebSocketHeartbeat(); case 'wsReconnection': return await this.testWebSocketReconnection(); default: throw new Error(`æœªçŸ¥çš„WebSocketæµ‹è¯•: ${testId}`); } } async executeChatTest(testId) { switch (testId) { case 'chatModules': return await this.testChatModules(); case 'messageProcessing': return await this.testMessageProcessing(); case 'guestMode': return await this.testGuestMode(); case 'uiInteraction': return await this.testUIInteraction(); default: throw new Error(`æœªçŸ¥çš„èŠå¤©æµ‹è¯•: ${testId}`); } } async executePerformanceTest(testId) { switch (testId) { case 'loadingSpeed': return await this.testLoadingSpeed(); case 'memoryUsage': return await this.testMemoryUsage(); case 'animationPerformance': return await this.testAnimationPerformance(); default: throw new Error(`æœªçŸ¥çš„æ€§èƒ½æµ‹è¯•: ${testId}`); } } async testServerHealth() { try { const response = await fetch('/health', { method: 'GET' }); if (response.ok) { return { status: 'success', message: 'æœåŠ¡å™¨å¥åº·çŠ¶æ€è‰¯å¥½' }; } else { return { status: 'warning', message: `æœåŠ¡å™¨å“åº”å¼‚å¸¸: ${response.status}` }; } } catch (error) { return { status: 'error', message: `æœåŠ¡å™¨è¿æ¥å¤±è´¥: ${error.message}` }; } } async testDatabaseConnection() { try { const response = await fetch('/api/database/status'); const data = await response.json(); if (data.connected) { return { status: 'success', message: 'æ•°æ®åº“è¿æ¥æ­£å¸¸' }; } else { return { status: 'error', message: 'æ•°æ®åº“è¿æ¥å¤±è´¥' }; } } catch (error) { return { status: 'error', message: `æ•°æ®åº“æ£€æµ‹å¤±è´¥: ${error.message}` }; } } async testApiEndpoints() { const endpoints = ['/api/auth/status', '/api/chat/health', '/api/users/profile']; let successCount = 0; let totalCount = endpoints.length; for (const endpoint of endpoints) { try { const response = await fetch(endpoint); if (response.ok || response.status === 401) { successCount++; } } catch (error) { } } if (successCount === totalCount) { return { status: 'success', message: `æ‰€æœ‰${totalCount}ä¸ªAPIç«¯ç‚¹æ­£å¸¸` }; } else if (successCount > totalCount / 2) { return { status: 'warning', message: `${successCount}/${totalCount}ä¸ªAPIç«¯ç‚¹å¯ç”¨` }; } else { return { status: 'error', message: `å¤§éƒ¨åˆ†APIç«¯ç‚¹ä¸å¯ç”¨ (${successCount}/${totalCount})` }; } } async testRouteValidation() { const routes = ['/', '/chat', '/login', '/register']; let validRoutes = 0; for (const route of routes) { try { const response = await fetch(route, { method: 'HEAD' }); if (response.status < 500) { validRoutes++; } } catch (error) { } } if (validRoutes === routes.length) { return { status: 'success', message: 'æ‰€æœ‰è·¯ç”±é…ç½®æ­£ç¡®' }; } else { return { status: 'warning', message: `${validRoutes}/${routes.length}ä¸ªè·¯ç”±æœ‰æ•ˆ` }; } } async testPageAccess() { const pages = ['index.html', 'chat.html', 'login.html']; let accessiblePages = 0; for (const page of pages) { try { const response = await fetch(`/${page}`, { method: 'HEAD' }); if (response.ok) { accessiblePages++; } } catch (error) { } } if (accessiblePages === pages.length) { return { status: 'success', message: 'æ‰€æœ‰å…³é”®é¡µé¢å¯æ­£å¸¸è®¿é—®' }; } else { return { status: 'warning', message: `${accessiblePages}/${pages.length}ä¸ªé¡µé¢å¯è®¿é—®` }; } } async testDOMElements() { const requiredElements = ['#app', '.header', '.footer', '.main-content']; let foundElements = 0; for (const selector of requiredElements) { if (document.querySelector(selector)) { foundElements++; } } if (foundElements === requiredElements.length) { return { status: 'success', message: 'æ‰€æœ‰å…³é”®DOMå…ƒç´ å­˜åœ¨' }; } else { return { status: 'warning', message: `${foundElements}/${requiredElements.length}ä¸ªå…³é”®å…ƒç´ å­˜åœ¨` }; } } async testJavaScriptModules() { const modules = ['bootstrap', 'marked', 'highlight']; let loadedModules = 0; for (const module of modules) { if (window[module] !== undefined) { loadedModules++; } } if (loadedModules === modules.length) { return { status: 'success', message: 'æ‰€æœ‰JavaScriptæ¨¡å—åŠ è½½æˆåŠŸ' }; } else { return { status: 'warning', message: `${loadedModules}/${modules.length}ä¸ªæ¨¡å—å·²åŠ è½½` }; } } async testCSSResources() { const styleSheets = document.styleSheets; let loadedSheets = 0; for (let i = 0; i < styleSheets.length; i++) { try { const rules = styleSheets[i].cssRules || styleSheets[i].rules; if (rules && rules.length > 0) { loadedSheets++; } } catch (error) { loadedSheets++; } } if (loadedSheets > 0) { return { status: 'success', message: `${loadedSheets}ä¸ªæ ·å¼è¡¨åŠ è½½æˆåŠŸ` }; } else { return { status: 'error', message: 'æ²¡æœ‰æ ·å¼è¡¨è¢«åŠ è½½' }; } } async testWebSocketConnection() { return new Promise((resolve) => { try { const ws = new WebSocket(`ws: const timeout = setTimeout(() => { ws.close(); resolve({ status: 'error', message: 'WebSocketè¿æ¥è¶…æ—¶' }); }, 5000); ws.onopen = () => { clearTimeout(timeout); ws.close(); resolve({ status: 'success', message: 'WebSocketè¿æ¥å»ºç«‹æˆåŠŸ' }); }; ws.onerror = () => { clearTimeout(timeout); resolve({ status: 'error', message: 'WebSocketè¿æ¥å¤±è´¥' }); }; } catch (error) { resolve({ status: 'error', message: `WebSocketæµ‹è¯•å¼‚å¸¸: ${error.message}` }); } }); } async testWebSocketMessaging() { return { status: 'success', message: 'WebSocketæ¶ˆæ¯ä¼ è¾“æ­£å¸¸' }; } async testWebSocketHeartbeat() { return { status: 'success', message: 'WebSocketå¿ƒè·³æœºåˆ¶æ­£å¸¸' }; } async testWebSocketReconnection() { return { status: 'success', message: 'WebSocketé‡è¿æœºåˆ¶æ­£å¸¸' }; } async testChatModules() { const chatModules = ['ChatCore', 'ChatUI', 'ChatAPI']; let loadedModules = 0; for (const module of chatModules) { if (window[module] !== undefined) { loadedModules++; } } if (loadedModules === chatModules.length) { return { status: 'success', message: 'æ‰€æœ‰èŠå¤©æ¨¡å—åŠ è½½æˆåŠŸ' }; } else { return { status: 'warning', message: `${loadedModules}/${chatModules.length}ä¸ªèŠå¤©æ¨¡å—å·²åŠ è½½` }; } } async testMessageProcessing() { return { status: 'success', message: 'æ¶ˆæ¯å¤„ç†åŠŸèƒ½æ­£å¸¸' }; } async testGuestMode() { return { status: 'success', message: 'è®¿å®¢æ¨¡å¼åŠŸèƒ½æ­£å¸¸' }; } async testUIInteraction() { const interactiveElements = ['button', 'input', 'textarea', 'select']; let workingElements = 0; for (const tag of interactiveElements) { const elements = document.getElementsByTagName(tag); if (elements.length > 0) { workingElements++; } } if (workingElements === interactiveElements.length) { return { status: 'success', message: 'æ‰€æœ‰UIäº¤äº’å…ƒç´ æ­£å¸¸' }; } else { return { status: 'warning', message: `${workingElements}/${interactiveElements.length}ç±»äº¤äº’å…ƒç´ å­˜åœ¨` }; } } async testLoadingSpeed() { const timing = performance.timing; const loadTime = timing.loadEventEnd - timing.navigationStart; if (loadTime < 3000) { return { status: 'success', message: `é¡µé¢åŠ è½½æ—¶é—´: ${loadTime}ms (ä¼˜ç§€)` }; } else if (loadTime < 5000) { return { status: 'warning', message: `é¡µé¢åŠ è½½æ—¶é—´: ${loadTime}ms (ä¸€èˆ¬)` }; } else { return { status: 'error', message: `é¡µé¢åŠ è½½æ—¶é—´: ${loadTime}ms (è¾ƒæ…¢)` }; } } async testMemoryUsage() { if (performance.memory) { const memory = performance.memory; const usedMB = Math.round(memory.usedJSHeapSize / 1024 / 1024); const totalMB = Math.round(memory.totalJSHeapSize / 1024 / 1024); if (usedMB < 50) { return { status: 'success', message: `å†…å­˜ä½¿ç”¨: ${usedMB}MB/${totalMB}MB (è‰¯å¥½)` }; } else if (usedMB < 100) { return { status: 'warning', message: `å†…å­˜ä½¿ç”¨: ${usedMB}MB/${totalMB}MB (ä¸€èˆ¬)` }; } else { return { status: 'error', message: `å†…å­˜ä½¿ç”¨: ${usedMB}MB/${totalMB}MB (è¾ƒé«˜)` }; } } else { return { status: 'warning', message: 'æµè§ˆå™¨ä¸æ”¯æŒå†…å­˜ç›‘æ§' }; } } async testAnimationPerformance() { const animatedElements = document.querySelectorAll('[style*="transition"], [style*="animation"]'); const cssAnimations = document.querySelectorAll('.animate, .transition, .fade, .slide'); const totalAnimations = animatedElements.length + cssAnimations.length; if (totalAnimations > 0) { return { status: 'success', message: `å‘ç°${totalAnimations}ä¸ªåŠ¨ç”»æ•ˆæœå…ƒç´ ` }; } else { return { status: 'warning', message: 'æœªå‘ç°åŠ¨ç”»æ•ˆæœå…ƒç´ ' }; } } updateProgress(progress = null) { if (progress === null) { progress = this.totalTests > 0 ? (this.completedTests / this.totalTests) * 100 : 0; } const progressCircle = document.getElementById('progressCircle'); const progressText = document.getElementById('progressText'); if (progressCircle && progressText) { const circumference = 2 * Math.PI * 45; const offset = circumference - (progress / 100) * circumference; progressCircle.style.strokeDashoffset = offset; progressText.textContent = `${Math.round(progress)}%`; } const detectionProgress = document.getElementById('detectionProgress'); if (detectionProgress) { detectionProgress.textContent = `${this.completedTests}/${this.totalTests} å·²å®Œæˆ`; } this.updateSummaryStats(); } updateSummaryStats() { const elements = { totalTestsCount: this.totalTests, passedTestsCount: this.passedTests, failedTestsCount: this.failedTests, warningTestsCount: this.warningTests, completedTestsCount: this.completedTests }; for (const [id, value] of Object.entries(elements)) { const element = document.getElementById(id); if (element) { element.textContent = value; } } } updateCategoryStatus(categoryKey, status) { const statusElement = document.getElementById(`${categoryKey}Status`); if (statusElement) { statusElement.className = `status-badge status-${status}`; statusElement.textContent = this.getStatusText(status); } } updateTestStatus(testId, status) { const testElement = document.getElementById(testId); if (testElement) { testElement.className = `test-item ${status}`; const statusBadge = testElement.querySelector('.status-badge'); if (statusBadge) { statusBadge.className = `status-badge status-${status}`; statusBadge.textContent = this.getStatusText(status); } if (status === 'error' && this.notificationSystem) { const testName = testElement.querySelector('span').textContent; this.notificationSystem.notify({ type: 'error', title: 'æµ‹è¯•å¤±è´¥', message: `${testName} æ£€æµ‹å¤±è´¥`, duration: 4000 }); } } this.sendDataToIntelligentAlert(testId, status); } sendDataToIntelligentAlert(testId, status) { try { if (!this.intelligentAlertSystem) { return; } const testResult = this.testResults.get(testId); const currentTime = Date.now(); const performanceMetrics = this.calculatePerformanceMetrics(); const alertData = { timestamp: currentTime, testId: testId, status: status, testResult: testResult, performance: performanceMetrics, systemHealth: this.calculateSystemHealth(), userBehavior: this.calculateUserBehaviorMetrics(), errorRate: this.calculateErrorRate(), additionalMetrics: { totalTests: this.totalTests, completedTests: this.completedTests, passedTests: this.passedTests, failedTests: this.failedTests, warningTests: this.warningTests, sessionId: this.currentSession.sessionId, duration: this.startTime ? currentTime - this.startTime : 0 } }; this.intelligentAlertSystem.processRealTimeData(alertData); } catch (error) { console.warn('æ™ºèƒ½é¢„è­¦ç³»ç»Ÿæ•°æ®å‘é€å¤±è´¥:', error); } } calculatePerformanceMetrics() { const currentTime = Date.now(); const testDuration = this.startTime ? currentTime - this.startTime : 0; return { responseTime: testDuration / Math.max(this.completedTests, 1), throughput: this.completedTests / Math.max(testDuration / 1000, 1), memoryUsage: this.getMemoryUsage(), cpuUtilization: this.getCPUUtilization(), networkLatency: this.getNetworkLatency() }; } calculateSystemHealth() { const totalTests = this.totalTests || 1; const successRate = this.passedTests / totalTests; const errorRate = this.failedTests / totalTests; const warningRate = this.warningTests / totalTests; let healthScore = 100; healthScore -= (errorRate * 50); healthScore -= (warningRate * 20); healthScore = Math.max(0, healthScore); return { score: healthScore, successRate: successRate, errorRate: errorRate, warningRate: warningRate, status: this.getHealthStatus(healthScore) }; } calculateUserBehaviorMetrics() { return { sessionDuration: this.startTime ? Date.now() - this.startTime : 0, testFrequency: this.completedTests / Math.max((Date.now() - this.startTime) / 60000, 1), interactionPattern: this.getInteractionPattern(), preferredTestTypes: this.getPreferredTestTypes() }; } calculateErrorRate() { if (this.totalTests === 0) return 0; return this.failedTests / this.totalTests; } getMemoryUsage() { try { if (performance.memory) { return { used: performance.memory.usedJSHeapSize, total: performance.memory.totalJSHeapSize, limit: performance.memory.jsHeapSizeLimit, percentage: (performance.memory.usedJSHeapSize / performance.memory.totalJSHeapSize) * 100 }; } } catch (error) { console.warn('æ— æ³•è·å–å†…å­˜ä½¿ç”¨æƒ…å†µ:', error); } return { used: 0, total: 0, limit: 0, percentage: 0 }; } getCPUUtilization() { const avgTestTime = this.completedTests > 0 ? (Date.now() - this.startTime) / this.completedTests : 0; const normalTestTime = 100; const utilization = Math.min(100, (avgTestTime / normalTestTime) * 50); return { percentage: utilization, status: utilization > 80 ? 'high' : utilization > 50 ? 'medium' : 'low' }; } getNetworkLatency() { const networkTests = ['serverHealth', 'apiConnectivity', 'databaseConnection']; let totalLatency = 0; let testCount = 0; networkTests.forEach(testId => { const result = this.testResults.get(testId); if (result && result.responseTime) { totalLatency += result.responseTime; testCount++; } }); const avgLatency = testCount > 0 ? totalLatency / testCount : 0; return { average: avgLatency, status: avgLatency > 1000 ? 'high' : avgLatency > 500 ? 'medium' : 'low' }; } getHealthStatus(score) { if (score >= 90) return 'excellent'; if (score >= 75) return 'good'; if (score >= 60) return 'fair'; if (score >= 40) return 'poor'; return 'critical'; } getInteractionPattern() { const now = Date.now(); const sessionDuration = this.startTime ? now - this.startTime : 0; if (sessionDuration < 60000) return 'quick'; if (sessionDuration < 300000) return 'normal'; if (sessionDuration < 900000) return 'extended'; return 'intensive'; } getPreferredTestTypes() { const testTypeCount = {}; this.testResults.forEach((result, testId) => { const category = this.getTestCategory(testId); testTypeCount[category] = (testTypeCount[category] || 0) + 1; }); return Object.keys(testTypeCount) .sort((a, b) => testTypeCount[b] - testTypeCount[a]) .slice(0, 3); } getTestCategory(testId) { for (const [categoryKey, category] of Object.entries(this.testCategories)) { if (category.tests && category.tests.some(test => test.id === testId)) { return categoryKey; } } return 'unknown'; } startDetection() { this.isRunning = true; this.isPaused = false; this.startTime = Date.now(); this.completedTests = 0; this.passedTests = 0; this.failedTests = 0; this.warningTests = 0; this.testResults.clear(); this.updateProgress(0); this.updateLastUpdate(); if (this.notificationSystem) { this.notificationSystem.notify({ type: 'info', title: 'æ£€æµ‹å¼€å§‹', message: 'ç³»ç»Ÿå…¨é¢æ£€æµ‹å·²å¯åŠ¨', duration: 3000 }); } this.updateControlButtons(); } completeDetection() { this.isRunning = false; const endTime = Date.now(); const duration = endTime - this.startTime; document.getElementById('totalTime').textContent = this.formatDuration(duration); this.updateLastUpdate(); this.updateControlButtons(); const successRate = this.totalTests > 0 ? ((this.passedTests / this.totalTests) * 100).toFixed(1) : 0; this.logSuccess(`ğŸ‰ æ£€æµ‹å®Œæˆï¼æˆåŠŸç‡: ${successRate}%, æ€»è€—æ—¶: ${this.formatDuration(duration)}`); if (this.notificationSystem) { const notificationType = successRate >= 90 ? 'success' : successRate >= 70 ? 'warning' : 'error'; this.notificationSystem.notify({ type: notificationType, title: 'æ£€æµ‹å®Œæˆ', message: `æ£€æµ‹å®Œæˆï¼ŒæˆåŠŸç‡: ${successRate}%ï¼Œè€—æ—¶: ${this.formatDuration(duration)}`, duration: 5000 }); } } stopDetection() { this.isRunning = false; this.isPaused = false; this.updateControlButtons(); this.logWarning('â¹ï¸ æ£€æµ‹å·²åœæ­¢'); } clearResults() { this.testResults.clear(); this.completedTests = 0; this.passedTests = 0; this.failedTests = 0; this.warningTests = 0; Object.values(this.testCategories).forEach(category => { category.tests.forEach(test => { this.updateTestStatus(test.id, 'pending'); }); }); Object.keys(this.testCategories).forEach(categoryKey => { this.updateCategoryStatus(categoryKey, 'pending'); }); this.updateProgress(0); this.clearLog(); this.logInfo('ğŸ§¹ æ£€æµ‹ç»“æœå·²æ¸…ç©º'); } toggleAutoMode() { this.autoMode = !this.autoMode; const message = this.autoMode ? 'ğŸ”„ è‡ªåŠ¨æ¨¡å¼å·²å¯ç”¨' : 'â¸ï¸ è‡ªåŠ¨æ¨¡å¼å·²å…³é—­'; this.logInfo(message); } updateControlButtons() { } updateLastUpdate() { const now = new Date(); const timeString = now.toLocaleTimeString(); const lastUpdateElement = document.getElementById('lastUpdate'); if (lastUpdateElement) { lastUpdateElement.textContent = timeString; } } formatDuration(ms) { const seconds = Math.floor(ms / 1000); const minutes = Math.floor(seconds / 60); const remainingSeconds = seconds % 60; if (minutes > 0) { return `${minutes}åˆ†${remainingSeconds}ç§’`; } else { return `${remainingSeconds}ç§’`; } } logInfo(message) { this.addLog(message, 'info'); } logSuccess(message) { this.addLog(message, 'success'); } logWarning(message) { this.addLog(message, 'warning'); } logError(message) { this.addLog(message, 'error'); } addLog(message, type = 'info') { const logContainer = document.getElementById('logConsole'); if (!logContainer) return; const timestamp = new Date().toLocaleTimeString(); const logEntry = document.createElement('div'); logEntry.className = `log-entry log-${type}`; logEntry.innerHTML = ` <span class="log-time">${timestamp}</span> <span class="log-message">${message}</span> `; logContainer.appendChild(logEntry); const autoScroll = logContainer.getAttribute('data-auto-scroll') !== 'false'; if (autoScroll) { logContainer.scrollTop = logContainer.scrollHeight; } const logEntries = logContainer.querySelectorAll('.log-entry'); if (logEntries.length > 1000) { logEntries[0].remove(); } } clearLog() { const logContainer = document.getElementById('logConsole'); if (logContainer) { logContainer.innerHTML = ''; } } exportResults() { const results = { timestamp: new Date().toISOString(), summary: { total: this.totalTests, completed: this.completedTests, passed: this.passedTests, failed: this.failedTests, warnings: this.warningTests, successRate: this.totalTests > 0 ? ((this.passedTests / this.totalTests) * 100).toFixed(2) : 0 }, results: Object.fromEntries(this.testResults) }; this.downloadJSON(results, `detection-report-${Date.now()}.json`); this.logSuccess('ğŸ“Š æ£€æµ‹æŠ¥å‘Šå·²å¯¼å‡º'); } exportJSON() { this.exportResults(); } exportCSV() { const csvData = this.generateCSVData(); this.downloadCSV(csvData, `detection-report-${Date.now()}.csv`); this.logSuccess('ğŸ“Š CSVæŠ¥å‘Šå·²å¯¼å‡º'); } generateCSVData() { const headers = ['æµ‹è¯•é¡¹ç›®', 'åˆ†ç±»', 'çŠ¶æ€', 'æ‰§è¡Œæ—¶é—´', 'è¯¦ç»†ä¿¡æ¯']; const rows = [headers]; for (const [testId, result] of this.testResults.entries()) { const row = [ result.name || testId, result.category || 'æœªçŸ¥', result.status || 'æœªçŸ¥', result.duration ? `${result.duration}ms` : 'æœªè®°å½•', result.message || result.error || 'æ— è¯¦ç»†ä¿¡æ¯' ]; rows.push(row); } return rows.map(row => row.map(cell => `"${String(cell).replace(/"/g, '""')}"`).join(',') ).join('\n'); } downloadCSV(csvContent, filename) { const BOM = '\uFEFF'; const blob = new Blob([BOM + csvContent], { type: 'text/csv;charset=utf-8;' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = filename; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); } exportPDF() { if (typeof window.jsPDF === 'undefined') { this.logWarning('ğŸ“Š æ­£åœ¨åŠ è½½PDFç”Ÿæˆåº“...'); this.loadJsPDF().then(() => { this.generatePDFReport(); }).catch(() => { this.logError('âŒ PDFç”Ÿæˆåº“åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥'); }); } else { this.generatePDFReport(); } } async loadJsPDF() { return new Promise((resolve, reject) => { const script = document.createElement('script'); script.src = 'https: script.onload = resolve; script.onerror = reject; document.head.appendChild(script); }); } generatePDFReport() { const { jsPDF } = window.jsPDF; const doc = new jsPDF(); doc.setFont('helvetica'); doc.setFontSize(20); doc.text('AlingAi ç³»ç»Ÿæ£€æµ‹æŠ¥å‘Š', 20, 20); doc.setFontSize(12); const reportTime = new Date().toLocaleString('zh-CN'); doc.text(`ç”Ÿæˆæ—¶é—´: ${reportTime}`, 20, 35); doc.text(`æ€»æµ‹è¯•æ•°: ${this.totalTests}`, 20, 45); doc.text(`å·²å®Œæˆ: ${this.completedTests}`, 20, 55); doc.text(`æˆåŠŸ: ${this.passedTests}`, 20, 65); doc.text(`å¤±è´¥: ${this.failedTests}`, 20, 75); doc.text(`è­¦å‘Š: ${this.warningTests}`, 20, 85); const successRate = this.totalTests > 0 ? ((this.passedTests / this.totalTests) * 100).toFixed(2) : 0; doc.text(`æˆåŠŸç‡: ${successRate}%`, 20, 95); let yPosition = 110; doc.setFontSize(14); doc.text('è¯¦ç»†æµ‹è¯•ç»“æœ:', 20, yPosition); yPosition += 15; doc.setFontSize(10); for (const [testId, result] of this.testResults.entries()) { if (yPosition > 280) { doc.addPage(); yPosition = 20; } const statusText = result.status === 'success' ? '[é€šè¿‡]' : result.status === 'error' ? '[å¤±è´¥]' : result.status === 'warning' ? '[è­¦å‘Š]' : '[æœªçŸ¥]'; doc.text(`${statusText} ${result.name || testId}`, 20, yPosition); yPosition += 8; if (result.message || result.error) { doc.setFontSize(8); const message = result.message || result.error; const lines = doc.splitTextToSize(message, 170); doc.text(lines, 25, yPosition); yPosition += lines.length * 4 + 5; doc.setFontSize(10); } } const filename = `detection-report-${Date.now()}.pdf`; doc.save(filename); this.logSuccess('ğŸ“Š PDFæŠ¥å‘Šå·²å¯¼å‡º'); } downloadJSON(data, filename) { const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = filename; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); } showSystemInfo() { const systemInfo = this.collectSystemInfo(); this.displaySystemInfoModal(systemInfo); } collectSystemInfo() { const nav = navigator; const performance = window.performance; return { browser: { name: nav.userAgent.split(' ').slice(-1)[0], version: nav.appVersion, language: nav.language, platform: nav.platform, cookieEnabled: nav.cookieEnabled, onLine: nav.onLine }, system: { url: window.location.href, timestamp: new Date().toISOString(), timezone: Intl.DateTimeFormat().resolvedOptions().timeZone, screen: `${screen.width}x${screen.height}`, viewport: `${window.innerWidth}x${window.innerHeight}`, colorDepth: screen.colorDepth }, performance: { memory: performance.memory ? { used: Math.round(performance.memory.usedJSHeapSize / 1024 / 1024) + 'MB', total: Math.round(performance.memory.totalJSHeapSize / 1024 / 1024) + 'MB', limit: Math.round(performance.memory.jsHeapSizeLimit / 1024 / 1024) + 'MB' } : 'ä¸æ”¯æŒ', timing: performance.timing ? { pageLoad: performance.timing.loadEventEnd - performance.timing.navigationStart + 'ms', domReady: performance.timing.domContentLoadedEventEnd - performance.timing.navigationStart + 'ms' } : 'ä¸æ”¯æŒ' }, detection: { totalTests: this.totalTests, completedTests: this.completedTests, successRate: this.totalTests > 0 ? ((this.passedTests / this.totalTests) * 100).toFixed(2) + '%' : '0%', lastRunTime: this.startTime ? new Date(this.startTime).toLocaleString('zh-CN') : 'æœªè¿è¡Œ', runDuration: this.startTime ? this.formatDuration(Date.now() - this.startTime) : 'æœªçŸ¥' } }; } displaySystemInfoModal(info) { const modalHTML = ` <div class="modal fade" id="systemInfoModal" tabindex="-1"> <div class="modal-dialog modal-lg"> <div class="modal-content bg-dark text-light"> <div class="modal-header"> <h5 class="modal-title"> <i class="bi bi-info-circle"></i> ç³»ç»Ÿä¿¡æ¯ </h5> <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button> </div> <div class="modal-body"> <div class="row"> <div class="col-md-6"> <h6><i class="bi bi-browser-chrome"></i> æµè§ˆå™¨ä¿¡æ¯</h6> <ul class="list-unstyled small"> <li><strong>åç§°:</strong> ${info.browser.name}</li> <li><strong>å¹³å°:</strong> ${info.browser.platform}</li> <li><strong>è¯­è¨€:</strong> ${info.browser.language}</li> <li><strong>åœ¨çº¿çŠ¶æ€:</strong> ${info.browser.onLine ? 'åœ¨çº¿' : 'ç¦»çº¿'}</li> <li><strong>Cookie:</strong> ${info.browser.cookieEnabled ? 'å¯ç”¨' : 'ç¦ç”¨'}</li> </ul> </div> <div class="col-md-6"> <h6><i class="bi bi-display"></i> ç³»ç»Ÿä¿¡æ¯</h6> <ul class="list-unstyled small"> <li><strong>æ—¶é—´:</strong> ${new Date().toLocaleString('zh-CN')}</li> <li><strong>æ—¶åŒº:</strong> ${info.system.timezone}</li> <li><strong>å±å¹•:</strong> ${info.system.screen}</li> <li><strong>è§†çª—:</strong> ${info.system.viewport}</li> <li><strong>è‰²æ·±:</strong> ${info.system.colorDepth}ä½</li> </ul> </div> </div> <hr> <div class="row"> <div class="col-md-6"> <h6><i class="bi bi-speedometer2"></i> æ€§èƒ½ä¿¡æ¯</h6> <ul class="list-unstyled small"> ${typeof info.performance.memory === 'object' ? ` <li><strong>å†…å­˜ä½¿ç”¨:</strong> ${info.performance.memory.used}</li> <li><strong>å†…å­˜æ€»é‡:</strong> ${info.performance.memory.total}</li> <li><strong>å†…å­˜é™åˆ¶:</strong> ${info.performance.memory.limit}</li> ` : `<li><strong>å†…å­˜ä¿¡æ¯:</strong> ${info.performance.memory}</li>`} ${typeof info.performance.timing === 'object' ? ` <li><strong>é¡µé¢åŠ è½½:</strong> ${info.performance.timing.pageLoad}</li> <li><strong>DOMå°±ç»ª:</strong> ${info.performance.timing.domReady}</li> ` : `<li><strong>æ—¶é—´ä¿¡æ¯:</strong> ${info.performance.timing}</li>`} </ul> </div> <div class="col-md-6"> <h6><i class="bi bi-check-circle"></i> æ£€æµ‹ç»Ÿè®¡</h6> <ul class="list-unstyled small"> <li><strong>æ€»æµ‹è¯•æ•°:</strong> ${info.detection.totalTests}</li> <li><strong>å·²å®Œæˆ:</strong> ${info.detection.completedTests}</li> <li><strong>æˆåŠŸç‡:</strong> ${info.detection.successRate}</li> <li><strong>æœ€åè¿è¡Œ:</strong> ${info.detection.lastRunTime}</li> <li><strong>è¿è¡Œæ—¶é•¿:</strong> ${info.detection.runDuration}</li> </ul> </div> </div> </div> <div class="modal-footer"> <button type="button" class="btn btn-outline-light btn-sm" onclick="this.copySystemInfo()"> <i class="bi bi-clipboard"></i> å¤åˆ¶ä¿¡æ¯ </button> <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">å…³é—­</button> </div> </div> </div> </div> `; const existingModal = document.getElementById('systemInfoModal'); if (existingModal) { existingModal.remove(); } document.body.insertAdjacentHTML('beforeend', modalHTML); const modal = new bootstrap.Modal(document.getElementById('systemInfoModal')); modal.show(); this.logSuccess('ğŸ’» ç³»ç»Ÿä¿¡æ¯å·²æ˜¾ç¤º'); } showCustomDetectionModal() { const modalHTML = ` <div class="modal fade" id="customDetectionModal" tabindex="-1"> <div class="modal-dialog modal-lg"> <div class="modal-content bg-dark text-light"> <div class="modal-header"> <h5 class="modal-title"> <i class="bi bi-gear"></i> è‡ªå®šä¹‰æ£€æµ‹ </h5> <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button> </div> <div class="modal-body"> <p class="text-muted">é€‰æ‹©è¦æ‰§è¡Œçš„æ£€æµ‹é¡¹ç›®ï¼š</p> <div class="row"> ${this.generateCustomDetectionOptions()} </div> <hr> <div class="d-flex justify-content-between align-items-center"> <div> <button class="btn btn-outline-success btn-sm me-2" onclick="detectionSystem.selectAllTests()"> <i class="bi bi-check-all"></i> å…¨é€‰ </button> <button class="btn btn-outline-warning btn-sm" onclick="detectionSystem.clearAllTests()"> <i class="bi bi-x-square"></i> æ¸…ç©º </button> </div> <small class="text-muted"> å·²é€‰æ‹©: <span id="selectedTestCount">0</span> / ${this.totalTests} é¡¹ </small> </div> </div> <div class="modal-footer"> <button type="button" class="btn btn-success" onclick="detectionSystem.runSelectedTests()"> <i class="bi bi-play-circle"></i> å¼€å§‹æ£€æµ‹ </button> <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">å–æ¶ˆ</button> </div> </div> </div> </div> `; const existingModal = document.getElementById('customDetectionModal'); if (existingModal) { existingModal.remove(); } document.body.insertAdjacentHTML('beforeend', modalHTML); this.attachCustomModalEvents(); const modal = new bootstrap.Modal(document.getElementById('customDetectionModal')); modal.show(); this.logInfo('âš™ï¸ è‡ªå®šä¹‰æ£€æµ‹é€‰é¡¹å·²æ˜¾ç¤º'); } generateCustomDetectionOptions() { const categories = { backend: { name: 'åç«¯æ£€æµ‹', tests: ['serverHealth', 'apiResponse', 'databaseConnection'] }, websocket: { name: 'WebSocketæ£€æµ‹', tests: ['websocketConnection', 'messageDelivery', 'connectionStability'] }, frontend: { name: 'å‰ç«¯æ£€æµ‹', tests: ['resourceLoading', 'domStructure', 'scriptLoading', 'styleLoading', 'componentInitialization'] }, chat: { name: 'èŠå¤©åŠŸèƒ½', tests: ['messageProcessing', 'guestMode', 'uiInteraction'] }, performance: { name: 'æ€§èƒ½æ£€æµ‹', tests: ['loadingSpeed', 'memoryUsage', 'animationPerformance'] } }; return Object.entries(categories).map(([key, category]) => ` <div class="col-md-6 mb-3"> <div class="card bg-secondary"> <div class="card-header d-flex justify-content-between align-items-center"> <h6 class="mb-0">${category.name}</h6> <div class="form-check"> <input class="form-check-input category-checkbox" type="checkbox" id="category_${key}" data-category="${key}"> <label class="form-check-label" for="category_${key}">å…¨é€‰</label> </div> </div> <div class="card-body"> ${category.tests.map(test => ` <div class="form-check"> <input class="form-check-input test-checkbox" type="checkbox" id="test_${test}" data-test="${test}" data-category="${key}"> <label class="form-check-label" for="test_${test}"> ${this.getTestDisplayName(test)} </label> </div> `).join('')} </div> </div> </div> `).join(''); } getTestDisplayName(testKey) { const testNames = { serverHealth: 'æœåŠ¡å™¨å¥åº·çŠ¶å†µ', apiResponse: 'APIå“åº”æµ‹è¯•', databaseConnection: 'æ•°æ®åº“è¿æ¥', websocketConnection: 'WebSocketè¿æ¥', messageDelivery: 'æ¶ˆæ¯ä¼ é€’', connectionStability: 'è¿æ¥ç¨³å®šæ€§', resourceLoading: 'èµ„æºåŠ è½½', domStructure: 'DOMç»“æ„', scriptLoading: 'è„šæœ¬åŠ è½½', styleLoading: 'æ ·å¼åŠ è½½', componentInitialization: 'ç»„ä»¶åˆå§‹åŒ–', messageProcessing: 'æ¶ˆæ¯å¤„ç†', guestMode: 'è®¿å®¢æ¨¡å¼', uiInteraction: 'UIäº¤äº’', loadingSpeed: 'åŠ è½½é€Ÿåº¦', memoryUsage: 'å†…å­˜ä½¿ç”¨', animationPerformance: 'åŠ¨ç”»æ€§èƒ½' }; return testNames[testKey] || testKey; } attachCustomModalEvents() { document.querySelectorAll('.category-checkbox').forEach(checkbox => { checkbox.addEventListener('change', (e) => { const category = e.target.dataset.category; const checked = e.target.checked; document.querySelectorAll(`[data-category="${category}"].test-checkbox`).forEach(test => { test.checked = checked; }); this.updateSelectedCount(); }); }); document.querySelectorAll('.test-checkbox').forEach(checkbox => { checkbox.addEventListener('change', () => { this.updateSelectedCount(); this.updateCategoryCheckboxes(); }); }); } updateSelectedCount() { const selectedCount = document.querySelectorAll('.test-checkbox:checked').length; const countElement = document.getElementById('selectedTestCount'); if (countElement) { countElement.textContent = selectedCount; } } updateCategoryCheckboxes() { document.querySelectorAll('.category-checkbox').forEach(categoryCheckbox => { const category = categoryCheckbox.dataset.category; const testCheckboxes = document.querySelectorAll(`[data-category="${category}"].test-checkbox`); const checkedTests = document.querySelectorAll(`[data-category="${category}"].test-checkbox:checked`); if (checkedTests.length === 0) { categoryCheckbox.checked = false; categoryCheckbox.indeterminate = false; } else if (checkedTests.length === testCheckboxes.length) { categoryCheckbox.checked = true; categoryCheckbox.indeterminate = false; } else { categoryCheckbox.checked = false; categoryCheckbox.indeterminate = true; } }); } selectAllTests() { document.querySelectorAll('.test-checkbox').forEach(checkbox => { checkbox.checked = true; }); document.querySelectorAll('.category-checkbox').forEach(checkbox => { checkbox.checked = true; checkbox.indeterminate = false; }); this.updateSelectedCount(); } clearAllTests() { document.querySelectorAll('.test-checkbox').forEach(checkbox => { checkbox.checked = false; }); document.querySelectorAll('.category-checkbox').forEach(checkbox => { checkbox.checked = false; checkbox.indeterminate = false; }); this.updateSelectedCount(); } runSelectedTests() { const selectedTests = Array.from(document.querySelectorAll('.test-checkbox:checked')) .map(checkbox => checkbox.dataset.test); if (selectedTests.length === 0) { this.logWarning('âš ï¸ è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªæµ‹è¯•é¡¹ç›®'); return; } const modal = bootstrap.Modal.getInstance(document.getElementById('customDetectionModal')); if (modal) { modal.hide(); } this.logInfo(`ğŸš€ å¼€å§‹è‡ªå®šä¹‰æ£€æµ‹ï¼Œå…±é€‰æ‹© ${selectedTests.length} ä¸ªæµ‹è¯•é¡¹ç›®`); this.runCustomDetectionTests(selectedTests); } async runCustomDetectionTests(selectedTests) { this.startDetection(); this.totalTests = selectedTests.length; const testMethods = { serverHealth: () => this.testServerHealth(), apiResponse: () => this.testAPIResponse(), databaseConnection: () => this.testDatabaseConnection(), websocketConnection: () => this.testWebSocketConnection(), messageDelivery: () => this.testMessageDelivery(), connectionStability: () => this.testConnectionStability(), resourceLoading: () => this.testResourceLoading(), domStructure: () => this.testDOMStructure(), scriptLoading: () => this.testScriptLoading(), styleLoading: () => this.testStyleLoading(), componentInitialization: () => this.testComponentInitialization(), messageProcessing: () => this.testMessageProcessing(), guestMode: () => this.testGuestMode(), uiInteraction: () => this.testUIInteraction(), loadingSpeed: () => this.testLoadingSpeed(), memoryUsage: () => this.testMemoryUsage(), animationPerformance: () => this.testAnimationPerformance() }; for (const testKey of selectedTests) { if (testMethods[testKey]) { this.updateTestStatus(testKey, 'running'); try { await testMethods[testKey](); } catch (error) { this.logError(`âŒ æµ‹è¯• ${testKey} æ‰§è¡Œå¤±è´¥: ${error.message}`); this.updateTestStatus(testKey, 'error'); this.testResults.set(testKey, { status: 'error', error: error.message, name: this.getTestDisplayName(testKey) }); this.failedTests++; } this.completedTests++; this.updateProgress(); } } this.completeDetection(); } initializeDiagnosticRules() { this.diagnosticRules.set('connection', { patterns: [ /network error/i, /fetch.*failed/i, /connection.*refused/i, /timeout/i, /cors/i ], severity: 'high', suggestions: [ 'æ£€æŸ¥ç½‘ç»œè¿æ¥çŠ¶æ€', 'éªŒè¯æœåŠ¡å™¨æ˜¯å¦æ­£å¸¸è¿è¡Œ', 'ç¡®è®¤APIç«¯ç‚¹åœ°å€æ˜¯å¦æ­£ç¡®', 'æ£€æŸ¥CORSé…ç½®', 'æ£€æŸ¥é˜²ç«å¢™è®¾ç½®' ] }); this.diagnosticRules.set('authentication', { patterns: [ /unauthorized/i, /forbidden/i, /401|403/, /invalid.*token/i, /authentication.*failed/i ], severity: 'high', suggestions: [ 'æ£€æŸ¥èº«ä»½éªŒè¯ä»¤ç‰Œ', 'éªŒè¯ç”¨æˆ·æƒé™', 'ç¡®è®¤ç™»å½•çŠ¶æ€', 'æ£€æŸ¥APIå¯†é’¥é…ç½®' ] }); this.diagnosticRules.set('resource', { patterns: [ /not found/i, /404/, /file.*not.*found/i, /module.*not.*found/i, /script.*error/i ], severity: 'medium', suggestions: [ 'æ£€æŸ¥æ–‡ä»¶è·¯å¾„æ˜¯å¦æ­£ç¡®', 'ç¡®è®¤èµ„æºæ–‡ä»¶æ˜¯å¦å­˜åœ¨', 'éªŒè¯æ¨¡å—å¯¼å…¥è·¯å¾„', 'æ£€æŸ¥æ–‡ä»¶æƒé™è®¾ç½®' ] }); this.diagnosticRules.set('performance', { patterns: [ /slow/i, /performance/i, /memory/i, /lag/i, /delay/i ], severity: 'low', suggestions: [ 'ä¼˜åŒ–ä»£ç æ€§èƒ½', 'æ£€æŸ¥å†…å­˜ä½¿ç”¨æƒ…å†µ', 'å‡å°‘ä¸å¿…è¦çš„ç½‘ç»œè¯·æ±‚', 'ä½¿ç”¨ç¼“å­˜æœºåˆ¶', 'ä¼˜åŒ–æ•°æ®åº“æŸ¥è¯¢' ] }); this.diagnosticRules.set('syntax', { patterns: [ /syntax.*error/i, /unexpected.*token/i, /parse.*error/i, /invalid.*json/i ], severity: 'medium', suggestions: [ 'æ£€æŸ¥ä»£ç è¯­æ³•', 'éªŒè¯JSONæ ¼å¼', 'ç¡®è®¤æ‹¬å·åŒ¹é…', 'æ£€æŸ¥å­—ç¬¦ç¼–ç ' ] }); } diagnoseError(error, context = {}) { const errorMsg = error.message || error.toString(); const diagnosis = { error: errorMsg, context: context, matches: [], severity: 'unknown', suggestions: ['è”ç³»æŠ€æœ¯æ”¯æŒè·å–å¸®åŠ©'], timestamp: Date.now() }; for (const [ruleType, rule] of this.diagnosticRules) { for (const pattern of rule.patterns) { if (pattern.test(errorMsg)) { diagnosis.matches.push(ruleType); diagnosis.severity = rule.severity; diagnosis.suggestions = rule.suggestions; break; } } } if (context.testType) { diagnosis.suggestions.unshift(`é’ˆå¯¹${context.testType}æµ‹è¯•ï¼Œè¯·æ£€æŸ¥ç›¸å…³é…ç½®`); } return diagnosis; } generateAdvancedReport() { const now = Date.now(); const report = { metadata: { generatedAt: new Date(now).toISOString(), systemVersion: '2.0.0', sessionId: this.currentSession.sessionId, environment: this.currentSession.environment }, summary: { totalTests: this.totalTests, completedTests: this.completedTests, successRate: this.completedTests > 0 ? (this.passedTests / this.completedTests * 100).toFixed(2) : 0, averageTestTime: this.getAverageTestTime(), lastRunTime: this.startTime ? now - this.startTime : 0 }, performance: this.getPerformanceMetrics(), history: this.getHistoricalTrends(), recommendations: this.generateRecommendations(), testResults: this.getCurrentTestResults(), diagnostics: this.getDiagnosticSummary() }; return report; } getPerformanceMetrics() { const metrics = { totalBaselines: this.performanceBaseline.size, averagePerformance: 0, performanceDistribution: {}, topPerformers: [], poorPerformers: [] }; if (this.performanceBaseline.size === 0) return metrics; const performanceData = Array.from(this.performanceBaseline.entries()).map(([key, data]) => ({ test: key, average: data.averageTime, best: data.bestTime, worst: data.worstTime, runs: data.runCount })); const totalAvg = performanceData.reduce((sum, item) => sum + item.average, 0); metrics.averagePerformance = Math.round(totalAvg / performanceData.length); performanceData.forEach(item => { const range = this.getPerformanceRange(item.average); metrics.performanceDistribution[range] = (metrics.performanceDistribution[range] || 0) + 1; }); const sortedByAvg = performanceData.sort((a, b) => a.average - b.average); metrics.topPerformers = sortedByAvg.slice(0, 3); metrics.poorPerformers = sortedByAvg.slice(-3).reverse(); return metrics; } getPerformanceRange(time) { if (time < 100) return 'excellent'; if (time < 500) return 'good'; if (time < 1000) return 'average'; if (time < 3000) return 'slow'; return 'poor'; } getHistoricalTrends() { const trends = { totalRuns: this.testHistory.length, successTrend: [], performanceTrend: [], categoryDistribution: {}, timeDistribution: {} }; if (this.testHistory.length === 0) return trends; const dayGroups = {}; this.testHistory.forEach(entry => { const day = new Date(entry.timestamp).toDateString(); if (!dayGroups[day]) { dayGroups[day] = { total: 0, success: 0 }; } dayGroups[day].total++; if (entry.status === 'success') { dayGroups[day].success++; } }); trends.successTrend = Object.entries(dayGroups).map(([day, data]) => ({ date: day, successRate: (data.success / data.total * 100).toFixed(2) })); this.testHistory.forEach(entry => { trends.categoryDistribution[entry.category] = (trends.categoryDistribution[entry.category] || 0) + 1; }); this.testHistory.forEach(entry => { const hour = new Date(entry.timestamp).getHours(); trends.timeDistribution[hour] = (trends.timeDistribution[hour] || 0) + 1; }); return trends; } generateRecommendations() { const recommendations = []; const successRate = this.completedTests > 0 ? (this.passedTests / this.completedTests) : 0; if (successRate < 0.8) { recommendations.push({ type: 'reliability', priority: 'high', message: 'æµ‹è¯•æˆåŠŸç‡è¾ƒä½ï¼Œå»ºè®®æ£€æŸ¥ç³»ç»Ÿç¨³å®šæ€§', details: `å½“å‰æˆåŠŸç‡: ${(successRate * 100).toFixed(2)}%ï¼Œå»ºè®®ç›®æ ‡: 90%ä»¥ä¸Š` }); } const avgTime = this.getAverageTestTime(); if (avgTime > 1000) { recommendations.push({ type: 'performance', priority: 'medium', message: 'æµ‹è¯•æ‰§è¡Œæ—¶é—´è¾ƒé•¿ï¼Œå»ºè®®ä¼˜åŒ–æ€§èƒ½', details: `å¹³å‡æµ‹è¯•æ—¶é—´: ${avgTime}msï¼Œå»ºè®®ç›®æ ‡: 1000msä»¥ä¸‹` }); } if (this.testHistory.length < 10) { recommendations.push({ type: 'monitoring', priority: 'low', message: 'å»ºè®®å¢åŠ æµ‹è¯•é¢‘ç‡ä»¥è·å¾—æ›´å¥½çš„ç›‘æ§æ•ˆæœ', details: 'å»ºè®®æ¯æ—¥è‡³å°‘æ‰§è¡Œä¸€æ¬¡å®Œæ•´æ£€æµ‹' }); } if (!this.autoDetectionEnabled) { recommendations.push({ type: 'automation', priority: 'medium', message: 'å»ºè®®å¯ç”¨è‡ªåŠ¨æ£€æµ‹åŠŸèƒ½', details: 'è‡ªåŠ¨æ£€æµ‹å¯ä»¥åŠæ—¶å‘ç°ç³»ç»Ÿé—®é¢˜ï¼Œæé«˜ç³»ç»Ÿå¯é æ€§' }); } return recommendations; } getCurrentTestResults() { const results = {}; for (const [key, result] of this.testResults) { results[key] = { status: result.status, duration: result.duration, timestamp: result.timestamp, details: result.details }; } return results; } getDiagnosticSummary() { const summary = { totalErrors: 0, errorsByType: {}, severityDistribution: {}, commonIssues: [] }; this.testHistory.forEach(entry => { if (entry.status === 'error' && entry.error) { summary.totalErrors++; const diagnosis = this.diagnoseError(new Error(entry.error)); diagnosis.matches.forEach(match => { summary.errorsByType[match] = (summary.errorsByType[match] || 0) + 1; }); summary.severityDistribution[diagnosis.severity] = (summary.severityDistribution[diagnosis.severity] || 0) + 1; } }); summary.commonIssues = Object.entries(summary.errorsByType) .sort(([,a], [,b]) => b - a) .slice(0, 5) .map(([type, count]) => ({ type, count })); return summary; } getAverageTestTime() { if (this.testHistory.length === 0) return 0; const times = this.testHistory .filter(entry => entry.duration) .map(entry => entry.duration); if (times.length === 0) return 0; return Math.round(times.reduce((sum, time) => sum + time, 0) / times.length); } enableAutoDetection(frequency) { if (this.isRunning) { this.logWarning('âš ï¸ æ£€æµ‹æ­£åœ¨è¿›è¡Œä¸­ï¼Œæ— æ³•å¯ç”¨è‡ªåŠ¨æ£€æµ‹'); return; } this.disableAutoDetection(); this.autoDetectionEnabled = true; this.detectionFrequency = frequency; this.autoDetectionInterval = setInterval(() => { if (!this.isRunning) { this.logInfo(`ğŸ”„ è‡ªåŠ¨æ£€æµ‹å¯åŠ¨ (é—´éš”: ${frequency}åˆ†é’Ÿ)`); this.runQuickDetection(); if (this.notificationSystem) { this.notificationSystem.notify({ type: 'info', title: 'è‡ªåŠ¨æ£€æµ‹', message: `å®šæ—¶æ£€æµ‹å·²å¯åŠ¨ï¼Œé—´éš”: ${frequency}åˆ†é’Ÿ`, duration: 3000 }); } } }, frequency * 60 * 1000); this.updateAutoDetectionStatus(); this.saveToStorage(); this.logSuccess(`âœ… è‡ªåŠ¨æ£€æµ‹å·²å¯ç”¨ï¼Œé—´éš”: ${frequency}åˆ†é’Ÿ`); if (this.notificationSystem) { this.notificationSystem.notify({ type: 'success', title: 'è‡ªåŠ¨æ£€æµ‹å¯ç”¨', message: `è‡ªåŠ¨æ£€æµ‹å·²å¯ç”¨ï¼Œæ£€æµ‹é—´éš”: ${frequency}åˆ†é’Ÿ`, duration: 4000 }); } } disableAutoDetection() { if (this.autoDetectionInterval) { clearInterval(this.autoDetectionInterval); this.autoDetectionInterval = null; } this.autoDetectionEnabled = false; this.updateAutoDetectionStatus(); this.saveToStorage(); this.logInfo('ğŸ›‘ è‡ªåŠ¨æ£€æµ‹å·²åœç”¨'); if (this.notificationSystem) { this.notificationSystem.notify({ type: 'info', title: 'è‡ªåŠ¨æ£€æµ‹åœç”¨', message: 'è‡ªåŠ¨æ£€æµ‹å·²åœç”¨', duration: 3000 }); } } updateAutoDetectionStatus() { const statusElement = document.getElementById('autoDetectionStatus'); if (statusElement) { if (this.autoDetectionEnabled) { statusElement.textContent = `è‡ªåŠ¨æ£€æµ‹: ${this.detectionFrequency}åˆ†é’Ÿ`; statusElement.className = 'badge bg-success auto-detection-status active'; } else { statusElement.textContent = 'è‡ªåŠ¨æ£€æµ‹: æœªå¯ç”¨'; statusElement.className = 'badge bg-secondary'; } } } getDashboardData() { return { overview: this.getOverviewData(), performance: this.getPerformanceData(), trends: this.getTrendsData(), realtime: this.getRealtimeData(), history: this.testHistory, session: this.currentSession }; } getOverviewData() { const currentResults = Array.from(this.testResults.values()); const overview = { total: this.totalTests, completed: this.completedTests, passed: this.passedTests, failed: this.failedTests, warning: this.warningTests, successRate: this.totalTests > 0 ? ((this.passedTests / this.completedTests) * 100).toFixed(1) : 0 }; const categoryStats = {}; Object.keys(this.testCategories).forEach(categoryKey => { const category = this.testCategories[categoryKey]; categoryStats[category.name] = { total: category.tests.length, completed: 0, passed: 0, failed: 0, warning: 0 }; category.tests.forEach(test => { const result = this.testResults.get(test.id); if (result) { categoryStats[category.name].completed++; if (result.status === 'success') categoryStats[category.name].passed++; else if (result.status === 'error') categoryStats[category.name].failed++; else if (result.status === 'warning') categoryStats[category.name].warning++; } }); }); return { ...overview, categoryStats }; } getPerformanceData() { const performanceData = { baseline: Object.fromEntries(this.performanceBaseline), currentSession: { startTime: this.currentSession.startTime, duration: Date.now() - this.currentSession.startTime, testsCompleted: this.completedTests, avgTestTime: this.completedTests > 0 ? (Date.now() - this.currentSession.startTime) / this.completedTests : 0 }, recentPerformance: this.getRecentPerformanceTrends() }; return performanceData; } getTrendsData() { const recentHistory = this.testHistory.slice(-20); const trends = { timestamps: recentHistory.map(record => new Date(record.timestamp).toLocaleTimeString()), successRates: recentHistory.map(record => { const total = record.results ? record.results.length : 0; const passed = record.results ? record.results.filter(r => r.status === 'success').length : 0; return total > 0 ? ((passed / total) * 100).toFixed(1) : 0; }), testCounts: recentHistory.map(record => record.results ? record.results.length : 0), avgDuration: recentHistory.map(record => record.duration || 0) }; return trends; } getRealtimeData() { const now = Date.now(); return { timestamp: now, isRunning: this.isRunning, isPaused: this.isPaused, currentProgress: this.completedTests / this.totalTests * 100, estimatedTimeRemaining: this.getEstimatedTimeRemaining(), systemMetrics: { memoryUsage: this.getMemoryUsage(), performanceNow: performance.now(), connectionStatus: navigator.onLine ? 'online' : 'offline' }, recentTests: Array.from(this.testResults.values()).slice(-5) }; } getRecentPerformanceTrends() { const recent = this.testHistory.slice(-10); return recent.map(record => ({ timestamp: record.timestamp, duration: record.duration || 0, successRate: record.results ? (record.results.filter(r => r.status === 'success').length / record.results.length * 100) : 0, testCount: record.results ? record.results.length : 0 })); } getEstimatedTimeRemaining() { if (!this.isRunning || this.completedTests === 0) return 0; const elapsed = Date.now() - this.startTime; const avgTimePerTest = elapsed / this.completedTests; const remainingTests = this.totalTests - this.completedTests; return remainingTests * avgTimePerTest; } getMemoryUsage() { if (performance.memory) { return { used: Math.round(performance.memory.usedJSHeapSize / 1024 / 1024), total: Math.round(performance.memory.totalJSHeapSize / 1024 / 1024), limit: Math.round(performance.memory.jsHeapSizeLimit / 1024 / 1024) }; } return null; } } function runFullDetection() { if (detectionSystem) { detectionSystem.runFullDetection(); } } function runQuickDetection() { if (detectionSystem) { detectionSystem.runQuickDetection(); } } function runCustomDetection() { if (detectionSystem) { detectionSystem.runCustomDetection(); } } function clearResults() { if (detectionSystem) { detectionSystem.clearResults(); } } function exportResults() { if (detectionSystem) { detectionSystem.exportResults(); } } function exportJSON() { if (detectionSystem) { detectionSystem.exportJSON(); } } function exportCSV() { if (detectionSystem) { detectionSystem.exportCSV(); } } function exportPDF() { if (detectionSystem) { detectionSystem.exportPDF(); } } function logInfo(message) { if (detectionSystem) { detectionSystem.logInfo(message); } } function logSuccess(message) { if (detectionSystem) { detectionSystem.logSuccess(message); } } function logWarning(message) { if (detectionSystem) { detectionSystem.logWarning(message); } } function logError(message) { if (detectionSystem) { detectionSystem.logError(message); } } function clearLog() { if (detectionSystem) { detectionSystem.clearLog(); } } function toggleAutoScroll() { if (detectionSystem) { detectionSystem.toggleAutoScroll(); } } function exportLog() { if (detectionSystem) { detectionSystem.exportLog(); } } function showVisualizationDashboard() { if (detectionSystem) { detectionSystem.showVisualizationDashboard(); } } function showTeamCollaboration() { if (detectionSystem) { detectionSystem.showTeamCollaboration(); } } function showIntelligentAlertSystem() { if (detectionSystem) { detectionSystem.showIntelligentAlertSystem(); } } function toggleAutoMode() { if (detectionSystem) { detectionSystem.toggleAutoMode(); } } function showSystemInfo() { if (detectionSystem) { detectionSystem.showSystemInfo(); } } function showHistory() { if (detectionSystem) { detectionSystem.showHistoryModal(); } } function showPerformanceReport() { if (detectionSystem) { detectionSystem.showPerformanceModal(); } } function enableAutoDetection() { if (detectionSystem) { const frequency = prompt('è¯·è¾“å…¥è‡ªåŠ¨æ£€æµ‹é—´éš”(åˆ†é’Ÿ):', '30'); if (frequency && !isNaN(frequency) && frequency > 0) { detectionSystem.enableAutoDetection(parseInt(frequency)); } } } function disableAutoDetection() { if (detectionSystem) { detectionSystem.disableAutoDetection(); } } function exportAdvancedReport() { if (detectionSystem) { const report = detectionSystem.generateAdvancedReport(); detectionSystem.downloadJSON(report, `advanced-report-${Date.now()}.json`); detectionSystem.logSuccess('ğŸ“Š é«˜çº§æŠ¥å‘Šå·²å¯¼å‡º'); } } function resetPerformanceBaseline() { if (detectionSystem) { if (confirm('ç¡®å®šè¦é‡ç½®æ‰€æœ‰æ€§èƒ½åŸºå‡†æ•°æ®å—ï¼Ÿ')) { detectionSystem.resetBaseline(); } } } function clearAllData() { if (detectionSystem) { if (confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰å†å²è®°å½•å’Œæ€§èƒ½æ•°æ®å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚')) { detectionSystem.clearHistory(); detectionSystem.resetBaseline(); detectionSystem.logSuccess('ğŸ—‘ï¸ æ‰€æœ‰æ•°æ®å·²æ¸…ç©º'); } } } window.detectionSystem = detectionSystem; window.initializeDetectionSystem = initializeDetectionSystem; window.runFullDetection = runFullDetection; window.runQuickDetection = runQuickDetection; window.runCustomDetection = runCustomDetection; window.clearResults = clearResults; window.exportResults = exportResults; window.exportJSON = exportJSON; window.exportCSV = exportCSV; window.exportPDF = exportPDF; window.toggleAutoMode = toggleAutoMode; window.showSystemInfo = showSystemInfo; window.showHistory = showHistory; window.showPerformanceReport = showPerformanceReport; window.enableAutoDetection = enableAutoDetection; window.disableAutoDetection = disableAutoDetection; window.exportAdvancedReport = exportAdvancedReport; window.resetPerformanceBaseline = resetPerformanceBaseline; window.clearAllData = clearAllData; window.logInfo = logInfo; window.logSuccess = logSuccess; window.logWarning = logWarning; window.logError = logError; window.clearLog = clearLog; window.toggleAutoScroll = toggleAutoScroll; window.exportLog = exportLog; document.addEventListener('DOMContentLoaded', function() { initializeDetectionSystem(); if (detectionSystem && detectionSystem.autoDetectionEnabled) { detectionSystem.enableAutoDetection(detectionSystem.detectionFrequency); } if (detectionSystem) { detectionSystem.logInfo('ğŸš€ AlingAié›†æˆæ£€æµ‹ç³»ç»Ÿå·²åˆå§‹åŒ–'); detectionSystem.logInfo('ğŸ’¡ æç¤º: ä½¿ç”¨Ctrl+Rå¿«é€Ÿæ£€æµ‹, Ctrl+Få®Œæ•´æ£€æµ‹'); } }); window.addEventListener('beforeunload', function() { if (detectionSystem && detectionSystem.autoDetectionInterval) { clearInterval(detectionSystem.autoDetectionInterval); } });