 class FloatingButtonsManager { constructor() { this.buttons = new Map(); this.zIndexBase = 1000; this.positions = { // å®šä¹‰æ ‡å‡†ä½ç½®ç½‘æ ¼ (å³ä¾§è¾¹æ åŒºåŸŸ) 'top-right-1': { top: '20px', right: '20px' }, // æ€§èƒ½ä»ªè¡¨æ¿ 'top-right-2': { top: '90px', right: '20px' }, // æ‰©å±•ä½ç½®1 'middle-right-1': { top: '50%', right: '20px', transform: 'translateY(-50%)' }, // ä¸­é—´ä½ç½® 'bottom-right-1': { bottom: '140px', right: '20px' }, // èŠå¤©æŒ‰é’® 'bottom-right-2': { bottom: '80px', right: '20px' }, // è‡ªå®šä¹‰æŒ‰é’® 'bottom-right-3': { bottom: '20px', right: '20px' }, // è°ƒè¯•æ§åˆ¶å° // å·¦ä¾§ä½ç½® (å¦‚æœéœ€è¦) 'bottom-left-1': { bottom: '20px', left: '20px' }, 'top-left-1': { top: '20px', left: '20px' } }; this.occupiedPositions = new Set(); this.init(); } init() { this.createManagerCSS(); this.setupGlobalEventListeners(); console.log('ğŸ¯ æ‚¬æµ®æŒ‰é’®ç®¡ç†å™¨å·²åˆå§‹åŒ–'); } createManagerCSS() { const style = document.createElement('style'); style.id = 'floating-buttons-manager-styles'; style.textContent = ` .floating-btn-managed { position: fixed !important; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1) !important; border-radius: 50% !important; width: 56px !important; height: 56px !important; display: flex !important; align-items: center !important; justify-content: center !important; cursor: pointer !important; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15) !important; backdrop-filter: blur(10px) !important; border: none !important; outline: none !important; user-select: none !important; } .floating-btn-managed:hover { transform: translateY(-2px) scale(1.05) !important; box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2) !important; } .floating-btn-managed:active { transform: translateY(0) scale(0.98) !important; } .floating-btn-chat { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%) !important; color: white !important; z-index: 1010 !important; } .floating-btn-dashboard { background: linear-gradient(135deg, #06b6d4 0%, #3b82f6 100%) !important; color: white !important; z-index: 1020 !important; } .floating-btn-customization { background: linear-gradient(135deg, #00ffff 0%, #00ff00 100%) !important; color: #000 !important; z-index: 1030 !important; font-size: 20px !important; } .floating-btn-debug { background: linear-gradient(135deg, #374151 0%, #1f2937 100%) !important; color: white !important; border: 1px solid #4b5563 !important; z-index: 1040 !important; } @media (max-width: 768px) { .floating-btn-managed { width: 48px !important; height: 48px !important; font-size: 16px !important; } .floating-btn-managed[data-position="top-right-1"] { top: 10px !important; right: 10px !important; } .floating-btn-managed[data-position="bottom-right-1"] { bottom: 80px !important; right: 10px !important; } .floating-btn-managed[data-position="bottom-right-2"] { bottom: 140px !important; right: 10px !important; } .floating-btn-managed[data-position="bottom-right-3"] { bottom: 20px !important; right: 10px !important; } } .floating-btn-managed.hidden { opacity: 0 !important; pointer-events: none !important; transform: scale(0.8) !important; } .floating-btn-badge { position: absolute; top: -4px; right: -4px; background: #ef4444; color: white; border-radius: 50%; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; font-size: 10px; font-weight: bold; border: 2px solid white; z-index: 1; } .floating-btn-tooltip { position: absolute; right: 100%; top: 50%; transform: translateY(-50%); background: rgba(0, 0, 0, 0.8); color: white; padding: 6px 12px; border-radius: 6px; font-size: 12px; white-space: nowrap; opacity: 0; pointer-events: none; transition: opacity 0.2s ease; margin-right: 10px; backdrop-filter: blur(10px); } .floating-btn-managed:hover .floating-btn-tooltip { opacity: 1; } .floating-buttons-collapsed .floating-btn-managed:not(.primary) { opacity: 0.3; pointer-events: none; transform: scale(0.7); } `; document.head.appendChild(style); } registerButton(id, config) { const { element, preferredPosition, type = 'default', priority = 0, title = '', icon = '', onClick = null, badge = null } = config; // ä¸ºç°æœ‰æŒ‰é’®åˆ†é…ä½ç½® const position = this.allocatePosition(preferredPosition, priority); if (!position) { console.warn(`æ— æ³•ä¸ºæŒ‰é’® ${id} åˆ†é…ä½ç½®`); return false; } // åº”ç”¨ç»Ÿä¸€æ ·å¼å’Œä½ç½® this.applyButtonStyles(element, type, position, { title, icon, badge }); // æ³¨å†Œç‚¹å‡»äº‹ä»¶ if (onClick) { element.addEventListener('click', onClick); } // å­˜å‚¨æŒ‰é’®ä¿¡æ¯ this.buttons.set(id, { element, position, type, priority, config }); console.log(`âœ… æ‚¬æµ®æŒ‰é’® ${id} å·²æ³¨å†Œåˆ°ä½ç½® ${position}`); return true; } allocatePosition(preferred, priority) { // å¦‚æœé¦–é€‰ä½ç½®å¯ç”¨ï¼Œä½¿ç”¨å®ƒ if (preferred && this.positions[preferred] && !this.occupiedPositions.has(preferred)) { this.occupiedPositions.add(preferred); return preferred; } // å¦åˆ™æŒ‰ä¼˜å…ˆçº§åˆ†é…å¯ç”¨ä½ç½® const availablePositions = Object.keys(this.positions) .filter(pos => !this.occupiedPositions.has(pos)) .sort(); // æŒ‰åç§°æ’åºç¡®ä¿ä¸€è‡´æ€§ if (availablePositions.length > 0) { const allocated = availablePositions[0]; this.occupiedPositions.add(allocated); return allocated; } return null; // æ— å¯ç”¨ä½ç½® } applyButtonStyles(element, type, position, options = {}) { // æ·»åŠ åŸºç¡€ç±» element.classList.add('floating-btn-managed', `floating-btn-${type}`); element.setAttribute('data-position', position); // åº”ç”¨ä½ç½®æ ·å¼ const posConfig = this.positions[position]; Object.keys(posConfig).forEach(key => { element.style[key] = posConfig[key]; }); // æ·»åŠ å›¾æ ‡ï¼ˆå¦‚æœæä¾›ï¼‰ if (options.icon && !element.querySelector('.floating-btn-icon')) { element.innerHTML = `<i class="floating-btn-icon ${options.icon}"></i>`; } // æ·»åŠ å·¥å…·æç¤º if (options.title) { const tooltip = document.createElement('div'); tooltip.className = 'floating-btn-tooltip'; tooltip.textContent = options.title; element.appendChild(tooltip); } // æ·»åŠ å¾½ç«  if (options.badge) { this.updateBadge(element, options.badge); } } updateBadge(element, badgeText) { let badge = element.querySelector('.floating-btn-badge'); if (!badge) { badge = document.createElement('div'); badge.className = 'floating-btn-badge'; element.appendChild(badge); } badge.textContent = badgeText; badge.style.display = badgeText ? 'flex' : 'none'; } toggleButton(id, visible = null) { const button = this.buttons.get(id); if (!button) return false; const isVisible = visible !== null ? visible : button.element.classList.contains('hidden'); if (isVisible) { button.element.classList.remove('hidden'); } else { button.element.classList.add('hidden'); } return true; } unregisterButton(id) { const button = this.buttons.get(id); if (!button) return false; // é‡Šæ”¾ä½ç½® this.occupiedPositions.delete(button.position); // ç§»é™¤å…ƒç´  if (button.element.parentNode) { button.element.parentNode.removeChild(button.element); } // ä»æ³¨å†Œè¡¨ç§»é™¤ this.buttons.delete(id); console.log(`ğŸ—‘ï¸ æ‚¬æµ®æŒ‰é’® ${id} å·²ç§»é™¤`); return true; } getButtonsStatus() { const status = {}; this.buttons.forEach((button, id) => { status[id] = { position: button.position, type: button.type, visible: !button.element.classList.contains('hidden'), element: button.element }; }); return status; } setupGlobalEventListeners() { // é”®ç›˜å¿«æ·é”® document.addEventListener('keydown', (e) => { // Ctrl+Shift+H éšè—/æ˜¾ç¤ºæ‰€æœ‰æ‚¬æµ®æŒ‰é’® if (e.ctrlKey && e.shiftKey && e.key === 'H') { e.preventDefault(); this.toggleAllButtons(); } }); // çª—å£å¤§å°å˜åŒ–æ—¶é‡æ–°æ’åˆ— window.addEventListener('resize', () => { this.repositionButtons(); }); } toggleAllButtons() { const hasVisible = Array.from(this.buttons.values()) .some(button => !button.element.classList.contains('hidden')); this.buttons.forEach((button, id) => { this.toggleButton(id, !hasVisible); }); } repositionButtons() { this.buttons.forEach((button) => { const posConfig = this.positions[button.position]; Object.keys(posConfig).forEach(key => { button.element.style[key] = posConfig[key]; }); }); } optimizeLayout() { const buttonsArray = Array.from(this.buttons.entries()) .sort(([,a], [,b]) => b.priority - a.priority); // æŒ‰ä¼˜å…ˆçº§æ’åº // é‡æ–°åˆ†é…ä½ç½® this.occupiedPositions.clear(); buttonsArray.forEach(([id, button]) => { const newPosition = this.allocatePosition(null, button.priority); if (newPosition && newPosition !== button.position) { button.position = newPosition; this.applyButtonStyles(button.element, button.type, newPosition, button.config); console.log(`ğŸ”„ æŒ‰é’® ${id} é‡æ–°å®šä½åˆ° ${newPosition}`); } }); } } // å…¨å±€å®ä¾‹ window.floatingButtonsManager = new FloatingButtonsManager(); console.log('ğŸ¯ æ‚¬æµ®æŒ‰é’®ç®¡ç†å™¨å·²åŠ è½½'); 