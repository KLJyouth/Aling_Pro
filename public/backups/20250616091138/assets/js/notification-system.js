 class NotificationSystem { constructor() { this.isEnabled = true; this.soundEnabled = true; this.desktopEnabled = true; this.visualEnabled = true; this.notificationHistory = []; this.maxHistoryRecords = 100; // é€šçŸ¥ç±»å‹é…ç½® this.notificationTypes = { success: { icon: 'âœ…', color: '#28a745', sound: 'success', priority: 'normal' }, warning: { icon: 'âš ï¸', color: '#ffc107', sound: 'warning', priority: 'normal' }, error: { icon: 'âŒ', color: '#dc3545', sound: 'error', priority: 'high' }, info: { icon: 'â„¹ï¸', color: '#17a2b8', sound: 'info', priority: 'low' } }; // å£°éŸ³æ–‡ä»¶URLs (ä½¿ç”¨Web Audio APIç”Ÿæˆ) this.sounds = { success: null, warning: null, error: null, info: null }; // åˆå§‹åŒ– this.init(); } async init() { // è¯·æ±‚æ¡Œé¢é€šçŸ¥æƒé™ await this.requestPermissions(); // åˆå§‹åŒ–å£°éŸ³ç³»ç»Ÿ this.initSounds(); // åˆ›å»ºè§†è§‰é€šçŸ¥å®¹å™¨ this.createNotificationContainer(); // åŠ è½½ç”¨æˆ·åå¥½è®¾ç½® this.loadSettings(); console.log('ğŸ”” é€šçŸ¥ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ'); } async requestPermissions() { if ('Notification' in window) { if (Notification.permission === 'default') { try { const permission = await Notification.requestPermission(); this.desktopEnabled = permission === 'granted'; console.log(`ğŸ”” æ¡Œé¢é€šçŸ¥æƒé™: ${permission}`); } catch (error) { console.warn('æ¡Œé¢é€šçŸ¥æƒé™è¯·æ±‚å¤±è´¥:', error); this.desktopEnabled = false; } } else { this.desktopEnabled = Notification.permission === 'granted'; } } else { console.warn('æ­¤æµè§ˆå™¨ä¸æ”¯æŒæ¡Œé¢é€šçŸ¥'); this.desktopEnabled = false; } } initSounds() { // å»¶è¿ŸéŸ³é¢‘åˆå§‹åŒ–ï¼Œç­‰å¾…ç”¨æˆ·äº¤äº’ this.audioInitialized = false; this.pendingAudioInit = true; // æ·»åŠ ç‚¹å‡»ç›‘å¬å™¨æ¥åˆå§‹åŒ–éŸ³é¢‘ document.addEventListener('click', () => { if (this.pendingAudioInit && !this.audioInitialized) { this.initAudioContext(); } }, { once: true }); console.log('ğŸ”‡ éŸ³é¢‘ç³»ç»Ÿå°†åœ¨ç”¨æˆ·äº¤äº’ååˆå§‹åŒ–'); } initAudioContext() { try { if ('AudioContext' in window || 'webkitAudioContext' in window) { this.audioContext = new (window.AudioContext || window.webkitAudioContext)(); // æ¢å¤éŸ³é¢‘ä¸Šä¸‹æ–‡ï¼ˆå¦‚æœè¢«æš‚åœï¼‰ if (this.audioContext.state === 'suspended') { this.audioContext.resume().then(() => { this.generateSounds(); this.audioInitialized = true; this.pendingAudioInit = false; console.log('ğŸ”Š éŸ³é¢‘ç³»ç»Ÿåˆå§‹åŒ–æˆåŠŸ'); }); } else { this.generateSounds(); this.audioInitialized = true; this.pendingAudioInit = false; console.log('ğŸ”Š éŸ³é¢‘ç³»ç»Ÿåˆå§‹åŒ–æˆåŠŸ'); } } else { console.warn('æ­¤æµè§ˆå™¨ä¸æ”¯æŒWeb Audio API'); this.soundEnabled = false; this.pendingAudioInit = false; } } catch (error) { console.warn('éŸ³é¢‘åˆå§‹åŒ–å¤±è´¥:', error); this.soundEnabled = false; this.pendingAudioInit = false; } } generateSounds() { // æˆåŠŸéŸ³ - æ¸…è„†çš„åŒéŸ³ this.sounds.success = this.createTone([800, 1000], [0.1, 0.1], 'sine'); // è­¦å‘ŠéŸ³ - ä¸­é¢‘ä¸‰éŸ³ this.sounds.warning = this.createTone([600, 700, 600], [0.15, 0.15, 0.15], 'triangle'); // é”™è¯¯éŸ³ - ä½é¢‘é•¿éŸ³ this.sounds.error = this.createTone([300, 250], [0.3, 0.3], 'sawtooth'); // ä¿¡æ¯éŸ³ - æ¸©å’Œå•éŸ³ this.sounds.info = this.createTone([500], [0.2], 'sine'); } createTone(frequencies, durations, waveType = 'sine') { const sampleRate = this.audioContext.sampleRate; const totalDuration = durations.reduce((sum, dur) => sum + dur, 0); const buffer = this.audioContext.createBuffer(1, sampleRate * totalDuration, sampleRate); const data = buffer.getChannelData(0); let currentTime = 0; for (let i = 0; i < frequencies.length; i++) { const frequency = frequencies[i]; const duration = durations[i]; const startSample = Math.floor(currentTime * sampleRate); const endSample = Math.floor((currentTime + duration) * sampleRate); for (let sample = startSample; sample < endSample; sample++) { const time = sample / sampleRate; const envelope = Math.sin((time - currentTime) / duration * Math.PI); // åŒ…ç»œ switch (waveType) { case 'sine': data[sample] = Math.sin(2 * Math.PI * frequency * time) * envelope * 0.1; break; case 'triangle': data[sample] = (2 / Math.PI) * Math.asin(Math.sin(2 * Math.PI * frequency * time)) * envelope * 0.1; break; case 'sawtooth': data[sample] = (2 * (frequency * time - Math.floor(frequency * time + 0.5))) * envelope * 0.1; break; } } currentTime += duration; } return buffer; } playSound(type) { // æ£€æŸ¥éŸ³é¢‘æ˜¯å¦å¯ç”¨ if (!this.soundEnabled || !this.audioInitialized || !this.audioContext || !this.sounds[type]) { return; } try { // ç¡®ä¿éŸ³é¢‘ä¸Šä¸‹æ–‡å¤„äºè¿è¡ŒçŠ¶æ€ if (this.audioContext.state === 'suspended') { this.audioContext.resume().then(() => { this.playAudioBuffer(type); }).catch(error => { console.warn('éŸ³é¢‘ä¸Šä¸‹æ–‡æ¢å¤å¤±è´¥:', error); }); } else { this.playAudioBuffer(type); } } catch (error) { console.warn('æ’­æ”¾é€šçŸ¥å£°éŸ³å¤±è´¥:', error); } } playAudioBuffer(type) { try { const source = this.audioContext.createBufferSource(); source.buffer = this.sounds[type]; source.connect(this.audioContext.destination); source.start(); } catch (error) { console.warn('éŸ³é¢‘æ’­æ”¾é”™è¯¯:', error); } } createNotificationContainer() { // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨ if (document.getElementById('notification-container')) return; const container = document.createElement('div'); container.id = 'notification-container'; container.style.cssText = ` position: fixed; top: 20px; right: 20px; z-index: 10000; max-width: 350px; pointer-events: none; `; document.body.appendChild(container); // æ·»åŠ CSSæ ·å¼ const style = document.createElement('style'); style.textContent = ` .notification-toast { background: rgba(255, 255, 255, 0.95); border-radius: 8px; box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15); margin-bottom: 10px; padding: 16px; border-left: 4px solid; backdrop-filter: blur(10px); animation: slideInRight 0.3s ease-out; pointer-events: auto; position: relative; overflow: hidden; } .notification-toast::before { content: ''; position: absolute; top: 0; left: 0; right: 0; height: 2px; background: linear-gradient(90deg, transparent, currentColor, transparent); animation: shimmer 2s infinite; } .notification-header { display: flex; align-items: center; margin-bottom: 8px; font-weight: 600; } .notification-icon { font-size: 18px; margin-right: 8px; } .notification-title { flex: 1; font-size: 14px; } .notification-time { font-size: 11px; color: #666; margin-left: 8px; } .notification-body { font-size: 13px; color: #555; line-height: 1.4; } .notification-close { position: absolute; top: 8px; right: 8px; background: none; border: none; font-size: 16px; cursor: pointer; opacity: 0.5; transition: opacity 0.2s; } .notification-close:hover { opacity: 1; } @keyframes slideInRight { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } } @keyframes slideOutRight { from { transform: translateX(0); opacity: 1; } to { transform: translateX(100%); opacity: 0; } } @keyframes shimmer { 0% { transform: translateX(-100%); } 100% { transform: translateX(100%); } } .notification-success { border-left-color: #28a745; color: #28a745; } .notification-warning { border-left-color: #ffc107; color: #ffc107; } .notification-error { border-left-color: #dc3545; color: #dc3545; } .notification-info { border-left-color: #17a2b8; color: #17a2b8; } `; document.head.appendChild(style); } notify(title, message, type = 'info', options = {}) { if (!this.isEnabled) return; const notification = { id: this.generateId(), title, message, type, timestamp: Date.now(), options: { persistent: false, autoClose: true, duration: 5000, showDesktop: true, playSound: true, ...options } }; // æ·»åŠ åˆ°å†å²è®°å½• this.addToHistory(notification); // æ˜¾ç¤ºæ¡Œé¢é€šçŸ¥ if (notification.options.showDesktop && this.desktopEnabled) { this.showDesktopNotification(notification); } // æ˜¾ç¤ºè§†è§‰é€šçŸ¥ if (this.visualEnabled) { this.showVisualNotification(notification); } // æ’­æ”¾å£°éŸ³ if (notification.options.playSound && this.soundEnabled) { this.playSound(type); } // è§¦å‘è‡ªå®šä¹‰äº‹ä»¶ this.dispatchNotificationEvent(notification); return notification.id; } showDesktopNotification(notification) { if (!this.desktopEnabled) return; const config = this.notificationTypes[notification.type]; try { const desktopNotification = new Notification(notification.title, { body: notification.message, icon: `/favicon.ico`, // ä½¿ç”¨é¡¹ç›®å›¾æ ‡ badge: `/favicon.ico`, tag: notification.id, requireInteraction: notification.options.persistent, silent: !notification.options.playSound }); // è‡ªåŠ¨å…³é—­ if (notification.options.autoClose && !notification.options.persistent) { setTimeout(() => { desktopNotification.close(); }, notification.options.duration); } // ç‚¹å‡»å¤„ç† desktopNotification.onclick = () => { window.focus(); desktopNotification.close(); this.handleNotificationClick(notification); }; } catch (error) { console.warn('æ˜¾ç¤ºæ¡Œé¢é€šçŸ¥å¤±è´¥:', error); } } showVisualNotification(notification) { const container = document.getElementById('notification-container'); if (!container) return; const config = this.notificationTypes[notification.type]; const toast = document.createElement('div'); toast.className = `notification-toast notification-${notification.type}`; toast.id = `toast-${notification.id}`; toast.innerHTML = ` <div class="notification-header"> <span class="notification-icon">${config.icon}</span> <span class="notification-title">${notification.title}</span> <span class="notification-time">${this.formatTime(notification.timestamp)}</span> </div> <div class="notification-body">${notification.message}</div> <button class="notification-close" onclick="notificationSystem.closeToast('${notification.id}')">&times;</button> `; container.appendChild(toast); // è‡ªåŠ¨ç§»é™¤ if (notification.options.autoClose) { setTimeout(() => { this.closeToast(notification.id); }, notification.options.duration); } // æ·»åŠ ç‚¹å‡»äº‹ä»¶ toast.addEventListener('click', (e) => { if (e.target.className !== 'notification-close') { this.handleNotificationClick(notification); } }); } closeToast(notificationId) { const toast = document.getElementById(`toast-${notificationId}`); if (!toast) return; toast.style.animation = 'slideOutRight 0.3s ease-in'; setTimeout(() => { if (toast.parentNode) { toast.parentNode.removeChild(toast); } }, 300); } handleNotificationClick(notification) { // è§¦å‘è‡ªå®šä¹‰äº‹ä»¶ const event = new CustomEvent('notificationClick', { detail: notification }); document.dispatchEvent(event); // å¦‚æœæœ‰å›è°ƒå‡½æ•° if (notification.options.onClick) { notification.options.onClick(notification); } } dispatchNotificationEvent(notification) { const event = new CustomEvent('notification', { detail: notification }); document.dispatchEvent(event); } addToHistory(notification) { this.notificationHistory.unshift(notification); // é™åˆ¶å†å²è®°å½•æ•°é‡ if (this.notificationHistory.length > this.maxHistoryRecords) { this.notificationHistory = this.notificationHistory.slice(0, this.maxHistoryRecords); } // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨ this.saveToStorage(); } getHistory(type = null, limit = null) { let history = this.notificationHistory; if (type) { history = history.filter(n => n.type === type); } if (limit) { history = history.slice(0, limit); } return history; } clearHistory() { this.notificationHistory = []; this.saveToStorage(); } showHistoryModal() { const modalHtml = ` <div class="modal fade" id="notificationHistoryModal" tabindex="-1"> <div class="modal-dialog modal-lg"> <div class="modal-content"> <div class="modal-header"> <h5 class="modal-title"> <i class="bi bi-bell"></i> é€šçŸ¥å†å²è®°å½• </h5> <button type="button" class="btn-close" data-bs-dismiss="modal"></button> </div> <div class="modal-body"> <div class="d-flex justify-content-between mb-3"> <div> <small class="text-muted">å…± ${this.notificationHistory.length} æ¡é€šçŸ¥è®°å½•</small> </div> <div> <button class="btn btn-sm btn-outline-danger" onclick="notificationSystem.clearHistory(); notificationSystem.showHistoryModal();"> <i class="bi bi-trash"></i> æ¸…ç©ºè®°å½• </button> </div> </div> <div class="notification-history-list" style="max-height: 400px; overflow-y: auto;"> ${this.renderHistoryList()} </div> </div> <div class="modal-footer"> <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">å…³é—­</button> <button type="button" class="btn btn-primary" onclick="notificationSystem.exportHistory()"> <i class="bi bi-download"></i> å¯¼å‡ºè®°å½• </button> </div> </div> </div> </div> `; // ç§»é™¤ç°æœ‰æ¨¡æ€æ¡† const existingModal = document.getElementById('notificationHistoryModal'); if (existingModal) { existingModal.remove(); } // æ·»åŠ æ–°æ¨¡æ€æ¡† document.body.insertAdjacentHTML('beforeend', modalHtml); // æ˜¾ç¤ºæ¨¡æ€æ¡† const modal = new bootstrap.Modal(document.getElementById('notificationHistoryModal')); modal.show(); } renderHistoryList() { if (this.notificationHistory.length === 0) { return '<div class="text-center text-muted py-4">æš‚æ— é€šçŸ¥è®°å½•</div>'; } return this.notificationHistory.map(notification => { const config = this.notificationTypes[notification.type]; const timeStr = new Date(notification.timestamp).toLocaleString(); return ` <div class="notification-history-item p-3 border-bottom"> <div class="d-flex align-items-start"> <span class="notification-icon me-2" style="color: ${config.color}"> ${config.icon} </span> <div class="flex-grow-1"> <div class="fw-bold mb-1">${notification.title}</div> <div class="text-muted small mb-1">${notification.message}</div> <div class="text-muted" style="font-size: 11px;"> ${timeStr} </div> </div> <span class="badge bg-${this.getBootstrapColor(notification.type)} ms-2"> ${notification.type.toUpperCase()} </span> </div> </div> `; }).join(''); } getBootstrapColor(type) { const colorMap = { success: 'success', warning: 'warning', error: 'danger', info: 'info' }; return colorMap[type] || 'secondary'; } exportHistory() { const data = { exportTime: new Date().toISOString(), totalNotifications: this.notificationHistory.length, notifications: this.notificationHistory }; const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = `notification-history-${new Date().toISOString().split('T')[0]}.json`; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); this.notify('å¯¼å‡ºå®Œæˆ', 'é€šçŸ¥å†å²è®°å½•å·²å¯¼å‡ºåˆ°ä¸‹è½½æ–‡ä»¶å¤¹', 'success'); } setPreferences(preferences) { Object.assign(this, preferences); this.saveToStorage(); this.notify('è®¾ç½®å·²æ›´æ–°', 'é€šçŸ¥åå¥½è®¾ç½®å·²ä¿å­˜', 'info'); } formatTime(timestamp) { const now = Date.now(); const diff = now - timestamp; if (diff < 60000) return 'åˆšåˆš'; if (diff < 3600000) return `${Math.floor(diff / 60000)}åˆ†é’Ÿå‰`; if (diff < 86400000) return `${Math.floor(diff / 3600000)}å°æ—¶å‰`; return new Date(timestamp).toLocaleDateString(); } generateId() { return Date.now().toString(36) + Math.random().toString(36).substr(2); } saveToStorage() { try { const data = { isEnabled: this.isEnabled, soundEnabled: this.soundEnabled, desktopEnabled: this.desktopEnabled, visualEnabled: this.visualEnabled, history: this.notificationHistory.slice(0, this.maxHistoryRecords) }; localStorage.setItem('aidNotificationSystem', JSON.stringify(data)); } catch (error) { console.warn('ä¿å­˜é€šçŸ¥ç³»ç»Ÿè®¾ç½®å¤±è´¥:', error); } } loadSettings() { try { const data = JSON.parse(localStorage.getItem('aidNotificationSystem') || '{}'); this.isEnabled = data.isEnabled !== false; this.soundEnabled = data.soundEnabled !== false; this.visualEnabled = data.visualEnabled !== false; this.notificationHistory = data.history || []; // æ¡Œé¢é€šçŸ¥æƒé™éœ€è¦é‡æ–°æ£€æŸ¥ this.desktopEnabled = this.desktopEnabled && (data.desktopEnabled !== false); } catch (error) { console.warn('åŠ è½½é€šçŸ¥ç³»ç»Ÿè®¾ç½®å¤±è´¥:', error); } } getStatus() { return { isEnabled: this.isEnabled, soundEnabled: this.soundEnabled, desktopEnabled: this.desktopEnabled, visualEnabled: this.visualEnabled, historyCount: this.notificationHistory.length, permissionStatus: Notification.permission }; } } // åˆ›å»ºå…¨å±€å®ä¾‹ window.notificationSystem = new NotificationSystem(); // å¯¼å‡ºç±» if (typeof module !== 'undefined' && module.exports) { module.exports = NotificationSystem; } 