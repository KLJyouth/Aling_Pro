 class APIIntegration { constructor() { this.apiKey = null; this.apiEndpoints = new Map(); this.webhookEndpoints = new Map(); this.externalServices = new Map(); this.syncQueue = []; this.rateLimiter = new Map(); this.authTokens = new Map(); this.isInitialized = false; // APIé…ç½® this.config = { baseUrl: '/api/v1', timeout: 30000, retryAttempts: 3, rateLimitWindow: 60000, // 1åˆ†é’Ÿ maxRequestsPerWindow: 100, enableWebhooks: true, webhookSecret: null }; // æ”¯æŒçš„å¤–éƒ¨æœåŠ¡ this.supportedServices = { slack: { name: 'Slack', icon: 'slack', color: '#4A154B' }, teams: { name: 'Microsoft Teams', icon: 'microsoft', color: '#6264A7' }, discord: { name: 'Discord', icon: 'discord', color: '#5865F2' }, email: { name: 'Email', icon: 'envelope', color: '#EA4335' }, webhook: { name: 'Custom Webhook', icon: 'webhook', color: '#28a745' }, grafana: { name: 'Grafana', icon: 'graph-up', color: '#F46800' }, prometheus: { name: 'Prometheus', icon: 'speedometer2', color: '#E6522C' }, elastic: { name: 'Elasticsearch', icon: 'search', color: '#005571' }, jira: { name: 'Jira', icon: 'kanban', color: '#0052CC' }, github: { name: 'GitHub', icon: 'github', color: '#24292e' } };  } // ==================== åˆå§‹åŒ–æ–¹æ³• ==================== async initialize(detectionSystem) { if (this.isInitialized) return; this.detectionSystem = detectionSystem; await this.loadConfiguration(); this.setupAPIEndpoints(); this.initializeWebhooks(); this.setupRateLimiting(); this.startSyncService(); this.isInitialized = true;  } async loadConfiguration() { try { const savedConfig = localStorage.getItem('api-integration-config'); if (savedConfig) { const config = JSON.parse(savedConfig); this.config = { ...this.config, ...config }; } // åŠ è½½APIå¯†é’¥ const savedApiKey = localStorage.getItem('api-integration-key'); if (savedApiKey) { this.apiKey = savedApiKey; } // åŠ è½½å¤–éƒ¨æœåŠ¡é…ç½® const savedServices = localStorage.getItem('external-services-config'); if (savedServices) { const services = JSON.parse(savedServices); services.forEach(service => { this.externalServices.set(service.id, service); }); }  } catch (error) { console.error('âŒ é…ç½®åŠ è½½å¤±è´¥:', error); } } saveConfiguration() { try { localStorage.setItem('api-integration-config', JSON.stringify(this.config)); if (this.apiKey) { localStorage.setItem('api-integration-key', this.apiKey); } const services = Array.from(this.externalServices.values()); localStorage.setItem('external-services-config', JSON.stringify(services));  } catch (error) { console.error('âŒ é…ç½®ä¿å­˜å¤±è´¥:', error); } } // ==================== RESTful API æ¥å£ ==================== setupAPIEndpoints() { // æ£€æµ‹ç»“æœAPI this.apiEndpoints.set('GET /detection/results', { handler: this.getDetectionResults.bind(this), description: 'è·å–æ£€æµ‹ç»“æœ', auth: true }); this.apiEndpoints.set('POST /detection/start', { handler: this.startDetection.bind(this), description: 'å¯åŠ¨æ£€æµ‹', auth: true }); this.apiEndpoints.set('GET /detection/status', { handler: this.getDetectionStatus.bind(this), description: 'è·å–æ£€æµ‹çŠ¶æ€', auth: false }); this.apiEndpoints.set('GET /detection/history', { handler: this.getDetectionHistory.bind(this), description: 'è·å–æ£€æµ‹å†å²', auth: true }); // ç³»ç»Ÿä¿¡æ¯API this.apiEndpoints.set('GET /system/info', { handler: this.getSystemInfo.bind(this), description: 'è·å–ç³»ç»Ÿä¿¡æ¯', auth: false }); this.apiEndpoints.set('GET /system/metrics', { handler: this.getSystemMetrics.bind(this), description: 'è·å–ç³»ç»ŸæŒ‡æ ‡', auth: true }); // é…ç½®ç®¡ç†API this.apiEndpoints.set('GET /config', { handler: this.getConfiguration.bind(this), description: 'è·å–é…ç½®', auth: true }); this.apiEndpoints.set('PUT /config', { handler: this.updateConfiguration.bind(this), description: 'æ›´æ–°é…ç½®', auth: true });  } // APIå¤„ç†æ–¹æ³• async getDetectionResults(params) { if (!this.detectionSystem) { throw new Error('æ£€æµ‹ç³»ç»Ÿæœªåˆå§‹åŒ–'); } const results = Array.from(this.detectionSystem.testResults.entries()).map(([key, result]) => ({ testId: key, status: result.status, duration: result.duration, timestamp: result.timestamp, details: result.details })); return { success: true, data: { results, summary: { total: this.detectionSystem.totalTests, completed: this.detectionSystem.completedTests, passed: this.detectionSystem.passedTests, failed: this.detectionSystem.failedTests, successRate: this.detectionSystem.completedTests > 0 ? (this.detectionSystem.passedTests / this.detectionSystem.completedTests * 100).toFixed(2) : 0 } }, timestamp: Date.now() }; } async startDetection(params) { if (!this.detectionSystem) { throw new Error('æ£€æµ‹ç³»ç»Ÿæœªåˆå§‹åŒ–'); } const { type = 'full', tests = null } = params; try { if (type === 'custom' && tests) { await this.detectionSystem.runCustomDetectionTests(tests); } else if (type === 'quick') { await this.detectionSystem.runQuickDetection(); } else { await this.detectionSystem.runFullDetection(); } return { success: true, message: 'æ£€æµ‹å·²å¯åŠ¨', sessionId: this.detectionSystem.currentSession.sessionId, timestamp: Date.now() }; } catch (error) { throw new Error(`æ£€æµ‹å¯åŠ¨å¤±è´¥: ${error.message}`); } } async getDetectionStatus(params) { if (!this.detectionSystem) { throw new Error('æ£€æµ‹ç³»ç»Ÿæœªåˆå§‹åŒ–'); } return { success: true, data: { isRunning: this.detectionSystem.isRunning, isPaused: this.detectionSystem.isPaused, progress: this.detectionSystem.totalTests > 0 ? (this.detectionSystem.completedTests / this.detectionSystem.totalTests * 100) : 0, currentTest: this.detectionSystem.currentTest, sessionId: this.detectionSystem.currentSession.sessionId, autoDetectionEnabled: this.detectionSystem.autoDetectionEnabled }, timestamp: Date.now() }; } async getDetectionHistory(params) { if (!this.detectionSystem) { throw new Error('æ£€æµ‹ç³»ç»Ÿæœªåˆå§‹åŒ–'); } const { limit = 50, offset = 0, startDate = null, endDate = null } = params; let history = [...this.detectionSystem.testHistory]; // æ—¥æœŸè¿‡æ»¤ if (startDate) { history = history.filter(record => record.timestamp >= new Date(startDate).getTime()); } if (endDate) { history = history.filter(record => record.timestamp <= new Date(endDate).getTime()); } // åˆ†é¡µ const total = history.length; const records = history.slice(offset, offset + limit); return { success: true, data: { records, pagination: { total, limit, offset, hasMore: offset + limit < total } }, timestamp: Date.now() }; } async getSystemInfo(params) { return { success: true, data: { version: '2.0.0', environment: this.detectionSystem?.currentSession?.environment || {}, uptime: Date.now() - (this.detectionSystem?.currentSession?.startTime || Date.now()), apiVersion: '1.0', features: { notifications: true, visualization: true, apiIntegration: true, collaboration: false, intelligentAlerts: false } }, timestamp: Date.now() }; } async getSystemMetrics(params) { if (!this.detectionSystem) { throw new Error('æ£€æµ‹ç³»ç»Ÿæœªåˆå§‹åŒ–'); } const dashboardData = this.detectionSystem.getDashboardData(); return { success: true, data: { performance: dashboardData.performance, overview: dashboardData.overview, trends: dashboardData.trends, realtime: dashboardData.realtime }, timestamp: Date.now() }; } async getConfiguration(params) { return { success: true, data: { config: this.config, endpoints: Array.from(this.apiEndpoints.keys()), webhooks: Array.from(this.webhookEndpoints.keys()), services: Array.from(this.externalServices.values()) }, timestamp: Date.now() }; } async updateConfiguration(params) { try { const { config, webhooks, services } = params; if (config) { this.config = { ...this.config, ...config }; } if (webhooks) { webhooks.forEach(webhook => { this.addWebhook(webhook.event, webhook.url, webhook.options); }); } if (services) { services.forEach(service => { this.addExternalService(service); }); } this.saveConfiguration(); return { success: true, message: 'é…ç½®å·²æ›´æ–°', timestamp: Date.now() }; } catch (error) { throw new Error(`é…ç½®æ›´æ–°å¤±è´¥: ${error.message}`); } } // ==================== APIè¯·æ±‚å¤„ç† ==================== async handleAPIRequest(method, path, params = {}, headers = {}) { const endpoint = `${method} ${path}`; const apiEndpoint = this.apiEndpoints.get(endpoint); if (!apiEndpoint) { throw new Error(`APIç«¯ç‚¹ä¸å­˜åœ¨: ${endpoint}`); } // èº«ä»½éªŒè¯æ£€æŸ¥ if (apiEndpoint.auth && !this.verifyAuth(headers)) { throw new Error('èº«ä»½éªŒè¯å¤±è´¥'); } // é€Ÿç‡é™åˆ¶æ£€æŸ¥ if (!this.checkRateLimit(headers.clientId || 'default')) { throw new Error('è¯·æ±‚é¢‘ç‡è¿‡é«˜ï¼Œè¯·ç¨åå†è¯•'); } try { const result = await apiEndpoint.handler(params); this.logAPIUsage(endpoint, 'success', headers); return result; } catch (error) { this.logAPIUsage(endpoint, 'error', headers, error); throw error; } } verifyAuth(headers) { const authHeader = headers.authorization || headers.Authorization; if (!authHeader) return false; const token = authHeader.replace('Bearer ', ''); return token === this.apiKey || this.authTokens.has(token); } checkRateLimit(clientId) { const now = Date.now(); const windowStart = now - this.config.rateLimitWindow; if (!this.rateLimiter.has(clientId)) { this.rateLimiter.set(clientId, []); } const requests = this.rateLimiter.get(clientId); // æ¸…ç†è¿‡æœŸè¯·æ±‚ const validRequests = requests.filter(timestamp => timestamp > windowStart); this.rateLimiter.set(clientId, validRequests); // æ£€æŸ¥æ˜¯å¦è¶…è¿‡é™åˆ¶ if (validRequests.length >= this.config.maxRequestsPerWindow) { return false; } // è®°å½•å½“å‰è¯·æ±‚ validRequests.push(now); return true; } logAPIUsage(endpoint, status, headers, error = null) { const logEntry = { timestamp: Date.now(), endpoint, status, clientId: headers.clientId || 'unknown', userAgent: headers.userAgent || headers['user-agent'] || 'unknown', error: error ? error.message : null }; // è¿™é‡Œå¯ä»¥å‘é€åˆ°æ—¥å¿—ç³»ç»Ÿæˆ–åˆ†ææœåŠ¡  } // ==================== Webhook æ”¯æŒ ==================== initializeWebhooks() { // é¢„å®šä¹‰çš„webhookäº‹ä»¶ const webhookEvents = [ 'detection.started', 'detection.completed', 'detection.failed', 'test.passed', 'test.failed', 'system.error', 'performance.threshold', 'auto.detection.enabled', 'auto.detection.disabled' ]; webhookEvents.forEach(event => { this.webhookEndpoints.set(event, new Set()); });  } addWebhook(event, url, options = {}) { if (!this.webhookEndpoints.has(event)) { this.webhookEndpoints.set(event, new Set()); } const webhook = { url, options: { method: 'POST', headers: { 'Content-Type': 'application/json', 'User-Agent': 'AlingAi-Detection-System/2.0' }, timeout: 5000, retryAttempts: 3, ...options }, createdAt: Date.now(), lastTriggered: null, triggerCount: 0 }; this.webhookEndpoints.get(event).add(webhook);  this.saveConfiguration(); return webhook; } removeWebhook(event, url) { if (!this.webhookEndpoints.has(event)) return false; const webhooks = this.webhookEndpoints.get(event); const webhook = Array.from(webhooks).find(w => w.url === url); if (webhook) { webhooks.delete(webhook);  this.saveConfiguration(); return true; } return false; } async triggerWebhook(event, data) { if (!this.config.enableWebhooks || !this.webhookEndpoints.has(event)) { return; } const webhooks = this.webhookEndpoints.get(event); if (webhooks.size === 0) return; const payload = { event, timestamp: Date.now(), data, source: 'AlingAi-Detection-System', version: '2.0.0' }; // æ·»åŠ ç­¾åï¼ˆå¦‚æœé…ç½®äº†å¯†é’¥ï¼‰ if (this.config.webhookSecret) { payload.signature = this.generateWebhookSignature(payload); } const promises = Array.from(webhooks).map(webhook => this.sendWebhook(webhook, payload) ); try { await Promise.allSettled(promises);  } catch (error) { console.error('âŒ Webhookè§¦å‘å¤±è´¥:', error); } } async sendWebhook(webhook, payload) { for (let attempt = 1; attempt <= webhook.options.retryAttempts; attempt++) { try { const response = await fetch(webhook.url, { method: webhook.options.method, headers: webhook.options.headers, body: JSON.stringify(payload), timeout: webhook.options.timeout }); if (response.ok) { webhook.lastTriggered = Date.now(); webhook.triggerCount++; return response; } throw new Error(`HTTP ${response.status}: ${response.statusText}`); } catch (error) { if (attempt === webhook.options.retryAttempts) { console.error(`âŒ Webhookå‘é€å¤±è´¥ (${webhook.url}):`, error); throw error; } // æŒ‡æ•°é€€é¿ await this.delay(Math.pow(2, attempt) * 1000); } } } generateWebhookSignature(payload) { // ç®€å•çš„HMAC-SHA256ç­¾åå®ç° const message = JSON.stringify(payload); // è¿™é‡Œåº”è¯¥ä½¿ç”¨çœŸæ­£çš„HMAC-SHA256ï¼Œè¿™åªæ˜¯ç¤ºä¾‹ return btoa(this.config.webhookSecret + message).slice(0, 32); } // ==================== å¤–éƒ¨ç³»ç»Ÿé›†æˆ ==================== addExternalService(serviceConfig) { const service = { id: serviceConfig.id || this.generateId(), type: serviceConfig.type, name: serviceConfig.name, config: serviceConfig.config || {}, enabled: serviceConfig.enabled !== false, createdAt: Date.now(), lastUsed: null, usageCount: 0 }; this.externalServices.set(service.id, service); console.log(`ğŸ”— å·²æ·»åŠ å¤–éƒ¨æœåŠ¡: ${service.name} (${service.type})`); this.saveConfiguration(); return service; } removeExternalService(serviceId) { if (this.externalServices.has(serviceId)) { const service = this.externalServices.get(serviceId); this.externalServices.delete(serviceId);  this.saveConfiguration(); return true; } return false; } async sendToExternalService(serviceId, data, event = null) { const service = this.externalServices.get(serviceId); if (!service || !service.enabled) { throw new Error('å¤–éƒ¨æœåŠ¡ä¸å­˜åœ¨æˆ–å·²ç¦ç”¨'); } try { let result; switch (service.type) { case 'slack': result = await this.sendToSlack(service, data, event); break; case 'teams': result = await this.sendToTeams(service, data, event); break; case 'discord': result = await this.sendToDiscord(service, data, event); break; case 'email': result = await this.sendEmail(service, data, event); break; case 'webhook': result = await this.sendCustomWebhook(service, data, event); break; case 'grafana': result = await this.sendToGrafana(service, data, event); break; case 'prometheus': result = await this.sendToPrometheus(service, data, event); break; default: throw new Error(`ä¸æ”¯æŒçš„æœåŠ¡ç±»å‹: ${service.type}`); } service.lastUsed = Date.now(); service.usageCount++; this.saveConfiguration(); return result; } catch (error) { console.error(`âŒ å‘é€åˆ°å¤–éƒ¨æœåŠ¡å¤±è´¥ (${service.name}):`, error); throw error; } } // å…·ä½“çš„å¤–éƒ¨æœåŠ¡å‘é€æ–¹æ³• async sendToSlack(service, data, event) { const webhook_url = service.config.webhookUrl; if (!webhook_url) { throw new Error('Slack Webhook URLæœªé…ç½®'); } const message = this.formatSlackMessage(data, event); const response = await fetch(webhook_url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(message) }); if (!response.ok) { throw new Error(`Slackå‘é€å¤±è´¥: ${response.statusText}`); } return { success: true, service: 'slack' }; } async sendToTeams(service, data, event) { const webhook_url = service.config.webhookUrl; if (!webhook_url) { throw new Error('Teams Webhook URLæœªé…ç½®'); } const message = this.formatTeamsMessage(data, event); const response = await fetch(webhook_url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(message) }); if (!response.ok) { throw new Error(`Teamså‘é€å¤±è´¥: ${response.statusText}`); } return { success: true, service: 'teams' }; } async sendToDiscord(service, data, event) { const webhook_url = service.config.webhookUrl; if (!webhook_url) { throw new Error('Discord Webhook URLæœªé…ç½®'); } const message = this.formatDiscordMessage(data, event); const response = await fetch(webhook_url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(message) }); if (!response.ok) { throw new Error(`Discordå‘é€å¤±è´¥: ${response.statusText}`); } return { success: true, service: 'discord' }; } async sendEmail(service, data, event) { // è¿™é‡Œéœ€è¦å®é™…çš„é‚®ä»¶å‘é€æœåŠ¡  return { success: true, service: 'email', note: 'éœ€è¦åç«¯é‚®ä»¶æœåŠ¡' }; } async sendCustomWebhook(service, data, event) { const url = service.config.url; if (!url) { throw new Error('Webhook URLæœªé…ç½®'); } const payload = { event, data, timestamp: Date.now(), source: 'AlingAi-Detection-System' }; const response = await fetch(url, { method: service.config.method || 'POST', headers: { 'Content-Type': 'application/json', ...service.config.headers }, body: JSON.stringify(payload) }); if (!response.ok) { throw new Error(`Webhookå‘é€å¤±è´¥: ${response.statusText}`); } return { success: true, service: 'webhook' }; } async sendToGrafana(service, data, event) { // Grafanaæ³¨è§£API const url = `${service.config.url}/api/annotations`; const apiKey = service.config.apiKey; if (!url || !apiKey) { throw new Error('Grafanaé…ç½®ä¸å®Œæ•´'); } const annotation = { text: this.formatGrafanaAnnotation(data, event), tags: ['alingai', 'detection', event], time: Date.now(), isRegion: false }; const response = await fetch(url, { method: 'POST', headers: { 'Authorization': `Bearer ${apiKey}`, 'Content-Type': 'application/json' }, body: JSON.stringify(annotation) }); if (!response.ok) { throw new Error(`Grafanaå‘é€å¤±è´¥: ${response.statusText}`); } return { success: true, service: 'grafana' }; } async sendToPrometheus(service, data, event) { // Prometheus Pushgateway const url = service.config.pushgatewayUrl; if (!url) { throw new Error('Prometheus Pushgateway URLæœªé…ç½®'); } const metrics = this.formatPrometheusMetrics(data, event); const response = await fetch(`${url}/metrics/job/alingai_detection`, { method: 'POST', headers: { 'Content-Type': 'text/plain' }, body: metrics }); if (!response.ok) { throw new Error(`Prometheuså‘é€å¤±è´¥: ${response.statusText}`); } return { success: true, service: 'prometheus' }; } // ==================== æ¶ˆæ¯æ ¼å¼åŒ–æ–¹æ³• ==================== formatSlackMessage(data, event) { const color = this.getEventColor(event); const emoji = this.getEventEmoji(event); return { attachments: [{ color, blocks: [{ type: 'section', text: { type: 'mrkdwn', text: `${emoji} *AlingAiæ£€æµ‹ç³»ç»Ÿé€šçŸ¥*\n\n*äº‹ä»¶:* ${event}\n*æ—¶é—´:* ${new Date().toLocaleString()}` } }, { type: 'section', fields: this.formatDataFields(data) }] }] }; } formatTeamsMessage(data, event) { const color = this.getEventColor(event); const emoji = this.getEventEmoji(event); return { '@type': 'MessageCard', '@context': 'http://schema.org/extensions', themeColor: color, summary: `AlingAiæ£€æµ‹ç³»ç»Ÿ: ${event}`, sections: [{ activityTitle: `${emoji} AlingAiæ£€æµ‹ç³»ç»Ÿé€šçŸ¥`, activitySubtitle: `äº‹ä»¶: ${event}`, facts: this.formatTeamsFacts(data) }] }; } formatDiscordMessage(data, event) { const color = parseInt(this.getEventColor(event).replace('#', ''), 16); const emoji = this.getEventEmoji(event); return { embeds: [{ title: `${emoji} AlingAiæ£€æµ‹ç³»ç»Ÿé€šçŸ¥`, description: `**äº‹ä»¶:** ${event}\n**æ—¶é—´:** ${new Date().toLocaleString()}`, color, fields: this.formatDiscordFields(data), timestamp: new Date().toISOString() }] }; } formatGrafanaAnnotation(data, event) { return `AlingAiæ£€æµ‹ç³»ç»Ÿ: ${event} - ${JSON.stringify(data)}`; } formatPrometheusMetrics(data, event) { const timestamp = Date.now(); let metrics = `# AlingAi Detection System Metrics\n`; metrics += `alingai_detection_event{event="${event}"} 1 ${timestamp}\n`; if (data.successRate !== undefined) { metrics += `alingai_detection_success_rate ${data.successRate} ${timestamp}\n`; } if (data.duration !== undefined) { metrics += `alingai_detection_duration_ms ${data.duration} ${timestamp}\n`; } return metrics; } // ==================== å·¥å…·æ–¹æ³• ==================== getEventColor(event) { const colorMap = { 'detection.completed': '#28a745', 'detection.failed': '#dc3545', 'test.passed': '#28a745', 'test.failed': '#dc3545', 'system.error': '#dc3545', 'performance.threshold': '#ffc107' }; return colorMap[event] || '#17a2b8'; } getEventEmoji(event) { const emojiMap = { 'detection.started': 'ğŸš€', 'detection.completed': 'âœ…', 'detection.failed': 'âŒ', 'test.passed': 'âœ…', 'test.failed': 'âŒ', 'system.error': 'ğŸš¨', 'performance.threshold': 'âš ï¸', 'auto.detection.enabled': 'ğŸ”„', 'auto.detection.disabled': 'â¹ï¸' }; return emojiMap[event] || 'ğŸ“Š'; } formatDataFields(data) { const fields = []; Object.entries(data).forEach(([key, value]) => { fields.push({ type: 'mrkdwn', text: `*${key}:* ${value}` }); }); return fields; } formatTeamsFacts(data) { return Object.entries(data).map(([key, value]) => ({ name: key, value: String(value) })); } formatDiscordFields(data) { return Object.entries(data).map(([key, value]) => ({ name: key, value: String(value), inline: true })); } generateId() { return 'svc_' + Math.random().toString(36).substr(2, 9); } delay(ms) { return new Promise(resolve => setTimeout(resolve, ms)); } // ==================== æ•°æ®åŒæ­¥æœåŠ¡ ==================== startSyncService() { // æ¯5åˆ†é’ŸåŒæ­¥ä¸€æ¬¡æ•°æ® setInterval(() => { this.processSyncQueue(); }, 5 * 60 * 1000);  } addToSyncQueue(data, priority = 'normal') { this.syncQueue.push({ id: this.generateId(), data, priority, timestamp: Date.now(), retries: 0, maxRetries: 3 }); } async processSyncQueue() { if (this.syncQueue.length === 0) return; // æŒ‰ä¼˜å…ˆçº§æ’åº this.syncQueue.sort((a, b) => { const priorityOrder = { high: 3, normal: 2, low: 1 }; return priorityOrder[b.priority] - priorityOrder[a.priority]; }); const batch = this.syncQueue.splice(0, 10); // æ¯æ¬¡å¤„ç†10ä¸ª for (const item of batch) { try { await this.syncDataItem(item); } catch (error) { console.error('âŒ æ•°æ®åŒæ­¥å¤±è´¥:', error); if (item.retries < item.maxRetries) { item.retries++; this.syncQueue.push(item); // é‡æ–°åŠ å…¥é˜Ÿåˆ— } } } } async syncDataItem(item) { // è¿™é‡Œå®ç°å…·ä½“çš„æ•°æ®åŒæ­¥é€»è¾‘  // å‘é€åˆ°å·²é…ç½®çš„å¤–éƒ¨æœåŠ¡ const promises = Array.from(this.externalServices.values()) .filter(service => service.enabled && service.config.autoSync) .map(service => this.sendToExternalService(service.id, item.data, 'data.sync')); await Promise.allSettled(promises); } // ==================== å…¬å…±æ¥å£æ–¹æ³• ==================== show() { if (!this.isInitialized) { console.warn('âš ï¸ APIé›†æˆç³»ç»Ÿæœªåˆå§‹åŒ–'); return; } this.createConfigurationModal(); } async createConfigurationModal() { // è¿™ä¸ªæ–¹æ³•å°†åœ¨ä¸‹ä¸€æ­¥å®ç°UIç•Œé¢  } } // å…¨å±€å‡½æ•° window.showAPIIntegration = function() { if (window.detectionSystem && window.detectionSystem.apiIntegration) { window.detectionSystem.apiIntegration.show(); } else { console.warn('âš ï¸ APIé›†æˆç³»ç»Ÿæœªåˆå§‹åŒ–'); } }; // å¯¼å‡ºç±» window.APIIntegration = APIIntegration;  