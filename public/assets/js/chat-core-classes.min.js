 class MessageProcessor { constructor() { this.messageHistory = []; this.filters = []; this.processors = new Map(); this.initializeDefaultProcessors();  } initializeDefaultProcessors() { this.processors.set('text', this.processTextMessage.bind(this)); this.processors.set('emoji', this.processEmojiMessage.bind(this)); this.processors.set('link', this.processLinkMessage.bind(this)); this.processors.set('file', this.processFileMessage.bind(this)); } processMessage(message, type = 'text') { try { const timestamp = new Date().toISOString(); const processedMessage = { id: this.generateMessageId(), content: message, type: type, timestamp: timestamp, processed: true }; if (this.processors.has(type)) { processedMessage.content = this.processors.get(type)(message); } this.filters.forEach(filter => { processedMessage.content = filter(processedMessage.content); }); this.messageHistory.push(processedMessage); return processedMessage; } catch (error) { console.error('âŒ æ¶ˆæ¯å¤„ç†å¤±è´¥:', error); return { id: this.generateMessageId(), content: message, type: 'error', timestamp: new Date().toISOString(), error: error.message }; } } processTextMessage(text) { return text.trim() .replace(/\n{3,}/g, '\n\n') .replace(/\s{2,}/g, ' '); } processEmojiMessage(text) { return text.replace(/:\w+:/g, (match) => { const emojiMap = { ':smile:': 'ğŸ˜Š', ':heart:': 'â¤ï¸', ':thumbs_up:': 'ğŸ‘', ':fire:': 'ğŸ”¥' }; return emojiMap[match] || match; }); } processLinkMessage(text) { const urlRegex = /(https?:\/\/[^\s]+)/g; return text.replace(urlRegex, '<a href="$1" target="_blank" rel="noopener">$1</a>'); } processFileMessage(fileInfo) { return { type: 'file', name: fileInfo.name || 'unknown', size: fileInfo.size || 0, url: fileInfo.url || '', processed: true }; } addFilter(filterFn) { if (typeof filterFn === 'function') { this.filters.push(filterFn); } } generateMessageId() { return 'msg_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9); } getMessageHistory(limit = 50) { return this.messageHistory.slice(-limit); } clearHistory() { this.messageHistory = [];  } } class MessageRenderer { constructor(containerElement) { this.container = containerElement; this.templates = new Map(); this.animations = true; this.initializeTemplates();  } initializeTemplates() { this.templates.set('text', this.createTextTemplate.bind(this)); this.templates.set('system', this.createSystemTemplate.bind(this)); this.templates.set('error', this.createErrorTemplate.bind(this)); this.templates.set('file', this.createFileTemplate.bind(this)); } renderMessage(message) { try { const messageElement = this.createMessageElement(message); if (this.container) { this.container.appendChild(messageElement); if (this.animations) { this.animateMessageIn(messageElement); } this.scrollToBottom(); } return messageElement; } catch (error) { console.error('âŒ æ¶ˆæ¯æ¸²æŸ“å¤±è´¥:', error); return this.createErrorMessage('æ¸²æŸ“å¤±è´¥: ' + error.message); } } createMessageElement(message) { const messageDiv = document.createElement('div'); messageDiv.className = `message message-${message.type}`; messageDiv.setAttribute('data-message-id', message.id); const template = this.templates.get(message.type) || this.templates.get('text'); messageDiv.innerHTML = template(message); return messageDiv; } createTextTemplate(message) { return ` <div class="message-content"> <div class="message-text">${this.escapeHtml(message.content)}</div> <div class="message-time">${this.formatTime(message.timestamp)}</div> </div> `; } createSystemTemplate(message) { return ` <div class="message-content system"> <i class="bi bi-info-circle"></i> <span class="message-text">${this.escapeHtml(message.content)}</span> <div class="message-time">${this.formatTime(message.timestamp)}</div> </div> `; } createErrorTemplate(message) { return ` <div class="message-content error"> <i class="bi bi-exclamation-triangle"></i> <span class="message-text">${this.escapeHtml(message.content)}</span> <div class="message-time">${this.formatTime(message.timestamp)}</div> </div> `; } createFileTemplate(message) { const fileInfo = typeof message.content === 'object' ? message.content : { name: message.content }; return ` <div class="message-content file"> <i class="bi bi-file-earmark"></i> <div class="file-info"> <div class="file-name">${this.escapeHtml(fileInfo.name)}</div> <div class="file-size">${this.formatFileSize(fileInfo.size)}</div> </div> <div class="message-time">${this.formatTime(message.timestamp)}</div> </div> `; } createErrorMessage(errorText) { const errorDiv = document.createElement('div'); errorDiv.className = 'message message-error'; errorDiv.innerHTML = this.createErrorTemplate({ content: errorText, timestamp: new Date().toISOString() }); return errorDiv; } animateMessageIn(element) { element.style.opacity = '0'; element.style.transform = 'translateY(20px)'; requestAnimationFrame(() => { element.style.transition = 'all 0.3s ease'; element.style.opacity = '1'; element.style.transform = 'translateY(0)'; }); } scrollToBottom() { if (this.container) { this.container.scrollTop = this.container.scrollHeight; } } clearMessages() { if (this.container) { this.container.innerHTML = ''; } } escapeHtml(text) { const div = document.createElement('div'); div.textContent = text; return div.innerHTML; } formatTime(timestamp) { const date = new Date(timestamp); return date.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' }); } formatFileSize(bytes) { if (!bytes) return 'Unknown size'; const sizes = ['Bytes', 'KB', 'MB', 'GB']; const i = Math.floor(Math.log(bytes) / Math.log(1024)); return Math.round(bytes / Math.pow(1024, i) * 100) / 100 + ' ' + sizes[i]; } } class ChatCore { constructor() { this.processor = new MessageProcessor(); this.renderer = null; this.isInitialized = false; this.eventHandlers = new Map();  } initialize(chatContainer) { try { if (chatContainer) { this.renderer = new MessageRenderer(chatContainer); } this.isInitialized = true; this.emit('initialized');  return true; } catch (error) { console.error('âŒ ChatCore åˆå§‹åŒ–å¤±è´¥:', error); return false; } } sendMessage(content, type = 'text') { if (!this.isInitialized) { console.warn('âš ï¸ ChatCore æœªåˆå§‹åŒ–'); return false; } const processedMessage = this.processor.processMessage(content, type); if (this.renderer) { this.renderer.renderMessage(processedMessage); } this.emit('messageSent', processedMessage); return processedMessage; } receiveMessage(content, type = 'text') { return this.sendMessage(content, type); } on(event, handler) { if (!this.eventHandlers.has(event)) { this.eventHandlers.set(event, []); } this.eventHandlers.get(event).push(handler); } emit(event, data) { if (this.eventHandlers.has(event)) { this.eventHandlers.get(event).forEach(handler => { try { handler(data); } catch (error) { console.error(`âŒ äº‹ä»¶å¤„ç†å™¨é”™è¯¯ (${event}):`, error); } }); } } getMessageHistory() { return this.processor.getMessageHistory(); } clearChat() { this.processor.clearHistory(); if (this.renderer) { this.renderer.clearMessages(); } this.emit('chatCleared'); } isReady() { return this.isInitialized && this.processor && this.renderer; } } window.MessageProcessor = MessageProcessor; window.MessageRenderer = MessageRenderer; window.ChatCore = ChatCore; window.chatInstance = { core: new ChatCore(), processor: new MessageProcessor(), renderer: null, ui: { initialize: function(container) { return window.chatInstance.core.initialize(container); }, sendMessage: function(content, type) { return window.chatInstance.core.sendMessage(content, type); }, clearChat: function() { return window.chatInstance.core.clearChat(); } }, api: { sendRequest: async function(message) { return new Promise((resolve) => { setTimeout(() => { resolve({ success: true, response: `å›å¤: ${message}`, timestamp: new Date().toISOString() }); }, 1000); }); }, getHistory: function() { return window.chatInstance.core.getMessageHistory(); } } };   