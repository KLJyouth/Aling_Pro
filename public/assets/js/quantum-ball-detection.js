 class QuantumBallDetection { constructor() { this.baseURL = window.location.origin; this.apiEndpoints = [ '/api/quantum/status', '/api/quantum/trigger', '/api/quantum/presets', '/api/quantum/animation', '/api/quantum/config', '/api/quantum/sync', '/api/quantum/analytics', '/api/quantum/reset' ]; this.testResults = []; this.websocketConnection = null; this.animationSystem = null; } // ==================== é‡å­çƒAPIæ£€æµ‹ ==================== async testQuantumBallAPI() { if (window.logInfo) window.logInfo('ðŸŒ å¼€å§‹æµ‹è¯•é‡å­çƒAPIæŽ¥å£...'); const results = { passed: 0, failed: 0, details: [] }; for (const endpoint of this.apiEndpoints) { try { const response = await fetch(`${this.baseURL}${endpoint}`, { method: 'GET', headers: { 'Content-Type': 'application/json' } }); const isSuccess = response.ok; const data = await response.json(); results.details.push({ endpoint, status: response.status, success: isSuccess, data: isSuccess ? data : null, error: isSuccess ? null : data.error }); if (isSuccess) { results.passed++; if (window.logSuccess) window.logSuccess(`âœ… ${endpoint} - å“åº”æ­£å¸¸`); } else { results.failed++; if (window.logError) window.logError(`âŒ ${endpoint} - å“åº”å¼‚å¸¸: ${response.status}`); } } catch (error) { results.failed++; results.details.push({ endpoint, status: 'ERROR', success: false, data: null, error: error.message }); if (window.logError) window.logError(`âŒ ${endpoint} - è¯·æ±‚å¤±è´¥: ${error.message}`); } } // æ›´æ–°UIçŠ¶æ€ this.updateTestStatus('quantumBallAPI', results.failed === 0 ? 'success' : 'error'); return results; } // ==================== WebSocketé‡å­åŒæ­¥æ£€æµ‹ ==================== async testQuantumBallWebSocket() { if (window.logInfo) window.logInfo('ðŸ“¡ å¼€å§‹æµ‹è¯•WebSocketé‡å­åŒæ­¥...'); return new Promise((resolve) => { try { const wsURL = `ws://${window.location.host}`; this.websocketConnection = new WebSocket(wsURL); let connectionTested = false; const timeout = setTimeout(() => { if (!connectionTested) { this.updateTestStatus('quantumBallWebSocket', 'error'); if (window.logError) window.logError('âŒ WebSocketè¿žæŽ¥è¶…æ—¶'); resolve({ success: false, error: 'Connection timeout' }); } }, 5000); this.websocketConnection.onopen = () => { connectionTested = true; clearTimeout(timeout); // æµ‹è¯•é‡å­çƒçŠ¶æ€åŒæ­¥ const testMessage = { type: 'quantum_sync', action: 'trigger_animation', animation: 'pulse', data: { intensity: 0.8, duration: 2000 } }; this.websocketConnection.send(JSON.stringify(testMessage)); this.updateTestStatus('quantumBallWebSocket', 'success'); if (window.logSuccess) window.logSuccess('âœ… WebSocketè¿žæŽ¥æˆåŠŸï¼Œé‡å­åŒæ­¥æ­£å¸¸'); resolve({ success: true, message: 'WebSocket connected and quantum sync tested' }); }; this.websocketConnection.onerror = (error) => { connectionTested = true; clearTimeout(timeout); this.updateTestStatus('quantumBallWebSocket', 'error'); if (window.logError) window.logError(`âŒ WebSocketè¿žæŽ¥é”™è¯¯: ${error}`); resolve({ success: false, error: error }); }; this.websocketConnection.onmessage = (event) => { try { const data = JSON.parse(event.data); if (data.type === 'quantum_sync') { if (window.logInfo) window.logInfo(`ðŸ“¡ æ”¶åˆ°é‡å­åŒæ­¥æ¶ˆæ¯: ${data.message}`); } } catch (e) { if (window.logWarning) window.logWarning('âš ï¸ WebSocketæ¶ˆæ¯è§£æžå¤±è´¥'); } }; } catch (error) { this.updateTestStatus('quantumBallWebSocket', 'error'); if (window.logError) window.logError(`âŒ WebSocketåˆå§‹åŒ–å¤±è´¥: ${error.message}`); resolve({ success: false, error: error.message }); } }); } // ==================== 3Dæ¸²æŸ“å¼•æ“Žæ£€æµ‹ ==================== async test3DRenderingEngine() { if (window.logInfo) window.logInfo('ðŸŽ® å¼€å§‹æµ‹è¯•3Dæ¸²æŸ“å¼•æ“Ž...'); const capabilities = { webgl: false, webgl2: false, extensions: [], maxTextureSize: 0, renderer: '', vendor: '' }; try { // æ£€æµ‹WebGLæ”¯æŒ const canvas = document.createElement('canvas'); const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl'); if (gl) { capabilities.webgl = true; capabilities.renderer = gl.getParameter(gl.RENDERER); capabilities.vendor = gl.getParameter(gl.VENDOR); capabilities.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE); // æ£€æµ‹WebGLæ‰©å±• const extensions = gl.getSupportedExtensions(); capabilities.extensions = extensions || []; if (window.logSuccess) window.logSuccess(`âœ… WebGLæ”¯æŒæ­£å¸¸ - ${capabilities.renderer}`); } else { throw new Error('WebGLä¸æ”¯æŒ'); } // æ£€æµ‹WebGL2æ”¯æŒ const gl2 = canvas.getContext('webgl2'); if (gl2) { capabilities.webgl2 = true; if (window.logSuccess) window.logSuccess('âœ… WebGL2æ”¯æŒæ­£å¸¸'); } // æ£€æµ‹Three.jså¯ç”¨æ€§ if (typeof THREE !== 'undefined') { if (window.logSuccess) window.logSuccess('âœ… Three.jsåº“åŠ è½½æ­£å¸¸'); // åˆ›å»ºç®€å•çš„3Dåœºæ™¯æµ‹è¯• const scene = new THREE.Scene(); const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000); const renderer = new THREE.WebGLRenderer({ canvas }); // åˆ›å»ºæµ‹è¯•å‡ ä½•ä½“ const geometry = new THREE.SphereGeometry(1, 32, 32); const material = new THREE.MeshBasicMaterial({ color: 0x667eea }); const sphere = new THREE.Mesh(geometry, material); scene.add(sphere); renderer.render(scene, camera); if (window.logSuccess) window.logSuccess('âœ… 3Dåœºæ™¯æ¸²æŸ“æµ‹è¯•æˆåŠŸ'); } else { if (window.logWarning) window.logWarning('âš ï¸ Three.jsåº“æœªåŠ è½½'); } this.updateTestStatus('quantumBall3DRendering', 'success'); return { success: true, capabilities }; } catch (error) { this.updateTestStatus('quantumBall3DRendering', 'error'); if (window.logError) window.logError(`âŒ 3Dæ¸²æŸ“å¼•æ“Žæ£€æµ‹å¤±è´¥: ${error.message}`); return { success: false, error: error.message, capabilities }; } } // ==================== åŠ¨ç”»ç³»ç»Ÿæµ‹è¯• ==================== async testAnimationSystem() { if (window.logInfo) window.logInfo('ðŸŽ­ å¼€å§‹æµ‹è¯•é‡å­çƒåŠ¨ç”»ç³»ç»Ÿ...'); try { // æµ‹è¯•åŠ¨ç”»é¢„è®¾API const presetsResponse = await fetch(`${this.baseURL}/api/quantum/presets`); const presets = await presetsResponse.json(); if (presets.success && presets.presets) { if (window.logSuccess) window.logSuccess(`âœ… åŠ¨ç”»é¢„è®¾åŠ è½½æˆåŠŸ: ${presets.presets.length}ä¸ªé¢„è®¾`); // æµ‹è¯•æ¯ä¸ªåŠ¨ç”»é¢„è®¾ for (const preset of presets.presets.slice(0, 3)) { // åªæµ‹è¯•å‰3ä¸ª try { const animationResponse = await fetch(`${this.baseURL}/api/quantum/animation`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ animation: preset.name, duration: 1000, intensity: 0.5 }) }); const result = await animationResponse.json(); if (result.success) { if (window.logSuccess) window.logSuccess(`âœ… åŠ¨ç”»é¢„è®¾"${preset.name}"è§¦å‘æˆåŠŸ`); } else { if (window.logWarning) window.logWarning(`âš ï¸ åŠ¨ç”»é¢„è®¾"${preset.name}"è§¦å‘å¤±è´¥`); } } catch (error) { if (window.logError) window.logError(`âŒ åŠ¨ç”»é¢„è®¾"${preset.name}"æµ‹è¯•å¤±è´¥: ${error.message}`); } } } // æµ‹è¯•CSSåŠ¨ç”»æ”¯æŒ const testElement = document.createElement('div'); testElement.style.animation = 'quantumPulse 1s ease-in-out'; document.body.appendChild(testElement); setTimeout(() => { document.body.removeChild(testElement); }, 100); if (window.logSuccess) window.logSuccess('âœ… CSSåŠ¨ç”»æ”¯æŒæ­£å¸¸'); this.updateTestStatus('quantumBallAnimations', 'success'); return { success: true, presets: presets.presets || [] }; } catch (error) { this.updateTestStatus('quantumBallAnimations', 'error'); if (window.logError) window.logError(`âŒ åŠ¨ç”»ç³»ç»Ÿæµ‹è¯•å¤±è´¥: ${error.message}`); return { success: false, error: error.message }; } } // ==================== èŠå¤©é›†æˆæµ‹è¯• ==================== async testChatIntegration() { if (window.logInfo) window.logInfo('ðŸ’¬ å¼€å§‹æµ‹è¯•é‡å­çƒèŠå¤©é›†æˆ...'); try { // æ£€æµ‹QuantumChatIntegrator if (typeof QuantumChatIntegrator !== 'undefined') { if (window.logSuccess) window.logSuccess('âœ… QuantumChatIntegratorç±»å·²åŠ è½½'); // æµ‹è¯•èŠå¤©äº‹ä»¶è§¦å‘ const testEvents = [ { type: 'message_sent', animation: 'pulse' }, { type: 'message_received', animation: 'ripple' }, { type: 'typing_start', animation: 'breathing' }, { type: 'system_notification', animation: 'alert' } ]; for (const event of testEvents) { try { // æ¨¡æ‹ŸèŠå¤©äº‹ä»¶ const response = await fetch(`${this.baseURL}/api/quantum/trigger`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ event: event.type, animation: event.animation, intensity: 0.7 }) }); const result = await response.json(); if (result.success) { if (window.logSuccess) window.logSuccess(`âœ… èŠå¤©äº‹ä»¶"${event.type}"é›†æˆæ­£å¸¸`); } } catch (error) { if (window.logWarning) window.logWarning(`âš ï¸ èŠå¤©äº‹ä»¶"${event.type}"æµ‹è¯•å¤±è´¥`); } } } else { if (window.logWarning) window.logWarning('âš ï¸ QuantumChatIntegratoræœªåŠ è½½'); } this.updateTestStatus('quantumBallChatIntegration', 'success'); return { success: true }; } catch (error) { this.updateTestStatus('quantumBallChatIntegration', 'error'); if (window.logError) window.logError(`âŒ èŠå¤©é›†æˆæµ‹è¯•å¤±è´¥: ${error.message}`); return { success: false, error: error.message }; } } // ==================== æ€§èƒ½ä¼˜åŒ–æ£€æµ‹ ==================== async testPerformanceOptimization() { if (window.logInfo) window.logInfo('âš¡ å¼€å§‹æµ‹è¯•é‡å­çƒæ€§èƒ½ä¼˜åŒ–...'); const metrics = { frameRate: 0, renderTime: 0, memoryUsage: 0, gpuInfo: {}, optimizations: [] }; try { // æ£€æµ‹æ€§èƒ½APIæ”¯æŒ if (performance.now) { const startTime = performance.now(); // æ¨¡æ‹Ÿæ¸²æŸ“è´Ÿè½½ await new Promise(resolve => { let frame = 0; const animate = () => { frame++; if (frame < 60) { requestAnimationFrame(animate); } else { resolve(); } }; animate(); }); const endTime = performance.now(); metrics.renderTime = endTime - startTime; metrics.frameRate = 60000 / metrics.renderTime; if (window.logSuccess) window.logSuccess(`âœ… å¸§çŽ‡æµ‹è¯•å®Œæˆ: ${metrics.frameRate.toFixed(1)} FPS`); } // æ£€æµ‹å†…å­˜ä½¿ç”¨ if (performance.memory) { metrics.memoryUsage = performance.memory.usedJSHeapSize / 1024 / 1024; if (window.logInfo) window.logInfo(`ðŸ“Š å†…å­˜ä½¿ç”¨: ${metrics.memoryUsage.toFixed(2)} MB`); } // æ£€æµ‹WebGLæ€§èƒ½ä¿¡æ¯ const canvas = document.createElement('canvas'); const gl = canvas.getContext('webgl'); if (gl) { const debugInfo = gl.getExtension('WEBGL_debug_renderer_info'); if (debugInfo) { metrics.gpuInfo = { renderer: gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL), vendor: gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) }; if (window.logInfo) window.logInfo(`ðŸŽ® GPUä¿¡æ¯: ${metrics.gpuInfo.renderer}`); } } // æ£€æµ‹ä¼˜åŒ–ç‰¹æ€§ const optimizations = [ { name: 'requestAnimationFrame', supported: typeof requestAnimationFrame !== 'undefined' }, { name: 'WebGL', supported: !!gl }, { name: 'WebGL2', supported: !!canvas.getContext('webgl2') }, { name: 'Hardware Acceleration', supported: gl && gl.getParameter(gl.RENDERER).includes('GPU') } ]; metrics.optimizations = optimizations; optimizations.forEach(opt => { if (opt.supported) { if (window.logSuccess) window.logSuccess(`âœ… ${opt.name} ä¼˜åŒ–æ”¯æŒæ­£å¸¸`); } else { if (window.logWarning) window.logWarning(`âš ï¸ ${opt.name} ä¼˜åŒ–ä¸æ”¯æŒ`); } }); this.updateTestStatus('quantumBallPerformance', 'success'); return { success: true, metrics }; } catch (error) { this.updateTestStatus('quantumBallPerformance', 'error'); if (window.logError) window.logError(`âŒ æ€§èƒ½ä¼˜åŒ–æ£€æµ‹å¤±è´¥: ${error.message}`); return { success: false, error: error.message, metrics }; } } // ==================== ç»¼åˆé‡å­çƒæ£€æµ‹ ==================== async runFullQuantumBallDetection() { if (window.logInfo) window.logInfo('ðŸŒŸ å¼€å§‹é‡å­çƒ3Dç³»ç»Ÿå®Œæ•´æ£€æµ‹...'); const allResults = { timestamp: new Date().toISOString(), totalTests: 6, passedTests: 0, results: {} }; try { // ä¾æ¬¡æ‰§è¡Œæ‰€æœ‰æµ‹è¯• allResults.results.apiTest = await this.testQuantumBallAPI(); if (allResults.results.apiTest.passed > 0) allResults.passedTests++; allResults.results.websocketTest = await this.testQuantumBallWebSocket(); if (allResults.results.websocketTest.success) allResults.passedTests++; allResults.results.renderingTest = await this.test3DRenderingEngine(); if (allResults.results.renderingTest.success) allResults.passedTests++; allResults.results.animationTest = await this.testAnimationSystem(); if (allResults.results.animationTest.success) allResults.passedTests++; allResults.results.chatIntegrationTest = await this.testChatIntegration(); if (allResults.results.chatIntegrationTest.success) allResults.passedTests++; allResults.results.performanceTest = await this.testPerformanceOptimization(); if (allResults.results.performanceTest.success) allResults.passedTests++; // æ›´æ–°æ•´ä½“çŠ¶æ€ const overallSuccess = allResults.passedTests >= 4; // è‡³å°‘4ä¸ªæµ‹è¯•é€šè¿‡ this.updateTestStatus('quantumBallCategory', overallSuccess ? 'success' : 'warning'); if (window.logSuccess) { window.logSuccess(`ðŸŽ¯ é‡å­çƒç³»ç»Ÿæ£€æµ‹å®Œæˆ: ${allResults.passedTests}/${allResults.totalTests} é€šè¿‡`); } return allResults; } catch (error) { this.updateTestStatus('quantumBallCategory', 'error'); if (window.logError) window.logError(`âŒ é‡å­çƒç³»ç»Ÿæ£€æµ‹å¤±è´¥: ${error.message}`); return { success: false, error: error.message }; } } // ==================== å·¥å…·å‡½æ•° ==================== updateTestStatus(testId, status) { const element = document.getElementById(testId); if (element) { // ç§»é™¤æ—§çŠ¶æ€ç±» element.classList.remove('pending', 'running', 'success', 'warning', 'error'); element.classList.add(status); // æ›´æ–°çŠ¶æ€å¾½ç«  const badge = element.querySelector('.status-badge'); if (badge) { badge.classList.remove('status-pending', 'status-running', 'status-success', 'status-warning', 'status-error'); badge.classList.add(`status-${status}`); const statusText = { pending: 'å¾…æ£€æµ‹', running: 'æ£€æµ‹ä¸­', success: 'é€šè¿‡', warning: 'è­¦å‘Š', error: 'å¤±è´¥' }; badge.textContent = statusText[status] || status; } } } // æ¸…ç†èµ„æº cleanup() { if (this.websocketConnection) { this.websocketConnection.close(); this.websocketConnection = null; } } } // å…¨å±€å®žä¾‹ window.quantumBallDetection = new QuantumBallDetection(); // å°†é‡å­çƒæ£€æµ‹é›†æˆåˆ°ä¸»æ£€æµ‹ç³»ç»Ÿ if (window.detectionSystem) { // æ‰©å±•ä¸»æ£€æµ‹ç³»ç»Ÿ const originalRunFullDetection = window.detectionSystem.runFullDetection; if (originalRunFullDetection) { window.detectionSystem.runFullDetection = async function() { await originalRunFullDetection.call(this); // æ·»åŠ é‡å­çƒæ£€æµ‹ if (window.logInfo) window.logInfo('ðŸŒŸ å¯åŠ¨é‡å­çƒ3Dç³»ç»Ÿæ£€æµ‹...'); await window.quantumBallDetection.runFullQuantumBallDetection(); }; } } // å¯¼å‡ºç»™å…¨å±€ä½¿ç”¨ window.runQuantumBallDetection = () => { return window.quantumBallDetection.runFullQuantumBallDetection(); };  