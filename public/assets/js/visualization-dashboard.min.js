class VisualizationDashboard { constructor() { this.charts = new Map(); this.realTimeUpdateInterval = null; this.updateFrequency = 1000; this.maxDataPoints = 50; this.isInitialized = false; this.chartLibraryLoaded = false; this.colorTheme = { primary: '#667eea', secondary: '#764ba2', success: '#10b981', warning: '#f59e0b', error: '#ef4444', info: '#3b82f6', gradient: ['#667eea', '#764ba2', '#f093fb', '#f5576c'], background: 'rgba(102, 126, 234, 0.1)' }; this.initializeChartLibrary(); } async initializeChartLibrary() { try { if (typeof Chart !== 'undefined') { this.chartLibraryLoaded = true; this.setupChartDefaults(); return; } await this.loadChartJS(); this.chartLibraryLoaded = true; this.setupChartDefaults();  } catch (error) { console.error('❌ 加载图表库失败:', error); this.showFallbackMessage(); } } async loadChartJS() { return new Promise((resolve, reject) => { const script = document.createElement('script'); script.src = 'https: script.onload = resolve; script.onerror = reject; document.head.appendChild(script); }); } setupChartDefaults() { if (typeof Chart === 'undefined') return; Chart.defaults.font.family = "'Segoe UI', Tahoma, Geneva, Verdana, sans-serif"; Chart.defaults.font.size = 12; Chart.defaults.color = '#6b7280'; Chart.defaults.plugins.legend.position = 'top'; Chart.defaults.plugins.legend.labels.usePointStyle = true; Chart.defaults.responsive = true; Chart.defaults.maintainAspectRatio = false; } async initialize(detectionSystem) { if (this.isInitialized) return; this.detectionSystem = detectionSystem; while (!this.chartLibraryLoaded) { await this.delay(100); } await this.createDashboardModal(); this.setupEventListeners(); this.isInitialized = true;  } async createDashboardModal() { const modalHTML = ` <div class="modal fade" id="visualizationDashboard" tabindex="-1" aria-hidden="true"> <div class="modal-dialog modal-xl"> <div class="modal-content"> <div class="modal-header bg-gradient text-white"> <h5 class="modal-title"> <i class="bi bi-graph-up"></i> 数据可视化仪表板 </h5> <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button> </div> <div class="modal-body"> ${this.generateDashboardContent()} </div> <div class="modal-footer"> <button type="button" class="btn btn-outline-primary" onclick="visualizationDashboard.exportCharts()"> <i class="bi bi-download"></i> 导出图表 </button> <button type="button" class="btn btn-outline-success" onclick="visualizationDashboard.toggleRealTimeUpdate()"> <i class="bi bi-arrow-clockwise"></i> <span id="realTimeToggleText">启用实时更新</span> </button> <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">关闭</button> </div> </div> </div> </div> `; const existingModal = document.getElementById('visualizationDashboard'); if (existingModal) { existingModal.remove(); } document.body.insertAdjacentHTML('beforeend', modalHTML); } generateDashboardContent() { return ` <div class="container-fluid"> <!-- 仪表板选项卡 --> <ul class="nav nav-tabs mb-3" id="dashboardTabs" role="tablist"> <li class="nav-item" role="presentation"> <button class="nav-link active" id="overview-tab" data-bs-toggle="tab" data-bs-target="#overview-panel" type="button"> <i class="bi bi-speedometer2"></i> 总览 </button> </li> <li class="nav-item" role="presentation"> <button class="nav-link" id="performance-tab" data-bs-toggle="tab" data-bs-target="#performance-panel" type="button"> <i class="bi bi-graph-up"></i> 性能分析 </button> </li> <li class="nav-item" role="presentation"> <button class="nav-link" id="trends-tab" data-bs-toggle="tab" data-bs-target="#trends-panel" type="button"> <i class="bi bi-activity"></i> 趋势分析 </button> </li> <li class="nav-item" role="presentation"> <button class="nav-link" id="realtime-tab" data-bs-toggle="tab" data-bs-target="#realtime-panel" type="button"> <i class="bi bi-broadcast"></i> 实时监控 </button> </li> </ul> <!-- 选项卡内容 --> <div class="tab-content" id="dashboardTabContent"> <!-- 总览面板 --> <div class="tab-pane fade show active" id="overview-panel"> <div class="row"> <div class="col-md-6"> <div class="card h-100"> <div class="card-header"> <i class="bi bi-pie-chart"></i> 测试结果分布 </div> <div class="card-body"> <canvas id="testResultsChart" height="300"></canvas> </div> </div> </div> <div class="col-md-6"> <div class="card h-100"> <div class="card-header"> <i class="bi bi-bar-chart"></i> 类别成功率 </div> <div class="card-body"> <canvas id="categorySuccessChart" height="300"></canvas> </div> </div> </div> </div> <div class="row mt-3"> <div class="col-12"> <div class="card"> <div class="card-header"> <i class="bi bi-clock-history"></i> 最近测试历史 </div> <div class="card-body"> <canvas id="recentHistoryChart" height="200"></canvas> </div> </div> </div> </div> </div> <!-- 性能分析面板 --> <div class="tab-pane fade" id="performance-panel"> <div class="row"> <div class="col-md-8"> <div class="card h-100"> <div class="card-header"> <i class="bi bi-speedometer"></i> 性能基线对比 </div> <div class="card-body"> <canvas id="performanceBaselineChart" height="350"></canvas> </div> </div> </div> <div class="col-md-4"> <div class="card h-100"> <div class="card-header"> <i class="bi bi-stopwatch"></i> 平均执行时间 </div> <div class="card-body"> <canvas id="averageTimeChart" height="350"></canvas> </div> </div> </div> </div> </div> <!-- 趋势分析面板 --> <div class="tab-pane fade" id="trends-panel"> <div class="row"> <div class="col-12"> <div class="card"> <div class="card-header"> <i class="bi bi-graph-up-arrow"></i> 成功率趋势 </div> <div class="card-body"> <canvas id="successRateTrendChart" height="300"></canvas> </div> </div> </div> </div> <div class="row mt-3"> <div class="col-md-6"> <div class="card h-100"> <div class="card-header"> <i class="bi bi-calendar-week"></i> 每日测试次数 </div> <div class="card-body"> <canvas id="dailyTestCountChart" height="250"></canvas> </div> </div> </div> <div class="col-md-6"> <div class="card h-100"> <div class="card-header"> <i class="bi bi-exclamation-triangle"></i> 错误类型分布 </div> <div class="card-body"> <canvas id="errorTypeChart" height="250"></canvas> </div> </div> </div> </div> </div> <!-- 实时监控面板 --> <div class="tab-pane fade" id="realtime-panel"> <div class="row"> <div class="col-md-8"> <div class="card h-100"> <div class="card-header"> <i class="bi bi-activity"></i> 实时性能监控 <span class="badge bg-success ms-2" id="realTimeStatus">离线</span> </div> <div class="card-body"> <canvas id="realTimePerformanceChart" height="300"></canvas> </div> </div> </div> <div class="col-md-4"> <div class="card h-100"> <div class="card-header"> <i class="bi bi-cpu"></i> 系统资源使用 </div> <div class="card-body"> <canvas id="systemResourceChart" height="300"></canvas> </div> </div> </div> </div> <div class="row mt-3"> <div class="col-12"> <div class="card"> <div class="card-header"> <i class="bi bi-lightning"></i> 实时测试状态 </div> <div class="card-body"> <div id="realTimeTestStatus" class="d-flex flex-wrap gap-2"> <!-- 实时状态将在这里显示 --> </div> </div> </div> </div> </div> </div> </div> </div> `; } createTestResultsChart(data) { const ctx = document.getElementById('testResultsChart')?.getContext('2d'); if (!ctx || typeof Chart === 'undefined') return; const chart = new Chart(ctx, { type: 'doughnut', data: { labels: ['成功', '警告', '失败'], datasets: [{ data: [data.passed || 0, data.warning || 0, data.failed || 0], backgroundColor: [this.colorTheme.success, this.colorTheme.warning, this.colorTheme.error], borderWidth: 2, borderColor: '#ffffff' }] }, options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { position: 'bottom' }, tooltip: { callbacks: { afterLabel: (context) => { const total = context.dataset.data.reduce((a, b) => a + b, 0); const percentage = ((context.raw / total) * 100).toFixed(1); return `占比: ${percentage}%`; } } } } } }); this.charts.set('testResults', chart); return chart; } createCategorySuccessChart(data) { const ctx = document.getElementById('categorySuccessChart')?.getContext('2d'); if (!ctx || typeof Chart === 'undefined') return; const chart = new Chart(ctx, { type: 'bar', data: { labels: data.categories || [], datasets: [{ label: '成功率 (%)', data: data.successRates || [], backgroundColor: this.colorTheme.primary, borderColor: this.colorTheme.secondary, borderWidth: 1 }] }, options: { responsive: true, maintainAspectRatio: false, scales: { y: { beginAtZero: true, max: 100, ticks: { callback: function(value) { return value + '%'; } } } }, plugins: { legend: { display: false } } } }); this.charts.set('categorySuccess', chart); return chart; } createRecentHistoryChart(data) { const ctx = document.getElementById('recentHistoryChart')?.getContext('2d'); if (!ctx || typeof Chart === 'undefined') return; const chart = new Chart(ctx, { type: 'line', data: { labels: data.timestamps || [], datasets: [{ label: '成功率', data: data.successRates || [], borderColor: this.colorTheme.success, backgroundColor: 'rgba(16, 185, 129, 0.1)', fill: true, tension: 0.4 }, { label: '测试数量', data: data.testCounts || [], borderColor: this.colorTheme.info, backgroundColor: 'rgba(59, 130, 246, 0.1)', fill: false, yAxisID: 'y1' }] }, options: { responsive: true, maintainAspectRatio: false, scales: { y: { type: 'linear', display: true, position: 'left', max: 100, ticks: { callback: function(value) { return value + '%'; } } }, y1: { type: 'linear', display: true, position: 'right', grid: { drawOnChartArea: false, } } } } }); this.charts.set('recentHistory', chart); return chart; } createPerformanceBaselineChart(data) { const ctx = document.getElementById('performanceBaselineChart')?.getContext('2d'); if (!ctx || typeof Chart === 'undefined') return; const chart = new Chart(ctx, { type: 'radar', data: { labels: data.categories || [], datasets: [{ label: '当前性能', data: data.currentPerformance || [], borderColor: this.colorTheme.primary, backgroundColor: 'rgba(102, 126, 234, 0.2)', pointBackgroundColor: this.colorTheme.primary }, { label: '基线性能', data: data.baselinePerformance || [], borderColor: this.colorTheme.warning, backgroundColor: 'rgba(245, 158, 11, 0.2)', pointBackgroundColor: this.colorTheme.warning }] }, options: { responsive: true, maintainAspectRatio: false, elements: { line: { borderWidth: 3 } }, scales: { r: { angleLines: { display: false }, suggestedMin: 0, suggestedMax: 100 } } } }); this.charts.set('performanceBaseline', chart); return chart; } toggleRealTimeUpdate() { if (this.realTimeUpdateInterval) { this.stopRealTimeUpdate(); } else { this.startRealTimeUpdate(); } } startRealTimeUpdate() { if (this.realTimeUpdateInterval) return; this.realTimeUpdateInterval = setInterval(() => { this.updateRealTimeCharts(); }, this.updateFrequency); const statusBadge = document.getElementById('realTimeStatus'); const toggleText = document.getElementById('realTimeToggleText'); if (statusBadge) { statusBadge.textContent = '在线'; statusBadge.className = 'badge bg-success ms-2'; } if (toggleText) { toggleText.textContent = '停止实时更新'; }  } stopRealTimeUpdate() { if (this.realTimeUpdateInterval) { clearInterval(this.realTimeUpdateInterval); this.realTimeUpdateInterval = null; } const statusBadge = document.getElementById('realTimeStatus'); const toggleText = document.getElementById('realTimeToggleText'); if (statusBadge) { statusBadge.textContent = '离线'; statusBadge.className = 'badge bg-secondary ms-2'; } if (toggleText) { toggleText.textContent = '启用实时更新'; }  } updateRealTimeCharts() { if (!this.detectionSystem) return; this.updateRealTimePerformanceChart(); this.updateSystemResourceChart(); this.updateRealTimeTestStatus(); } updateRealTimePerformanceChart() { const chart = this.charts.get('realTimePerformance'); if (!chart) return; const realtimeData = this.detectionSystem.getRealtimeData(); const now = new Date(); chart.data.labels.push(now.toLocaleTimeString()); chart.data.datasets[0].data.push(realtimeData.progress || 0); if (chart.data.labels.length > 20) { chart.data.labels.shift(); chart.data.datasets[0].data.shift(); } chart.update('none'); } updateSystemResourceChart() { const chart = this.charts.get('systemResource'); if (!chart) return; const realtimeData = this.detectionSystem.getRealtimeData(); const metrics = realtimeData.systemMetrics || {}; const memoryUsage = metrics.memoryUsage ? (metrics.memoryUsage.usedJSHeapSize / metrics.memoryUsage.totalJSHeapSize * 100) : 0; chart.data.datasets[0].data = [ memoryUsage, Math.random() * 30 + 20, realtimeData.isRunning ? 80 : 20, Math.random() * 40 + 10 ]; chart.update('none'); } updateRealTimeTestStatus() { const statusContainer = document.getElementById('realTimeTestStatus'); if (!statusContainer) return; const realtimeData = this.detectionSystem.getRealtimeData(); const recentTests = realtimeData.recentTests || []; statusContainer.innerHTML = recentTests.map(test => { const statusClass = { 'success': 'bg-success', 'warning': 'bg-warning', 'error': 'bg-danger' }[test.status] || 'bg-secondary'; return ` <span class="badge ${statusClass} me-2 mb-1"> ${test.testName || 'Unknown'}: ${test.status} <small>(${test.duration}ms)</small> </span> `; }).join(''); } generateChartData() { if (!this.detectionSystem) return {}; const history = this.detectionSystem.testHistory || []; const results = this.detectionSystem.testResults || new Map(); const categories = this.detectionSystem.testCategories || {}; return { testResults: this.generateTestResultsData(results), categorySuccess: this.generateCategorySuccessData(categories, history), recentHistory: this.generateRecentHistoryData(history), performanceBaseline: this.generatePerformanceBaselineData(), trends: this.generateTrendsData(history) }; } generateTestResultsData(results) { let passed = 0, warning = 0, failed = 0; for (const [key, result] of results) { switch (result.status) { case 'success': passed++; break; case 'warning': warning++; break; case 'error': failed++; break; } } return { passed, warning, failed }; } generateCategorySuccessData(categories, history) { const categoryStats = {}; Object.keys(categories).forEach(category => { categoryStats[category] = { total: 0, success: 0 }; }); history.forEach(record => { if (categoryStats[record.category]) { categoryStats[record.category].total++; if (record.status === 'success') { categoryStats[record.category].success++; } } }); const categoryNames = Object.keys(categoryStats); const successRates = categoryNames.map(name => { const stats = categoryStats[name]; return stats.total > 0 ? (stats.success / stats.total * 100).toFixed(1) : 0; }); return { categories: categoryNames, successRates: successRates }; } generateRecentHistoryData(history) { const recent = history.slice(-20); const timestamps = recent.map(record => { const date = new Date(record.timestamp); return date.toLocaleTimeString(); }); const successRates = recent.map((_, index) => { const subset = recent.slice(0, index + 1); const success = subset.filter(r => r.status === 'success').length; return subset.length > 0 ? (success / subset.length * 100).toFixed(1) : 0; }); const testCounts = recent.map((_, index) => index + 1); return { timestamps, successRates, testCounts }; } show() { if (!this.isInitialized) { console.warn('⚠️ 可视化仪表板未初始化'); return; } const modal = new bootstrap.Modal(document.getElementById('visualizationDashboard')); modal.show(); setTimeout(() => { this.refreshAllCharts(); }, 300); } refreshAllCharts() { const data = this.generateChartData(); this.createTestResultsChart(data.testResults); this.createCategorySuccessChart(data.categorySuccess); this.createRecentHistoryChart(data.recentHistory); this.createPerformanceBaselineChart(data.performanceBaseline); } setupEventListeners() { const tabButtons = document.querySelectorAll('#dashboardTabs button[data-bs-toggle="tab"]'); tabButtons.forEach(button => { button.addEventListener('shown.bs.tab', (event) => { const targetTab = event.target.getAttribute('data-bs-target'); setTimeout(() => { this.onTabSwitch(targetTab); }, 100); }); }); } onTabSwitch(targetTab) { switch (targetTab) { case '#performance-panel': this.refreshPerformanceCharts(); break; case '#trends-panel': this.refreshTrendsCharts(); break; case '#realtime-panel': this.refreshRealTimeCharts(); break; } } exportCharts() { const exportData = { timestamp: new Date().toISOString(), charts: {} }; this.charts.forEach((chart, name) => { exportData.charts[name] = { type: chart.config.type, data: chart.data, options: chart.options }; }); const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = `visualization-dashboard-${Date.now()}.json`; a.click(); URL.revokeObjectURL(url);  } showFallbackMessage() { const fallbackHTML = ` <div class="alert alert-warning" role="alert"> <i class="bi bi-exclamation-triangle"></i> <strong>图表库加载失败</strong><br> 数据可视化功能需要Chart.js库支持。请检查网络连接或使用文本形式的数据报告。 </div> `; document.body.insertAdjacentHTML('beforeend', fallbackHTML); } delay(ms) { return new Promise(resolve => setTimeout(resolve, ms)); } refreshPerformanceCharts() {  if (!this.detectionSystem) return; const dashboardData = this.detectionSystem.getDashboardData(); const performanceData = dashboardData.performance; const baselineChart = this.charts.get('performanceBaseline'); if (baselineChart && performanceData.baseline) { const categories = Object.keys(performanceData.baseline); const currentPerformance = categories.map(cat => { const baseline = performanceData.baseline[cat]; return baseline.averageTime || 0; }); const baselinePerformance = categories.map(cat => { const baseline = performanceData.baseline[cat]; return baseline.bestTime || 0; }); baselineChart.data.labels = categories; baselineChart.data.datasets[0].data = currentPerformance; baselineChart.data.datasets[1].data = baselinePerformance; baselineChart.update(); } } refreshTrendsCharts() {  if (!this.detectionSystem) return; const dashboardData = this.detectionSystem.getDashboardData(); const trendsData = dashboardData.trends; const historyChart = this.charts.get('recentHistory'); if (historyChart && trendsData) { historyChart.data.labels = trendsData.timestamps; historyChart.data.datasets[0].data = trendsData.successRates; historyChart.data.datasets[1].data = trendsData.testCounts; historyChart.update(); } } processOverviewData(overviewData) { return { testResults: { passed: overviewData.passed || 0, failed: overviewData.failed || 0, warning: overviewData.warning || 0, pending: (overviewData.total || 0) - (overviewData.completed || 0) }, categoryStats: overviewData.categoryStats || {}, successRate: parseFloat(overviewData.successRate) || 0 }; } processPerformanceData(performanceData) { const baseline = performanceData.baseline || {}; const categories = Object.keys(baseline); return { categories: categories, currentPerformance: categories.map(cat => { const data = baseline[cat]; return data && data.averageTime ? Math.min(data.averageTime / 10, 100) : 0; }), baselinePerformance: categories.map(cat => { const data = baseline[cat]; return data && data.bestTime ? Math.min(data.bestTime / 10, 100) : 0; }), recentPerformance: performanceData.recentPerformance || [] }; } processTrendsData(trendsData) { return { timestamps: trendsData.timestamps || [], successRates: trendsData.successRates || [], testCounts: trendsData.testCounts || [], avgDuration: trendsData.avgDuration || [] }; } processRealtimeData(realtimeData) { return { timestamp: realtimeData.timestamp || Date.now(), isRunning: realtimeData.isRunning || false, progress: realtimeData.currentProgress || 0, systemMetrics: realtimeData.systemMetrics || {}, recentTests: realtimeData.recentTests || [] }; } refreshRealTimeCharts() {  } updateRealTimePerformanceChart() { } updateSystemResourceChart() { } updateRealTimeTestStatus() { } generatePerformanceBaselineData() { return { categories: ['后端', '前端', 'WebSocket', '聊天', '性能'], currentPerformance: [85, 92, 78, 90, 88], baselinePerformance: [80, 85, 75, 85, 85] }; } generateTrendsData(history) { return {}; } } window.visualizationDashboard = new VisualizationDashboard(); window.showVisualizationDashboard = function() { if (window.detectionSystem && window.visualizationDashboard) { if (!visualizationDashboard.isInitialized) { visualizationDashboard.initialize(window.detectionSystem).then(() => { visualizationDashboard.show(); }); } else { visualizationDashboard.show(); } } else { console.warn('⚠️ 检测系统或可视化仪表板未就绪'); } }; 