class AlingDataManager{constructor(options={}){this.options={apiBaseUrl: '/api',enableCache: true,cacheExpiration: 5*60*1000,enablePersistence: true,storagePrefix: 'aling_data_',enableOfflineSync: true,retryAttempts: 3,retryDelay: 1000,enableValidation: true,...options};this.stores=new Map();this.cache=new Map();this.observers=new Map();this.validators=new Map();this.api=new APIManager(this.options);this.syncQueue=[];this.isOnline=navigator.onLine;this.init();}init(){this.setupNetworkListener();this.loadPersistedData();this.processSyncQueue();}createStore(name,initialState={},options={}){const store=new DataStore(name,initialState,{...this.options,...options,dataManager: this});this.stores.set(name,store);if(this.options.enablePersistence){this.restoreStore(name);}return store;}getStore(name){return this.stores.get(name);}removeStore(name){const store=this.stores.get(name);if(store){store.destroy();this.stores.delete(name);if(this.options.enablePersistence){this.clearPersistedStore(name);}}}setupNetworkListener(){window.addEventListener('online',()=>{this.isOnline=true;this.processSyncQueue();this.emit('network:online');});window.addEventListener('offline',()=>{this.isOnline=false;this.emit('network:offline');});}loadPersistedData(){if(!this.options.enablePersistence)return;try{const keys=Object.keys(localStorage);keys.forEach(key=>{if(key.startsWith(this.options.storagePrefix)){const storeName=key.replace(this.options.storagePrefix,'');this.restoreStore(storeName);}});}catch(error){console.warn('加载持久化数据失败:',error);}}restoreStore(name){try{const key=this.options.storagePrefix+name;const data=localStorage.getItem(key);if(data){const parsed=JSON.parse(data);const store=this.stores.get(name);if(store && parsed.timestamp){const now=Date.now();if(now-parsed.timestamp < this.options.cacheExpiration){store.setState(parsed.state,{silent: true});}}}}catch(error){console.warn(`恢复存储 ${name}失败:`,error);}}persistStore(name,state){if(!this.options.enablePersistence)return;try{const key=this.options.storagePrefix+name;const data={state,timestamp: Date.now()};localStorage.setItem(key,JSON.stringify(data));}catch(error){console.warn(`持久化存储 ${name}失败:`,error);}}clearPersistedStore(name){try{const key=this.options.storagePrefix+name;localStorage.removeItem(key);}catch(error){console.warn(`清除持久化存储 ${name}失败:`,error);}}async processSyncQueue(){if(!this.isOnline || this.syncQueue.length===0)return;const queue=[...this.syncQueue];this.syncQueue=[];for(const operation of queue){try{await this.executeOperation(operation);this.emit('sync:success',{operation});}catch(error){console.error('同步操作失败:',error);this.syncQueue.push(operation);this.emit('sync:error',{operation,error});}}}async executeOperation(operation){const{type,endpoint,data,options={}}=operation;switch(type){case 'GET': return await this.api.get(endpoint,options);case 'POST': return await this.api.post(endpoint,data,options);case 'PUT': return await this.api.put(endpoint,data,options);case 'DELETE': return await this.api.delete(endpoint,options);default: throw new Error(`未知操作类型: ${type}`);}}addToSyncQueue(operation){if(this.options.enableOfflineSync){this.syncQueue.push({...operation,timestamp: Date.now()});}}registerValidator(name,validator){this.validators.set(name,validator);}validateData(validatorName,data){const validator=this.validators.get(validatorName);if(!validator){throw new Error(`验证器 ${validatorName}不存在`);}return validator(data);}setCache(key,data,ttl=this.options.cacheExpiration){this.cache.set(key,{data,timestamp: Date.now(),ttl});}getCache(key){const cached=this.cache.get(key);if(!cached)return null;const now=Date.now();if(now-cached.timestamp > cached.ttl){this.cache.delete(key);return null;}return cached.data;}clearCache(key=null){if(key){this.cache.delete(key);}else{this.cache.clear();}}emit(eventName,data){const event=new CustomEvent(`data:${eventName}`,{detail: data});document.dispatchEvent(event);}destroy(){this.stores.forEach(store=> store.destroy());this.stores.clear();this.cache.clear();this.observers.clear();this.validators.clear();this.syncQueue=[];}}class DataStore{constructor(name,initialState={},options={}){this.name=name;this.state={...initialState};this.options=options;this.observers=new Map();this.computed=new Map();this.mutations=new Map();this.actions=new Map();this.getters=new Map();this.isLoading=false;this.errors=new Map();this.setupReactivity();}setupReactivity(){this.proxy=new Proxy(this.state,{set:(target,property,value)=>{const oldValue=target[property];target[property]=value;this.notifyObservers(property,value,oldValue);if(this.options.dataManager){this.options.dataManager.persistStore(this.name,this.state);}return true;},get:(target,property)=>{if(this.computed.has(property)){return this.computed.get(property)();}if(this.getters.has(property)){return this.getters.get(property)(this.state);}return target[property];}});}getState(key=null){if(key){return this.proxy[key];}return{...this.state};}setState(keyOrState,value=null,options={}){if(typeof keyOrState==='object'){Object.entries(keyOrState).forEach(([key,val])=>{this.proxy[key]=val;});}else{this.proxy[keyOrState]=value;}if(!options.silent){this.emit('state:changed',{store: this.name,state: this.getState()});}}updateState(key,updater){const currentValue=this.proxy[key];const newValue=updater(currentValue);this.setState(key,newValue);}observe(keyOrObserver,observer=null){if(typeof keyOrObserver==='function'){const id=Symbol('observer');this.observers.set(id,{key: '*',callback: keyOrObserver});return id;}else{const id=Symbol('observer');this.observers.set(id,{key: keyOrObserver,callback: observer});return id;}}unobserve(observerId){this.observers.delete(observerId);}notifyObservers(key,newValue,oldValue){this.observers.forEach(observer=>{if(observer.key==='*' || observer.key===key){try{observer.callback(newValue,oldValue,key);}catch(error){console.error('观察者回调执行失败:',error);}}});}defineComputed(name,computed){this.computed.set(name,()=> computed(this.state));}defineGetter(name,getter){this.getters.set(name,getter);}defineMutation(name,mutation){this.mutations.set(name,mutation);}commit(name,payload){const mutation=this.mutations.get(name);if(!mutation){throw new Error(`Mutation ${name}不存在`);}mutation(this.state,payload);this.emit('mutation:committed',{name,payload});}defineAction(name,action){this.actions.set(name,action);}async dispatch(name,payload){const action=this.actions.get(name);if(!action){throw new Error(`Action ${name}不存在`);}this.setLoading(name,true);this.clearError(name);try{const context={state: this.state,commit: this.commit.bind(this),dispatch: this.dispatch.bind(this),getters: this.getters};const result=await action(context,payload);this.emit('action:dispatched',{name,payload,result});return result;}catch(error){this.setError(name,error);this.emit('action:error',{name,payload,error});throw error;}finally{this.setLoading(name,false);}}setLoading(action,loading){if(loading){this.isLoading=true;}else{this.isLoading=Array.from(this.errors.keys()).some(key=> key.endsWith('_loading')&& this.errors.get(key));}this.errors.set(`${action}_loading`,loading);this.emit('loading:changed',{action,loading});}setError(action,error){this.errors.set(action,error);this.emit('error:set',{action,error});}clearError(action){this.errors.delete(action);this.emit('error:cleared',{action});}getError(action){return this.errors.get(action);}reset(){Object.keys(this.state).forEach(key=>{delete this.state[key];});this.errors.clear();this.isLoading=false;this.emit('state:reset');}emit(eventName,data){const event=new CustomEvent(`store:${eventName}`,{detail:{store: this.name,...data}});document.dispatchEvent(event);}destroy(){this.observers.clear();this.computed.clear();this.mutations.clear();this.actions.clear();this.getters.clear();this.errors.clear();}}class APIManager{constructor(options={}){this.options=options;this.interceptors={request: [],response: []};}addRequestInterceptor(interceptor){this.interceptors.request.push(interceptor);}addResponseInterceptor(interceptor){this.interceptors.response.push(interceptor);}async request(url,options={}){let config={url,...options};for(const interceptor of this.interceptors.request){config=await interceptor(config);}try{let response=await fetch(config.url,config);for(const interceptor of this.interceptors.response){response=await interceptor(response);}return response;}catch(error){if(!navigator.onLine && this.options.dataManager){this.options.dataManager.addToSyncQueue({type: options.method || 'GET',endpoint: url,data: options.body,options});}throw error;}}async get(url,options={}){return this.request(url,{method: 'GET',...options});}async post(url,data,options={}){return this.request(url,{method: 'POST',headers:{'Content-Type': 'application/json',...options.headers},body: JSON.stringify(data),...options});}async put(url,data,options={}){return this.request(url,{method: 'PUT',headers:{'Content-Type': 'application/json',...options.headers},body: JSON.stringify(data),...options});}async delete(url,options={}){return this.request(url,{method: 'DELETE',...options});}}window.AlingDataManager=AlingDataManager;window.DataStore=DataStore;window.APIManager=APIManager;window.dataManager=new AlingDataManager();