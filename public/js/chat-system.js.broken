/**
 * AlingAi Pro - èŠå¤©ç³»ç»Ÿæ¨¡å—
 * é«˜çº§èŠå¤©åŠŸèƒ½é›†æˆï¼Œæ”¯æŒå®æ—¶é€šä¿¡ã€å¤šæ¨¡æ€äº¤äº’å’Œæ™ºèƒ½å“åº”
 * 
 * @version 1.0.0
 * @author AlingAi Team
 * @created 2024-12-19
 */

class ChatSystem {
    constructor(options = {}) {
        this.options = {
            apiEndpoint: '/api/chat',
            maxRetries: 3,
            retryDelay: 1000,
            enableTyping: true,
            enableVoice: false,
            enableQuantumEffects: true,
            autoSave: true,
            maxHistorySize: 1000,
            ...options
        };

        // APIç«¯ç‚¹é…ç½®
        this.apiEndpoints = {
            chat: '/api/v1/chat/messages',
            sessions: '/api/v1/chat/sessions',
            auth: '/api/v1/auth/check',
            preferences: '/api/v1/user/preferences'
        };

        this.state = {
            isInitialized: false,
            isConnected: false,
            isTyping: false,
            currentConversationId: null,
            messageQueue: [],
            retryCount: 0,
            isAuthenticated: false,
            currentUser: null
        };

        this.conversations = new Map();
        this.currentMessages = [];
        this.eventListeners = new Map();
        this.wsConnection = null;
        this.quantumIntegrator = null;

        this.init();
    }

    /**
     * åˆå§‹åŒ–èŠå¤©ç³»ç»Ÿ
     */    async init() {
        try {
            console.log('ğŸš€ åˆå§‹åŒ–èŠå¤©ç³»ç»Ÿ...');
            
            await this.checkAuthentication();
            await this.setupDOM();
            await this.setupEventListeners();
            await this.loadSettings();
            await this.loadConversationHistory();
            await this.initWebSocket();
            await this.initQuantumIntegration();
            
            this.state.isInitialized = true;
            this.emit('initialized');
            
            console.log('âœ… èŠå¤©ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ');
        } catch (error) {
            console.error('âŒ èŠå¤©ç³»ç»Ÿåˆå§‹åŒ–å¤±è´¥:', error);
            this.emit('error', { type: 'initialization', error });
        }
    }

    /**
     * æ£€æŸ¥ç”¨æˆ·è®¤è¯çŠ¶æ€
     */
    async checkAuthentication() {
        try {
            const response = await fetch(this.apiEndpoints.auth, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json',
                    'X-Requested-With': 'XMLHttpRequest'
                }
            });
            
            if (response.ok) {
                const result = await response.json();
                this.state.isAuthenticated = result.success && result.data?.authenticated;
                if (this.state.isAuthenticated && result.data?.user) {
                    this.state.currentUser = result.data.user;
                }
            } else {
                this.state.isAuthenticated = false;
            }
        } catch (error) {
            console.warn('è®¤è¯æ£€æŸ¥å¤±è´¥:', error);
            this.state.isAuthenticated = false;
        }
        
        return this.state.isAuthenticated;
    }

    /**
     * è®¾ç½®DOMå…ƒç´ 
     */
    async setupDOM() {
        // ç¡®ä¿èŠå¤©å®¹å™¨å­˜åœ¨
        if (!document.getElementById('chat-container')) {
            const chatContainer = document.createElement('div');
            chatContainer.id = 'chat-container';
            chatContainer.className = 'chat-container';
            chatContainer.innerHTML = this.generateChatHTML();
            document.body.appendChild(chatContainer);
        }

        // ç¼“å­˜DOMå…ƒç´ 
        this.elements = {
            container: document.getElementById('chat-container'),
            messagesList: document.getElementById('messages-list'),
            messageInput: document.getElementById('message-input'),
            sendButton: document.getElementById('send-button'),
            voiceButton: document.getElementById('voice-button'),
            settingsButton: document.getElementById('settings-button'),
            newChatButton: document.getElementById('new-chat-button'),
            conversationsList: document.getElementById('conversations-list'),
            typingIndicator: document.getElementById('typing-indicator'),
            statusIndicator: document.getElementById('status-indicator')
        };

        // è®¾ç½®åˆå§‹çŠ¶æ€
        this.updateConnectionStatus(false);
    }

    /**
     * ç”ŸæˆèŠå¤©ç•Œé¢HTML
     */
    generateChatHTML() {
        return `
            <div class="chat-header">
                <div class="chat-title">
                    <h3>AlingAi æ™ºèƒ½åŠ©æ‰‹</h3>
                    <div id="status-indicator" class="status-indicator offline">
                        <span class="status-dot"></span>
                        <span class="status-text">ç¦»çº¿</span>
                    </div>
                </div>
                <div class="chat-controls">
                    <button id="new-chat-button" class="btn btn-sm btn-outline" title="æ–°å»ºå¯¹è¯">
                        <i class="fas fa-plus"></i>
                    </button>
                    <button id="settings-button" class="btn btn-sm btn-outline" title="è®¾ç½®">
                        <i class="fas fa-cog"></i>
                    </button>
                    <button id="minimize-chat" class="btn btn-sm btn-outline" title="æœ€å°åŒ–">
                        <i class="fas fa-minus"></i>
                    </button>
                </div>
            </div>
            
            <div class="chat-body">
                <div class="chat-sidebar">
                    <div class="conversations-header">
                        <h4>å¯¹è¯å†å²</h4>
                        <div class="conversations-search">
                            <input type="text" id="conversations-search" placeholder="æœç´¢å¯¹è¯..." />
                        </div>
                    </div>
                    <div id="conversations-list" class="conversations-list"></div>
                </div>
                
                <div class="chat-main">
                    <div id="messages-list" class="messages-list">
                        <div class="welcome-message">
                            <div class="quantum-avatar">
                                <div class="quantum-particles"></div>
                            </div>
                            <h4>æ¬¢è¿ä½¿ç”¨ AlingAi Pro</h4>
                            <p>æˆ‘æ˜¯æ‚¨çš„æ™ºèƒ½åŠ©æ‰‹ï¼Œå¯ä»¥å¸®åŠ©æ‚¨å¤„ç†å„ç§ä»»åŠ¡ã€‚æ‚¨å¯ä»¥ï¼š</p>
                            <ul>
                                <li>è¯¢é—®æŠ€æœ¯é—®é¢˜</li>
                                <li>è¯·æ±‚ä»£ç å¸®åŠ©</li>
                                <li>è·å–å®æ—¶ä¿¡æ¯</li>
                                <li>è¿›è¡Œåˆ›æ„è®¨è®º</li>
                            </ul>
                        </div>
                    </div>
                    
                    <div id="typing-indicator" class="typing-indicator" style="display: none;">
                        <div class="typing-dots">
                            <span></span>
                            <span></span>
                            <span></span>
                        </div>
                        <span class="typing-text">AIæ­£åœ¨æ€è€ƒ...</span>
                    </div>
                    
                    <div class="chat-input-container">
                        <div class="quick-actions">
                            <button class="quick-action" data-action="explain" title="è§£é‡Šæ¦‚å¿µ">
                                <i class="fas fa-lightbulb"></i>
                            </button>
                            <button class="quick-action" data-action="code" title="ç¼–ç¨‹å¸®åŠ©">
                                <i class="fas fa-code"></i>
                            </button>
                            <button class="quick-action" data-action="translate" title="ç¿»è¯‘">
                                <i class="fas fa-language"></i>
                            </button>
                            <button class="quick-action" data-action="summarize" title="æ€»ç»“">
                                <i class="fas fa-compress-alt"></i>
                            </button>
                        </div>
                        
                        <div class="input-container">
                            <textarea 
                                id="message-input" 
                                class="message-input" 
                                placeholder="è¾“å…¥æ‚¨çš„æ¶ˆæ¯... (Shift+Enter æ¢è¡Œï¼ŒEnter å‘é€)"
                                rows="1"
                                maxlength="4000"
                            ></textarea>
                            
                            <div class="input-actions">
                                <button id="voice-button" class="btn btn-sm btn-ghost" title="è¯­éŸ³è¾“å…¥" disabled>
                                    <i class="fas fa-microphone"></i>
                                </button>
                                <button id="attach-button" class="btn btn-sm btn-ghost" title="é™„ä»¶">
                                    <i class="fas fa-paperclip"></i>
                                </button>
                                <button id="send-button" class="btn btn-sm btn-primary" title="å‘é€" disabled>
                                    <i class="fas fa-paper-plane"></i>
                                </button>
                            </div>
                        </div>
                        
                        <div class="input-footer">
                            <div class="character-count">
                                <span id="char-count">0</span>/4000
                            </div>
                            <div class="input-hints">
                                æ”¯æŒ Markdown æ ¼å¼ â€¢ 
                                <a href="#" id="shortcuts-help">å¿«æ·é”®</a>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        `;
    }

    /**
     * è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
     */
    async setupEventListeners() {
        // æ¶ˆæ¯è¾“å…¥äº‹ä»¶
        this.elements.messageInput?.addEventListener('input', (e) => {
            this.handleInputChange(e);
        });

        this.elements.messageInput?.addEventListener('keydown', (e) => {
            this.handleKeydown(e);
        });

        // å‘é€æŒ‰é’®
        this.elements.sendButton?.addEventListener('click', () => {
            this.sendMessage();
        });

        // æ–°å»ºå¯¹è¯
        this.elements.newChatButton?.addEventListener('click', () => {
            this.createNewConversation();
        });

        // è¯­éŸ³æŒ‰é’®
        this.elements.voiceButton?.addEventListener('click', () => {
            this.toggleVoiceInput();
        });

        // å¿«æ·æ“ä½œ
        document.querySelectorAll('.quick-action').forEach(button => {
            button.addEventListener('click', (e) => {
                const action = e.currentTarget.dataset.action;
                this.handleQuickAction(action);
            });
        });

        // å¯¹è¯æœç´¢
        const searchInput = document.getElementById('conversations-search');
        searchInput?.addEventListener('input', (e) => {
            this.filterConversations(e.target.value);
        });

        // çª—å£äº‹ä»¶
        window.addEventListener('beforeunload', () => {
            this.cleanup();
        });

        // é¡µé¢å¯è§æ€§å˜åŒ–
        document.addEventListener('visibilitychange', () => {
            this.handleVisibilityChange();
        });
    }

    /**
     * å¤„ç†è¾“å…¥å˜åŒ–
     */
    handleInputChange(event) {
        const input = event.target;
        const text = input.value;
        
        // æ›´æ–°å­—ç¬¦è®¡æ•°
        const charCount = document.getElementById('char-count');
        if (charCount) {
            charCount.textContent = text.length;
        }

        // è‡ªåŠ¨è°ƒæ•´é«˜åº¦
        this.adjustTextareaHeight(input);

        // æ›´æ–°å‘é€æŒ‰é’®çŠ¶æ€
        const sendButton = this.elements.sendButton;
        if (sendButton) {
            sendButton.disabled = !text.trim();
        }

        // å‘é€æ‰“å­—æŒ‡ç¤º
        if (this.options.enableTyping && text.trim()) {
            this.sendTypingIndicator();
        }
    }

    /**
     * å¤„ç†é”®ç›˜äº‹ä»¶
     */
    handleKeydown(event) {
        if (event.key === 'Enter') {
            if (event.shiftKey) {
                // Shift+Enter æ¢è¡Œ
                return;
            } else {
                // Enter å‘é€æ¶ˆæ¯
                event.preventDefault();
                this.sendMessage();
            }
        } else if (event.key === 'Escape') {
            // ESC æ¸…ç©ºè¾“å…¥
            this.clearInput();
        } else if (event.ctrlKey || event.metaKey) {
            // Ctrl/Cmd å¿«æ·é”®
            this.handleCtrlShortcuts(event);
        }
    }

    /**
     * å¤„ç†å¿«æ·é”®
     */
    handleCtrlShortcuts(event) {
        switch (event.key) {
            case 'n':
                event.preventDefault();
                this.createNewConversation();
                break;
            case 'k':
                event.preventDefault();
                this.focusConversationSearch();
                break;
            case '/':
                event.preventDefault();
                this.showShortcutsHelp();
                break;
        }
    }

    /**
     * å‘é€æ¶ˆæ¯
     */
    async sendMessage(text = null) {
        try {
            const messageText = text || this.elements.messageInput?.value?.trim();
            
            if (!messageText) {
                return;
            }

            // æ·»åŠ ç”¨æˆ·æ¶ˆæ¯åˆ°ç•Œé¢
            const userMessage = this.addMessage({
                id: this.generateMessageId(),
                type: 'user',
                content: messageText,
                timestamp: new Date().toISOString()
            });

            // æ¸…ç©ºè¾“å…¥æ¡†
            if (!text) {
                this.clearInput();
            }

            // æ˜¾ç¤ºæ‰“å­—æŒ‡ç¤ºå™¨
            this.showTypingIndicator();

            // è§¦å‘é‡å­æ•ˆæœ
            this.triggerQuantumEffect('user_message', { message: messageText });

            // å‘é€åˆ°æœåŠ¡å™¨
            const response = await this.sendToAPI(messageText);

            // éšè—æ‰“å­—æŒ‡ç¤ºå™¨
            this.hideTypingIndicator();

            // æ·»åŠ AIå“åº”
            if (response.success) {
                const aiMessage = this.addMessage({
                    id: this.generateMessageId(),
                    type: 'assistant',
                    content: response.content,
                    timestamp: new Date().toISOString(),
                    metadata: response.metadata
                });

                // è§¦å‘é‡å­æ•ˆæœ
                this.triggerQuantumEffect('ai_response', { 
                    message: response.content,
                    confidence: response.metadata?.confidence 
                });
            } else {
                // æ˜¾ç¤ºé”™è¯¯æ¶ˆæ¯
                this.addMessage({
                    id: this.generateMessageId(),
                    type: 'error',
                    content: response.error || 'å‘é€å¤±è´¥ï¼Œè¯·é‡è¯•',
                    timestamp: new Date().toISOString()
                });

                // è§¦å‘é”™è¯¯æ•ˆæœ
                this.triggerQuantumEffect('error', { error: response.error });
            }

            // è‡ªåŠ¨ä¿å­˜å¯¹è¯
            if (this.options.autoSave) {
                await this.saveConversation();
            }

        } catch (error) {
            console.error('å‘é€æ¶ˆæ¯å¤±è´¥:', error);
            this.hideTypingIndicator();
            
            this.addMessage({
                id: this.generateMessageId(),
                type: 'error',
                content: 'ç½‘ç»œé”™è¯¯ï¼Œè¯·æ£€æŸ¥è¿æ¥åé‡è¯•',
                timestamp: new Date().toISOString()
            });

            this.emit('error', { type: 'send_message', error });
        }
    }

    /**
     * å‘é€åˆ°API
     */
    async sendToAPI(message, options = {}) {
        const { signal, ...otherOptions } = options;
        
        try {
            const response = await fetch(`${this.options.apiEndpoint}/send`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRF-Token': window.APP_CONFIG?.csrfToken || '',
                    ...this.getAuthHeaders()
                },
                body: JSON.stringify({
                    message,
                    conversation_id: this.state.currentConversationId,
                    context: this.getConversationContext(),
                    ...otherOptions
                }),
                signal
            });

            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }

            const data = await response.json();
            return data;

        } catch (error) {
            if (error.name === 'AbortError') {
                throw new Error('è¯·æ±‚å·²å–æ¶ˆ');
            }
            
            // é‡è¯•é€»è¾‘
            if (this.state.retryCount < this.options.maxRetries) {
                this.state.retryCount++;
                console.log(`é‡è¯•ç¬¬ ${this.state.retryCount} æ¬¡...`);
                
                await this.delay(this.options.retryDelay * this.state.retryCount);
                return this.sendToAPI(message, options);
            }
            
            this.state.retryCount = 0;
            throw error;
        }
    }

    /**
     * æ·»åŠ æ¶ˆæ¯åˆ°ç•Œé¢
     */
    addMessage(messageData) {
        const { id, type, content, timestamp, metadata = {} } = messageData;
        
        // åˆ›å»ºæ¶ˆæ¯å…ƒç´ 
        const messageElement = document.createElement('div');
        messageElement.className = `message message-${type}`;
        messageElement.dataset.messageId = id;
        messageElement.dataset.timestamp = timestamp;

        // ç”Ÿæˆæ¶ˆæ¯HTML
        messageElement.innerHTML = this.generateMessageHTML(messageData);

        // æ·»åŠ åˆ°æ¶ˆæ¯åˆ—è¡¨
        const messagesList = this.elements.messagesList;
        if (messagesList) {
            // éšè—æ¬¢è¿æ¶ˆæ¯
            const welcomeMessage = messagesList.querySelector('.welcome-message');
            if (welcomeMessage) {
                welcomeMessage.style.display = 'none';
            }

            messagesList.appendChild(messageElement);
            this.scrollToBottom();
        }

        // æ·»åŠ åˆ°å½“å‰æ¶ˆæ¯åˆ—è¡¨
        this.currentMessages.push(messageData);

        // è®¾ç½®æ¶ˆæ¯äº¤äº’
        this.setupMessageInteractions(messageElement, messageData);

        // åº”ç”¨é‡å­æ•ˆæœ
        if (this.options.enableQuantumEffects) {
            this.applyQuantumMessageEffect(messageElement, type);
        }

        this.emit('message_added', messageData);
        return messageElement;
    }

    /**
     * ç”Ÿæˆæ¶ˆæ¯HTML
     */
    generateMessageHTML(messageData) {
        const { type, content, timestamp, metadata = {} } = messageData;
        
        const time = new Date(timestamp).toLocaleTimeString('zh-CN', {
            hour: '2-digit',
            minute: '2-digit'
        });

        switch (type) {
            case 'user':
                return `
                    <div class="message-avatar user-avatar">
                        <i class="fas fa-user"></i>
                    </div>
                    <div class="message-content">
                        <div class="message-header">
                            <span class="message-author">æ‚¨</span>
                            <span class="message-time">${time}</span>
                        </div>
                        <div class="message-text user-message">
                            ${this.processMessageContent(content)}
                        </div>
                    </div>
                    <div class="message-actions">
                        <button class="action-btn copy-btn" title="å¤åˆ¶">
                            <i class="fas fa-copy"></i>
                        </button>
                        <button class="action-btn edit-btn" title="ç¼–è¾‘">
                            <i class="fas fa-edit"></i>
                        </button>
                    </div>
                `;

            case 'assistant':
                return `
                    <div class="message-avatar ai-avatar">
                        <div class="quantum-avatar">
                            <div class="quantum-core"></div>
                            <div class="quantum-ring"></div>
                        </div>
                    </div>
                    <div class="message-content">
                        <div class="message-header">
                            <span class="message-author">AlingAi</span>
                            <span class="message-time">${time}</span>
                            ${metadata.confidence ? `<span class="confidence-badge">${Math.round(metadata.confidence * 100)}%</span>` : ''}
                        </div>
                        <div class="message-text ai-message">
                            ${this.processMessageContent(content)}
                        </div>
                    </div>
                    <div class="message-actions">
                        <button class="action-btn copy-btn" title="å¤åˆ¶">
                            <i class="fas fa-copy"></i>
                        </button>
                        <button class="action-btn regenerate-btn" title="é‡æ–°ç”Ÿæˆ">
                            <i class="fas fa-redo"></i>
                        </button>
                        <button class="action-btn speak-btn" title="æœ—è¯»">
                            <i class="fas fa-volume-up"></i>
                        </button>
                        <button class="action-btn like-btn" title="ç‚¹èµ">
                            <i class="far fa-thumbs-up"></i>
                        </button>
                        <button class="action-btn dislike-btn" title="ç‚¹è¸©">
                            <i class="far fa-thumbs-down"></i>
                        </button>
                    </div>
                `;

            case 'error':
                return `
                    <div class="message-avatar error-avatar">
                        <i class="fas fa-exclamation-triangle"></i>
                    </div>
                    <div class="message-content">
                        <div class="message-header">
                            <span class="message-author">ç³»ç»Ÿ</span>
                            <span class="message-time">${time}</span>
                        </div>
                        <div class="message-text error-message">
                            <i class="fas fa-exclamation-circle"></i>
                            ${content}
                        </div>
                    </div>
                    <div class="message-actions">
                        <button class="action-btn retry-btn" title="é‡è¯•">
                            <i class="fas fa-redo"></i>
                        </button>
                    </div>
                `;

            default:
                return `
                    <div class="message-content">
                        <div class="message-text">
                            ${this.processMessageContent(content)}
                        </div>
                    </div>
                `;
        }
    }

    /**
     * å¤„ç†æ¶ˆæ¯å†…å®¹ï¼ˆMarkdownã€ä»£ç é«˜äº®ç­‰ï¼‰
     */
    processMessageContent(content) {
        // è½¬ä¹‰HTMLç‰¹æ®Šå­—ç¬¦
        const escaped = content
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#x27;');

        // ç®€å•çš„Markdownæ”¯æŒ
        return escaped
            // ä»£ç å—
            .replace(/```(\w+)?\n([\s\S]*?)\n```/g, (match, lang, code) => {
                return `<pre class="code-block ${lang || ''}"><code>${code}</code></pre>`;
            })
            // è¡Œå†…ä»£ç 
            .replace(/`([^`]+)`/g, '<code class="inline-code">$1</code>')
            // ç²—ä½“
            .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
            // æ–œä½“
            .replace(/\*(.*?)\*/g, '<em>$1</em>')
            // é“¾æ¥
            .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" rel="noopener">$1</a>')
            // æ¢è¡Œ
            .replace(/\n/g, '<br>');
    }

    /**
     * è®¾ç½®æ¶ˆæ¯äº¤äº’
     */
    setupMessageInteractions(messageElement, messageData) {
        // å¤åˆ¶æŒ‰é’®
        const copyBtn = messageElement.querySelector('.copy-btn');
        copyBtn?.addEventListener('click', () => {
            this.copyMessage(messageData);
        });

        // é‡æ–°ç”ŸæˆæŒ‰é’®
        const regenerateBtn = messageElement.querySelector('.regenerate-btn');
        regenerateBtn?.addEventListener('click', () => {
            this.regenerateMessage(messageData);
        });

        // æœ—è¯»æŒ‰é’®
        const speakBtn = messageElement.querySelector('.speak-btn');
        speakBtn?.addEventListener('click', () => {
            this.speakMessage(messageData);
        });

        // ç‚¹èµ/ç‚¹è¸©
        const likeBtn = messageElement.querySelector('.like-btn');
        const dislikeBtn = messageElement.querySelector('.dislike-btn');
        
        likeBtn?.addEventListener('click', () => {
            this.rateMessage(messageData.id, 'like');
        });
        
        dislikeBtn?.addEventListener('click', () => {
            this.rateMessage(messageData.id, 'dislike');
        });

        // ç¼–è¾‘æŒ‰é’®
        const editBtn = messageElement.querySelector('.edit-btn');
        editBtn?.addEventListener('click', () => {
            this.editMessage(messageData);
        });

        // é‡è¯•æŒ‰é’®
        const retryBtn = messageElement.querySelector('.retry-btn');
        retryBtn?.addEventListener('click', () => {
            this.retryLastMessage();
        });
    }

    /**
     * å¤åˆ¶æ¶ˆæ¯
     */
    async copyMessage(messageData) {
        try {
            await navigator.clipboard.writeText(messageData.content);
            this.showToast('æ¶ˆæ¯å·²å¤åˆ¶åˆ°å‰ªè´´æ¿', 'success');
        } catch (error) {
            console.error('å¤åˆ¶å¤±è´¥:', error);
            this.showToast('å¤åˆ¶å¤±è´¥', 'error');
        }
    }

    /**
     * WebSocketè¿æ¥
     */
    async initWebSocket() {
        if (!window.WebSocket) {
            console.warn('æµè§ˆå™¨ä¸æ”¯æŒWebSocket');
            return;
        }        try {
            // è¿æ¥åˆ°ç‹¬ç«‹çš„WebSocketæœåŠ¡å™¨ç«¯å£
            const wsUrl = `ws://127.0.0.1:8080/ws`;
            
            this.wsConnection = new WebSocket(wsUrl);
            
            this.wsConnection.onopen = () => {
                console.log('âœ… WebSocketè¿æ¥å·²å»ºç«‹');
                this.state.isConnected = true;
                this.updateConnectionStatus(true);
                this.emit('connected');
            };

            this.wsConnection.onmessage = (event) => {
                this.handleWebSocketMessage(event);
            };

            this.wsConnection.onclose = (event) => {
                console.log('WebSocketè¿æ¥å…³é—­:', event.code, event.reason);
                this.state.isConnected = false;
                this.updateConnectionStatus(false);
                this.emit('disconnected');
                
                // è‡ªåŠ¨é‡è¿
                setTimeout(() => {
                    if (!this.state.isConnected) {
                        this.initWebSocket();
                    }
                }, 3000);
            };

            this.wsConnection.onerror = (error) => {
                console.error('WebSocketé”™è¯¯:', error);
                this.emit('error', { type: 'websocket', error });
            };

        } catch (error) {
            console.error('WebSocketåˆå§‹åŒ–å¤±è´¥:', error);
        }
    }

    /**
     * é‡å­æ•ˆæœé›†æˆ
     */
    async initQuantumIntegration() {
        if (window.QuantumParticles && this.options.enableQuantumEffects) {
            try {
                this.quantumIntegrator = new QuantumIntegrator({
                    container: this.elements.container,
                    particleCount: 50,
                    enableInteraction: true
                });
                
                await this.quantumIntegrator.init();
                console.log('âœ… é‡å­æ•ˆæœé›†æˆå®Œæˆ');
            } catch (error) {
                console.warn('é‡å­æ•ˆæœé›†æˆå¤±è´¥:', error);
            }
        }
    }

    /**
     * è§¦å‘é‡å­æ•ˆæœ
     */
    triggerQuantumEffect(type, data = {}) {
        if (this.quantumIntegrator) {
            this.quantumIntegrator.trigger(type, data);
        }
    }

    /**
     * åº”ç”¨æ¶ˆæ¯é‡å­æ•ˆæœ
     */
    applyQuantumMessageEffect(messageElement, type) {
        if (!this.options.enableQuantumEffects) return;

        // æ·»åŠ é‡å­åŠ¨ç”»ç±»
        messageElement.classList.add('quantum-message');
        
        // æ ¹æ®æ¶ˆæ¯ç±»å‹åº”ç”¨ä¸åŒæ•ˆæœ
        switch (type) {
            case 'user':
                messageElement.classList.add('quantum-user');
                break;
            case 'assistant':
                messageElement.classList.add('quantum-ai');
                break;
            case 'error':
                messageElement.classList.add('quantum-error');
                break;
        }

        // å…¥åœºåŠ¨ç”»
        requestAnimationFrame(() => {
            messageElement.classList.add('quantum-enter');
        });
    }

    /**
     * å·¥å…·å‡½æ•°
     */
    generateMessageId() {
        return `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }

    adjustTextareaHeight(textarea) {
        textarea.style.height = 'auto';
        textarea.style.height = Math.min(textarea.scrollHeight, 120) + 'px';
    }

    scrollToBottom() {
        const messagesList = this.elements.messagesList;
        if (messagesList) {
            messagesList.scrollTop = messagesList.scrollHeight;
        }
    }

    clearInput() {
        if (this.elements.messageInput) {
            this.elements.messageInput.value = '';
            this.elements.messageInput.style.height = 'auto';
            
            const charCount = document.getElementById('char-count');
            if (charCount) charCount.textContent = '0';
            
            if (this.elements.sendButton) {
                this.elements.sendButton.disabled = true;
            }
        }
    }

    showTypingIndicator() {
        const indicator = this.elements.typingIndicator;
        if (indicator) {
            indicator.style.display = 'flex';
            this.scrollToBottom();
        }
    }

    hideTypingIndicator() {
        const indicator = this.elements.typingIndicator;
        if (indicator) {
            indicator.style.display = 'none';
        }
    }

    updateConnectionStatus(isConnected) {
        const indicator = this.elements.statusIndicator;
        if (indicator) {
            indicator.className = `status-indicator ${isConnected ? 'online' : 'offline'}`;
            const statusText = indicator.querySelector('.status-text');
            if (statusText) {
                statusText.textContent = isConnected ? 'åœ¨çº¿' : 'ç¦»çº¿';
            }
        }
    }

    showToast(message, type = 'info') {
        // ä½¿ç”¨å…¨å±€é€šçŸ¥ç³»ç»Ÿæˆ–åˆ›å»ºç®€å•toast
        if (window.showNotification) {
            window.showNotification(message, type);
        } else {
            console.log(`[${type.toUpperCase()}] ${message}`);
        }
    }

    delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }    getAuthHeaders() {
        const headers = {
            'Content-Type': 'application/json',
            'X-Requested-With': 'XMLHttpRequest'
        };
        
        const token = localStorage.getItem('auth_token');
        if (token) {
            headers['Authorization'] = `Bearer ${token}`;
        }
        
        return headers;
    }

    getConversationContext() {
        return {
            messages: this.currentMessages.slice(-10), // æœ€è¿‘10æ¡æ¶ˆæ¯
            conversation_id: this.state.currentConversationId,
            user_preferences: this.getUserPreferences()
        };
    }    async getUserPreferences() {
        if (this.state.isAuthenticated) {
            try {
                const response = await fetch(this.apiEndpoints.preferences, {
                    method: 'GET',
                    headers: this.getAuthHeaders()
                });
                
                if (response.ok) {
                    const result = await response.json();
                    if (result.success && result.data) {
                        return result.data;
                    }
                }
            } catch (error) {
                console.warn('è·å–ç”¨æˆ·åå¥½è®¾ç½®å¤±è´¥:', error);
            }
        }
        
        // é™çº§åˆ°localStorage
        return JSON.parse(localStorage.getItem('chat_preferences') || '{}');
    }

    /**
     * äº‹ä»¶ç³»ç»Ÿ
     */
    on(event, callback) {
        if (!this.eventListeners.has(event)) {
            this.eventListeners.set(event, []);
        }
        this.eventListeners.get(event).push(callback);
    }

    off(event, callback) {
        if (this.eventListeners.has(event)) {
            const listeners = this.eventListeners.get(event);
            const index = listeners.indexOf(callback);
            if (index > -1) {
                listeners.splice(index, 1);
            }
        }
    }

    emit(event, data = null) {
        if (this.eventListeners.has(event)) {
            this.eventListeners.get(event).forEach(callback => {
                try {
                    callback(data);
                } catch (error) {
                    console.error(`äº‹ä»¶å›è°ƒé”™è¯¯ [${event}]:`, error);
                }
            });
        }
    }

    /**
     * å¯¹è¯ç®¡ç†
     */
    async createNewConversation() {
        try {
            this.state.currentConversationId = this.generateConversationId();
            this.currentMessages = [];
            
            // æ¸…ç©ºæ¶ˆæ¯åˆ—è¡¨
            if (this.elements.messagesList) {
                this.elements.messagesList.innerHTML = '';
                // é‡æ–°æ·»åŠ æ¬¢è¿æ¶ˆæ¯
                const welcomeMessage = document.createElement('div');
                welcomeMessage.className = 'welcome-message';
                welcomeMessage.innerHTML = this.generateChatHTML().match(/<div class="welcome-message">[\s\S]*?<\/div>/)[0];
                this.elements.messagesList.appendChild(welcomeMessage);
            }

            this.emit('conversation_created', { id: this.state.currentConversationId });
            this.showToast('æ–°å¯¹è¯å·²åˆ›å»º', 'success');

        } catch (error) {
            console.error('åˆ›å»ºæ–°å¯¹è¯å¤±è´¥:', error);
            this.showToast('åˆ›å»ºå¯¹è¯å¤±è´¥', 'error');
        }
    }

    generateConversationId() {
        return `conv_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }    async saveConversation() {
        if (!this.state.currentConversationId || this.currentMessages.length === 0) return;

        try {
            const conversationData = {
                id: this.state.currentConversationId,
                messages: this.currentMessages,
                timestamp: new Date().toISOString(),
                title: this.generateConversationTitle()
            };

            if (this.state.isAuthenticated) {
                // ä¿å­˜åˆ°API
                await this.saveConversationToServer(conversationData);
            } else {
                // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
                await this.saveConversationLocally(conversationData);
            }

        } catch (error) {
            console.error('ä¿å­˜å¯¹è¯å¤±è´¥:', error);
            // é™çº§åˆ°æœ¬åœ°å­˜å‚¨
            if (this.state.isAuthenticated) {
                await this.saveConversationLocally(conversationData);
            }
        }
    }

    async saveConversationLocally(conversationData) {
        const conversations = JSON.parse(localStorage.getItem('chat_conversations') || '[]');
        const existingIndex = conversations.findIndex(conv => conv.id === conversationData.id);
        
        if (existingIndex > -1) {
            conversations[existingIndex] = conversationData;
        } else {
            conversations.unshift(conversationData);
        }

        // é™åˆ¶å­˜å‚¨æ•°é‡
        if (conversations.length > this.options.maxHistorySize) {
            conversations.splice(this.options.maxHistorySize);
        }

        localStorage.setItem('chat_conversations', JSON.stringify(conversations));
    }

    async saveConversationToServer(conversationData) {
        const response = await fetch(this.apiEndpoints.sessions, {
            method: 'POST',
            headers: this.getAuthHeaders(),
            body: JSON.stringify({
                conversation_id: conversationData.id,
                title: conversationData.title,
                messages: conversationData.messages
            })
        });

        if (!response.ok) {
            throw new Error(`ä¿å­˜ä¼šè¯å¤±è´¥: ${response.status}`);
        }

        const result = await response.json();
        if (!result.success) {
            throw new Error(result.message || 'ä¿å­˜ä¼šè¯å¤±è´¥');
        }
    }

        } catch (error) {
            console.error('ä¿å­˜å¯¹è¯å¤±è´¥:', error);
        }
    }

    generateConversationTitle() {
        if (this.currentMessages.length === 0) return 'æ–°å¯¹è¯';
        
        const firstUserMessage = this.currentMessages.find(msg => msg.type === 'user');
        if (firstUserMessage) {
            const title = firstUserMessage.content.slice(0, 30);
            return title.length < firstUserMessage.content.length ? title + '...' : title;
        }
        
        return 'æ–°å¯¹è¯';
    }

    async loadConversationHistory() {
        try {
            const conversations = JSON.parse(localStorage.getItem('chat_conversations') || '[]');
            this.conversations.clear();
            
            conversations.forEach(conv => {
                this.conversations.set(conv.id, conv);
            });

            this.renderConversationsList();

        } catch (error) {
            console.error('åŠ è½½å¯¹è¯å†å²å¤±è´¥:', error);
        }
    }

    renderConversationsList() {
        const list = this.elements.conversationsList;
        if (!list) return;

        list.innerHTML = '';
        
        Array.from(this.conversations.values())
            .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))
            .forEach(conv => {
                const item = this.createConversationItem(conv);
                list.appendChild(item);
            });
    }

    createConversationItem(conversation) {
        const item = document.createElement('div');
        item.className = 'conversation-item';
        item.dataset.conversationId = conversation.id;
        
        const isActive = conversation.id === this.state.currentConversationId;
        if (isActive) {
            item.classList.add('active');
        }

        const time = new Date(conversation.timestamp).toLocaleDateString('zh-CN');
        const messageCount = conversation.messages.length;

        item.innerHTML = `
            <div class="conversation-info">
                <div class="conversation-title">${conversation.title}</div>
                <div class="conversation-meta">
                    <span class="conversation-time">${time}</span>
                    <span class="conversation-count">${messageCount} æ¡æ¶ˆæ¯</span>
                </div>
            </div>
            <div class="conversation-actions">
                <button class="action-btn delete-btn" title="åˆ é™¤">
                    <i class="fas fa-trash"></i>
                </button>
            </div>
        `;

        // ç‚¹å‡»åŠ è½½å¯¹è¯
        item.addEventListener('click', (e) => {
            if (!e.target.closest('.conversation-actions')) {
                this.loadConversation(conversation.id);
            }
        });

        // åˆ é™¤å¯¹è¯
        const deleteBtn = item.querySelector('.delete-btn');
        deleteBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            this.deleteConversation(conversation.id);
        });

        return item;
    }

    async loadConversation(conversationId) {
        try {
            const conversation = this.conversations.get(conversationId);
            if (!conversation) return;

            this.state.currentConversationId = conversationId;
            this.currentMessages = [...conversation.messages];

            // æ¸…ç©ºå¹¶é‡æ–°æ¸²æŸ“æ¶ˆæ¯
            if (this.elements.messagesList) {
                this.elements.messagesList.innerHTML = '';
                
                this.currentMessages.forEach(message => {
                    this.addMessage(message);
                });
            }

            // æ›´æ–°å¯¹è¯åˆ—è¡¨çŠ¶æ€
            this.updateConversationListState();

            this.emit('conversation_loaded', conversation);

        } catch (error) {
            console.error('åŠ è½½å¯¹è¯å¤±è´¥:', error);
            this.showToast('åŠ è½½å¯¹è¯å¤±è´¥', 'error');
        }
    }

    updateConversationListState() {
        const items = this.elements.conversationsList?.querySelectorAll('.conversation-item');
        items?.forEach(item => {
            const isActive = item.dataset.conversationId === this.state.currentConversationId;
            item.classList.toggle('active', isActive);
        });
    }

    async deleteConversation(conversationId) {
        if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªå¯¹è¯å—ï¼Ÿ')) return;

        try {
            this.conversations.delete(conversationId);
            
            // æ›´æ–°æœ¬åœ°å­˜å‚¨
            const conversations = Array.from(this.conversations.values());
            localStorage.setItem('chat_conversations', JSON.stringify(conversations));

            // é‡æ–°æ¸²æŸ“åˆ—è¡¨
            this.renderConversationsList();

            // å¦‚æœåˆ é™¤çš„æ˜¯å½“å‰å¯¹è¯ï¼Œåˆ›å»ºæ–°å¯¹è¯
            if (conversationId === this.state.currentConversationId) {
                await this.createNewConversation();
            }

            this.showToast('å¯¹è¯å·²åˆ é™¤', 'success');

        } catch (error) {
            console.error('åˆ é™¤å¯¹è¯å¤±è´¥:', error);
            this.showToast('åˆ é™¤å¯¹è¯å¤±è´¥', 'error');
        }
    }

    /**
     * æ¸…ç†èµ„æº
     */
    cleanup() {
        // å…³é—­WebSocketè¿æ¥
        if (this.wsConnection) {
            this.wsConnection.close();
        }

        // æ¸…ç†é‡å­æ•ˆæœ
        if (this.quantumIntegrator) {
            this.quantumIntegrator.destroy();
        }

        // ä¿å­˜æœ€åçŠ¶æ€
        this.saveConversation();

        console.log('âœ… èŠå¤©ç³»ç»Ÿå·²æ¸…ç†');
    }

    /**
     * åŠ è½½è®¾ç½®
     */
    async loadSettings() {
        try {
            const settings = JSON.parse(localStorage.getItem('chat_settings') || '{}');
            Object.assign(this.options, settings);
        } catch (error) {
            console.error('åŠ è½½è®¾ç½®å¤±è´¥:', error);
        }
    }

    /**
     * å…¶ä»–åŠŸèƒ½æ–¹æ³•å ä½ç¬¦
     */
    async sendTypingIndicator() {
        // å‘é€æ‰“å­—æŒ‡ç¤ºå™¨
    }

    handleVisibilityChange() {
        // å¤„ç†é¡µé¢å¯è§æ€§å˜åŒ–
    }

    handleQuickAction(action) {
        // å¤„ç†å¿«æ·æ“ä½œ
        const prompts = {
            explain: 'è¯·è§£é‡Šä¸€ä¸‹ï¼š',
            code: 'è¯·å¸®æˆ‘å†™ä»£ç ï¼š',
            translate: 'è¯·ç¿»è¯‘ï¼š',
            summarize: 'è¯·æ€»ç»“ï¼š'
        };

        const prompt = prompts[action];
        if (prompt && this.elements.messageInput) {
            this.elements.messageInput.value = prompt;
            this.elements.messageInput.focus();
        }
    }

    async regenerateMessage(messageData) {
        // é‡æ–°ç”Ÿæˆæ¶ˆæ¯
        this.showToast('é‡æ–°ç”ŸæˆåŠŸèƒ½å¼€å‘ä¸­...', 'info');
    }

    async speakMessage(messageData) {
        // æœ—è¯»æ¶ˆæ¯
        this.showToast('è¯­éŸ³æœ—è¯»åŠŸèƒ½å¼€å‘ä¸­...', 'info');
    }

    async rateMessage(messageId, rating) {
        // è¯„ä»·æ¶ˆæ¯
        this.showToast(`å·²${rating === 'like' ? 'ç‚¹èµ' : 'ç‚¹è¸©'}`, 'success');
    }

    async editMessage(messageData) {
        // ç¼–è¾‘æ¶ˆæ¯
        this.showToast('ç¼–è¾‘æ¶ˆæ¯åŠŸèƒ½å¼€å‘ä¸­...', 'info');
    }

    async retryLastMessage() {
        // é‡è¯•æœ€åä¸€æ¡æ¶ˆæ¯
        const lastUserMessage = this.currentMessages
            .slice()
            .reverse()
            .find(msg => msg.type === 'user');
        
        if (lastUserMessage) {
            await this.sendMessage(lastUserMessage.content);
        }
    }

    toggleVoiceInput() {
        // åˆ‡æ¢è¯­éŸ³è¾“å…¥
        this.showToast('è¯­éŸ³è¾“å…¥åŠŸèƒ½å¼€å‘ä¸­...', 'info');
    }

    filterConversations(searchTerm) {
        // è¿‡æ»¤å¯¹è¯
        const items = this.elements.conversationsList?.querySelectorAll('.conversation-item');
        items?.forEach(item => {
            const title = item.querySelector('.conversation-title')?.textContent || '';
            const visible = title.toLowerCase().includes(searchTerm.toLowerCase());
            item.style.display = visible ? 'block' : 'none';
        });
    }

    focusConversationSearch() {
        const searchInput = document.getElementById('conversations-search');
        searchInput?.focus();
    }

    showShortcutsHelp() {
        this.showToast('å¿«æ·é”®å¸®åŠ©åŠŸèƒ½å¼€å‘ä¸­...', 'info');
    }

    handleWebSocketMessage(event) {
        try {
            const data = JSON.parse(event.data);
            this.emit('websocket_message', data);
        } catch (error) {
            console.error('å¤„ç†WebSocketæ¶ˆæ¯å¤±è´¥:', error);
        }
    }

    async saveConversationToServer(conversationData) {
        // ä¿å­˜å¯¹è¯åˆ°æœåŠ¡å™¨
        try {
            await fetch('/api/conversations', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    ...this.getAuthHeaders()
                },
                body: JSON.stringify(conversationData)
            });
        } catch (error) {
            console.error('ä¿å­˜å¯¹è¯åˆ°æœåŠ¡å™¨å¤±è´¥:', error);
        }
    }
}

/**
 * é‡å­é›†æˆå™¨ç±»
 */
class QuantumIntegrator {
    constructor(options = {}) {
        this.options = {
            container: null,
            particleCount: 30,
            enableInteraction: true,
            ...options
        };
        
        this.particles = null;
        this.isInitialized = false;
    }

    async init() {
        if (window.QuantumParticles) {
            this.particles = new window.QuantumParticles(this.options.container, {
                count: this.options.particleCount,
                interactive: this.options.enableInteraction
            });
            
            await this.particles.init();
            this.isInitialized = true;
        }
    }

    trigger(type, data = {}) {
        if (!this.isInitialized || !this.particles) return;

        switch (type) {
            case 'user_message':
                this.particles.pulse({ color: '#3b82f6', intensity: 0.7 });
                break;
            case 'ai_response':
                this.particles.wave({ color: '#10b981', intensity: 0.8 });
                break;
            case 'error':
                this.particles.shake({ color: '#ef4444', intensity: 0.6 });
                break;
            default:
                this.particles.glow({ intensity: 0.5 });
        }
    }

    destroy() {
        if (this.particles) {
            this.particles.destroy();
            this.particles = null;
            this.isInitialized = false;
        }
    }
}

// å¯¼å‡º
window.ChatSystem = ChatSystem;
window.QuantumIntegrator = QuantumIntegrator;

console.log('âœ… èŠå¤©ç³»ç»Ÿæ¨¡å—å·²åŠ è½½');
