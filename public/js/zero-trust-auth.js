/**
 * Èõ∂‰ø°‰ªªËÆ§ËØÅÁ≥ªÁªü
 * ÂÆûÁé∞Â§öÂõ†Á¥†ËÆ§ËØÅ„ÄÅËÆæÂ§áÊåáÁ∫π„ÄÅË°å‰∏∫ÂàÜÊûêÁ≠âÂÆâÂÖ®ÁâπÊÄß
 */

class ZeroTrustAuth {
    constructor() {
        this.config = {
            deviceFingerprintEnabled: true,
            behaviorAnalysisEnabled: true,
            multiFactorEnabled: true,
            riskBasedAuth: true,
            sessionMonitoring: true,
            maxFailedAttempts: 5,
            lockoutDuration: 30 * 60 * 1000, // 30ÂàÜÈíü
            sessionTimeout: 24 * 60 * 60 * 1000, // 24Â∞èÊó∂
            riskThreshold: 0.7
        };
        
        this.authFactors = new Map();
        this.securityMetrics = {
            loginAttempts: 0,
            failedAttempts: 0,
            lastLoginTime: null,
            deviceChanges: 0,
            locationChanges: 0,
            behaviorScore: 1.0,
            riskScore: 0.0
        };
        
        this.deviceFingerprint = null;
        this.sessionData = null;
        this.behaviorPatterns = [];
        
        this.init();
    }

    // ==================== ÂàùÂßãÂåñ ====================

    async init() {
        
        
        try {
            await this.generateDeviceFingerprint();
            this.loadSecurityMetrics();
            this.setupSessionMonitoring();
            this.setupBehaviorAnalysis();
            this.setupEventListeners();
            
            
        } catch (error) {
            console.error('‚ùå Èõ∂‰ø°‰ªªËÆ§ËØÅÁ≥ªÁªüÂàùÂßãÂåñÂ§±Ë¥•:', error);
        }
    }

    setupEventListeners() {
        // ÁõëÂê¨Áî®Êà∑Ê¥ªÂä®
        document.addEventListener('mousemove', (e) => this.trackBehavior('mousemove', e));
        document.addEventListener('keydown', (e) => this.trackBehavior('keydown', e));
        document.addEventListener('click', (e) => this.trackBehavior('click', e));
        
        // ÁõëÂê¨È°µÈù¢ÂèØËßÅÊÄßÂèòÂåñ
        document.addEventListener('visibilitychange', () => {
            this.trackBehavior('visibility', { hidden: document.hidden });
        });
        
        // ÁõëÂê¨ÁΩëÁªúÁä∂ÊÄÅÂèòÂåñ
        window.addEventListener('online', () => this.trackBehavior('network', { online: true }));
        window.addEventListener('offline', () => this.trackBehavior('network', { online: false }));
    }

    // ==================== ËÆæÂ§áÊåáÁ∫π ====================

    async generateDeviceFingerprint() {
        try {
            const fingerprint = {
                userAgent: navigator.userAgent,
                language: navigator.language,
                platform: navigator.platform,
                cookieEnabled: navigator.cookieEnabled,
                timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                screen: {
                    width: screen.width,
                    height: screen.height,
                    colorDepth: screen.colorDepth,
                    pixelDepth: screen.pixelDepth
                },
                canvas: await this.generateCanvasFingerprint(),
                webgl: await this.generateWebGLFingerprint(),
                audio: await this.generateAudioFingerprint(),
                fonts: await this.getAvailableFonts(),
                plugins: this.getPluginInfo(),
                hardware: await this.getHardwareInfo(),
                timestamp: Date.now()
            };

            this.deviceFingerprint = await this.hashFingerprint(fingerprint);
            
            // Â≠òÂÇ®ËÆæÂ§áÊåáÁ∫π
            this.storeDeviceFingerprint(this.deviceFingerprint);
            
            console.log('üîç ËÆæÂ§áÊåáÁ∫πÁîüÊàêÂÆåÊàê:', this.deviceFingerprint.substring(0, 16) + '...');
            
            return this.deviceFingerprint;
        } catch (error) {
            console.error('ËÆæÂ§áÊåáÁ∫πÁîüÊàêÂ§±Ë¥•:', error);
            this.deviceFingerprint = 'fallback_' + Date.now();
            return this.deviceFingerprint;
        }
    }

    async generateCanvasFingerprint() {
        try {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = 200;
            canvas.height = 50;
            
            // ÁªòÂà∂ÊåáÁ∫πÂõæÊ°à
            ctx.textBaseline = 'top';
            ctx.font = '14px Arial';
            ctx.textBaseline = 'alphabetic';
            ctx.fillStyle = '#f60';
            ctx.fillRect(125, 1, 62, 20);
            ctx.fillStyle = '#069';
            ctx.fillText('AlingAi Zero Trust üîê', 2, 15);
            ctx.fillStyle = 'rgba(102, 204, 0, 0.7)';
            ctx.fillText('Security Fingerprint', 4, 35);
            
            return canvas.toDataURL();
        } catch (error) {
            console.warn('CanvasÊåáÁ∫πÁîüÊàêÂ§±Ë¥•:', error);
            return 'canvas_error';
        }
    }

    async generateWebGLFingerprint() {
        try {
            const canvas = document.createElement('canvas');
            const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            
            if (!gl) return 'webgl_not_supported';
            
            const renderer = gl.getParameter(gl.RENDERER);
            const vendor = gl.getParameter(gl.VENDOR);
            const version = gl.getParameter(gl.VERSION);
            const shadingLanguageVersion = gl.getParameter(gl.SHADING_LANGUAGE_VERSION);
            
            return btoa(JSON.stringify({
                renderer,
                vendor,
                version,
                shadingLanguageVersion
            }));
        } catch (error) {
            console.warn('WebGLÊåáÁ∫πÁîüÊàêÂ§±Ë¥•:', error);
            return 'webgl_error';
        }
    }

    async generateAudioFingerprint() {
        return new Promise((resolve) => {
            try {
                const context = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = context.createOscillator();
                const analyser = context.createAnalyser();
                const gainNode = context.createGain();
                const scriptProcessor = context.createScriptProcessor(4096, 1, 1);
                
                oscillator.type = 'triangle';
                oscillator.frequency.setValueAtTime(10000, context.currentTime);
                
                gainNode.gain.setValueAtTime(0, context.currentTime);
                
                oscillator.connect(analyser);
                analyser.connect(scriptProcessor);
                scriptProcessor.connect(gainNode);
                gainNode.connect(context.destination);
                
                scriptProcessor.onaudioprocess = function(bins) {
                    const data = new Float32Array(analyser.frequencyBinCount);
                    analyser.getFloatFrequencyData(data);
                    
                    const fingerprint = Array.from(data.slice(0, 50))
                        .map(x => Math.round(x * 1000))
                        .join(',');
                    
                    oscillator.disconnect();
                    scriptProcessor.disconnect();
                    context.close();
                    
                    resolve(btoa(fingerprint));
                };
                
                oscillator.start();
                
                setTimeout(() => {
                    resolve('audio_timeout');
                }, 1000);
            } catch (error) {
                console.warn('Èü≥È¢ëÊåáÁ∫πÁîüÊàêÂ§±Ë¥•:', error);
                resolve('audio_error');
            }
        });
    }

    async getAvailableFonts() {
        const testFonts = [
            'Arial', 'Helvetica', 'Times New Roman', 'Courier New', 'Verdana',
            'Georgia', 'Palatino', 'Garamond', 'Bookman', 'Comic Sans MS',
            'Trebuchet MS', 'Arial Black', 'Impact', 'Microsoft Sans Serif',
            'Tahoma', 'Monaco', 'Courier', 'Lucida Console'
        ];
        
        const availableFonts = [];
        
        for (const font of testFonts) {
            if (await this.isFontAvailable(font)) {
                availableFonts.push(font);
            }
        }
        
        return availableFonts.join(',');
    }

    async isFontAvailable(fontName) {
        const testString = 'mmmmmmmmmmlli';
        const testSize = '72px';
        const baseFonts = ['monospace', 'sans-serif', 'serif'];
        
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        
        for (const baseFont of baseFonts) {
            context.font = `${testSize} ${baseFont}`;
            const baseWidth = context.measureText(testString).width;
            
            context.font = `${testSize} ${fontName}, ${baseFont}`;
            const testWidth = context.measureText(testString).width;
            
            if (baseWidth !== testWidth) {
                return true;
            }
        }
        
        return false;
    }

    getPluginInfo() {
        const plugins = [];
        for (let i = 0; i < navigator.plugins.length; i++) {
            const plugin = navigator.plugins[i];
            plugins.push({
                name: plugin.name,
                description: plugin.description,
                filename: plugin.filename
            });
        }
        return JSON.stringify(plugins);
    }

    async getHardwareInfo() {
        const info = {
            hardwareConcurrency: navigator.hardwareConcurrency || 0,
            deviceMemory: navigator.deviceMemory || 0,
            maxTouchPoints: navigator.maxTouchPoints || 0
        };
        
        // Ëé∑ÂèñÁîµÊ±†‰ø°ÊÅØÔºàÂ¶ÇÊûúÂèØÁî®Ôºâ
        if ('getBattery' in navigator) {
            try {
                const battery = await navigator.getBattery();
                info.battery = {
                    charging: battery.charging,
                    level: Math.round(battery.level * 100),
                    chargingTime: battery.chargingTime,
                    dischargingTime: battery.dischargingTime
                };
            } catch (error) {
                info.battery = 'unavailable';
            }
        }
        
        return info;
    }

    async hashFingerprint(fingerprint) {
        const encoder = new TextEncoder();
        const data = encoder.encode(JSON.stringify(fingerprint));
        const hashBuffer = await crypto.subtle.digest('SHA-256', data);
        const hashArray = Array.from(new Uint8Array(hashBuffer));
        return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    }

    storeDeviceFingerprint(fingerprint) {
        try {
            localStorage.setItem('deviceFingerprint', fingerprint);
            localStorage.setItem('fingerprintTimestamp', Date.now().toString());
        } catch (error) {
            console.warn('ËÆæÂ§áÊåáÁ∫πÂ≠òÂÇ®Â§±Ë¥•:', error);
        }
    }

    // ==================== Ë°å‰∏∫ÂàÜÊûê ====================

    setupBehaviorAnalysis() {
        this.behaviorMetrics = {
            mouseMovements: [],
            keystrokes: [],
            clicks: [],
            scrollEvents: [],
            typingPattern: {
                averageSpeed: 0,
                rhythm: [],
                pauses: []
            },
            sessionDuration: 0,
            activityLevel: 0
        };
        
        // ÂêØÂä®Ë°å‰∏∫ÂàÜÊûêÂÆöÊó∂Âô®
        this.behaviorTimer = setInterval(() => {
            this.analyzeBehavior();
        }, 30000); // ÊØè30ÁßíÂàÜÊûê‰∏ÄÊ¨°
    }

    trackBehavior(type, data) {
        const timestamp = Date.now();
        
        switch (type) {
            case 'mousemove':
                this.behaviorMetrics.mouseMovements.push({
                    x: data.clientX,
                    y: data.clientY,
                    timestamp
                });
                // ‰øùÊåÅÊúÄËøë100‰∏™ÁßªÂä®ËÆ∞ÂΩï
                if (this.behaviorMetrics.mouseMovements.length > 100) {
                    this.behaviorMetrics.mouseMovements.shift();
                }
                break;
                
            case 'keydown':
                this.behaviorMetrics.keystrokes.push({
                    key: data.key,
                    keyCode: data.keyCode,
                    timestamp
                });
                // ‰øùÊåÅÊúÄËøë50‰∏™ÊåâÈîÆËÆ∞ÂΩï
                if (this.behaviorMetrics.keystrokes.length > 50) {
                    this.behaviorMetrics.keystrokes.shift();
                }
                this.updateTypingPattern();
                break;
                
            case 'click':
                this.behaviorMetrics.clicks.push({
                    x: data.clientX,
                    y: data.clientY,
                    button: data.button,
                    timestamp
                });
                // ‰øùÊåÅÊúÄËøë20‰∏™ÁÇπÂáªËÆ∞ÂΩï
                if (this.behaviorMetrics.clicks.length > 20) {
                    this.behaviorMetrics.clicks.shift();
                }
                break;
                
            case 'scroll':
                this.behaviorMetrics.scrollEvents.push({
                    scrollX: window.scrollX,
                    scrollY: window.scrollY,
                    timestamp
                });
                // ‰øùÊåÅÊúÄËøë30‰∏™ÊªöÂä®ËÆ∞ÂΩï
                if (this.behaviorMetrics.scrollEvents.length > 30) {
                    this.behaviorMetrics.scrollEvents.shift();
                }
                break;
        }
        
        this.behaviorPatterns.push({ type, timestamp });
        // ‰øùÊåÅÊúÄËøë200‰∏™Ë°å‰∏∫ËÆ∞ÂΩï
        if (this.behaviorPatterns.length > 200) {
            this.behaviorPatterns.shift();
        }
    }

    updateTypingPattern() {
        const keystrokes = this.behaviorMetrics.keystrokes;
        if (keystrokes.length < 2) return;
        
        const intervals = [];
        for (let i = 1; i < keystrokes.length; i++) {
            intervals.push(keystrokes[i].timestamp - keystrokes[i-1].timestamp);
        }
        
        if (intervals.length > 0) {
            const avgSpeed = intervals.reduce((a, b) => a + b, 0) / intervals.length;
            this.behaviorMetrics.typingPattern.averageSpeed = avgSpeed;
            this.behaviorMetrics.typingPattern.rhythm = intervals.slice(-10); // ÊúÄËøë10‰∏™Èó¥Èöî
        }
    }

    analyzeBehavior() {
        const now = Date.now();
        const timeWindow = 60000; // 1ÂàÜÈíüÁ™óÂè£
        
        // ËÆ°ÁÆóÊ¥ªÂä®Á∫ßÂà´
        const recentActivities = this.behaviorPatterns.filter(
            pattern => now - pattern.timestamp < timeWindow
        );
        
        this.behaviorMetrics.activityLevel = recentActivities.length;
        
        // ËÆ°ÁÆóË°å‰∏∫ÂàÜÊï∞
        this.calculateBehaviorScore();
        
        // Êõ¥Êñ∞È£éÈô©ËØÑÂàÜ
        this.updateRiskScore();
    }

    calculateBehaviorScore() {
        let score = 1.0;
        
        // Ê¥ªÂä®Á∫ßÂà´ÂàÜÊûê
        if (this.behaviorMetrics.activityLevel === 0) {
            score -= 0.3; // Êó†Ê¥ªÂä®Èôç‰ΩéÂàÜÊï∞
        } else if (this.behaviorMetrics.activityLevel > 100) {
            score -= 0.2; // ËøáÂ∫¶Ê¥ªÂä®‰πüÂèØËÉΩÊòØÂºÇÂ∏∏
        }
        
        // Èº†Ê†áÁßªÂä®Ê®°ÂºèÂàÜÊûê
        if (this.behaviorMetrics.mouseMovements.length > 10) {
            const movements = this.behaviorMetrics.mouseMovements;
            const distances = [];
            
            for (let i = 1; i < movements.length; i++) {
                const dx = movements[i].x - movements[i-1].x;
                const dy = movements[i].y - movements[i-1].y;
                distances.push(Math.sqrt(dx*dx + dy*dy));
            }
            
            const avgDistance = distances.reduce((a, b) => a + b, 0) / distances.length;
            
            // Ê≠£Â∏∏Èº†Ê†áÁßªÂä®Ë∑ùÁ¶ªÂ∫îËØ•Âú®‰∏ÄÂÆöËåÉÂõ¥ÂÜÖ
            if (avgDistance < 5 || avgDistance > 200) {
                score -= 0.1;
            }
        }
        
        // ÊâìÂ≠óÊ®°ÂºèÂàÜÊûê
        if (this.behaviorMetrics.typingPattern.averageSpeed > 0) {
            const speed = this.behaviorMetrics.typingPattern.averageSpeed;
            // Ê≠£Â∏∏ÊâìÂ≠óÈÄüÂ∫¶: 50-300ms
            if (speed < 50 || speed > 300) {
                score -= 0.1;
            }
        }
        
        this.securityMetrics.behaviorScore = Math.max(0, Math.min(1, score));
    }

    // ==================== È£éÈô©ËØÑ‰º∞ ====================

    updateRiskScore() {
        let riskScore = 0;
        
        // ËÆæÂ§áÂèòÂåñÈ£éÈô©
        if (this.securityMetrics.deviceChanges > 0) {
            riskScore += this.securityMetrics.deviceChanges * 0.2;
        }
        
        // ‰ΩçÁΩÆÂèòÂåñÈ£éÈô©
        if (this.securityMetrics.locationChanges > 2) {
            riskScore += (this.securityMetrics.locationChanges - 2) * 0.1;
        }
        
        // Â§±Ë¥•ÁôªÂΩïÊ¨°Êï∞
        if (this.securityMetrics.failedAttempts > 0) {
            riskScore += this.securityMetrics.failedAttempts * 0.15;
        }
        
        // Ë°å‰∏∫ÂºÇÂ∏∏
        if (this.securityMetrics.behaviorScore < 0.7) {
            riskScore += (0.7 - this.securityMetrics.behaviorScore) * 0.5;
        }
        
        // Êó∂Èó¥ÂºÇÂ∏∏ÔºàÈùûÊ≠£Â∏∏Êó∂Èó¥ÁôªÂΩïÔºâ
        const hour = new Date().getHours();
        if (hour < 6 || hour > 23) {
            riskScore += 0.1;
        }
        
        this.securityMetrics.riskScore = Math.min(1, riskScore);
        
        
    }

    // ==================== Â§öÂõ†Á¥†ËÆ§ËØÅ ====================

    async requestMFA(loginData) {
        const riskScore = this.securityMetrics.riskScore;
        const isHighRisk = riskScore > this.config.riskThreshold;
        
        
        
        if (!isHighRisk && this.isTrustedDevice()) {
            return { required: false, factors: [] };
        }
        
        const factors = [];
        
        // Âü∫‰∫éÈ£éÈô©Á∫ßÂà´Á°ÆÂÆöÈúÄË¶ÅÁöÑËÆ§ËØÅÂõ†Á¥†
        if (riskScore > 0.8) {
            factors.push('sms', 'email', 'totp');
        } else if (riskScore > 0.5) {
            factors.push('email', 'totp');
        } else {
            factors.push('email');
        }
        
        return {
            required: true,
            factors,
            riskScore,
            challengeId: this.generateChallengeId()
        };
    }

    generateChallengeId() {
        return 'chg_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }

    async verifyMFAFactor(challengeId, factor, value) {
        // ËøôÈáåÂ∫îËØ•Ë∞ÉÁî®ÂêéÁ´ØAPIÈ™åËØÅ
        console.log('È™åËØÅMFAÂõ†Á¥†:', { challengeId, factor, value: value.substring(0, 3) + '...' });
        
        // Ê®°ÊãüÈ™åËØÅËøáÁ®ã
        return new Promise((resolve) => {
            setTimeout(() => {
                // ÁÆÄÂçïÁöÑÊ®°ÊãüÈ™åËØÅ
                const isValid = value.length >= 4;
                resolve({
                    success: isValid,
                    factor,
                    challengeId
                });
            }, 1000);
        });
    }

    // ==================== ËÆæÂ§á‰ø°‰ªªÁÆ°ÁêÜ ====================

    isTrustedDevice() {
        const storedFingerprint = localStorage.getItem('trustedDeviceFingerprint');
        const fingerprintTimestamp = localStorage.getItem('trustedDeviceTimestamp');
        
        if (!storedFingerprint || !fingerprintTimestamp) {
            return false;
        }
        
        // Ê£ÄÊü•ËÆæÂ§á‰ø°‰ªªÊòØÂê¶ËøáÊúüÔºà30Â§©Ôºâ
        const trustExpiry = 30 * 24 * 60 * 60 * 1000;
        if (Date.now() - parseInt(fingerprintTimestamp) > trustExpiry) {
            this.removeTrustedDevice();
            return false;
        }
        
        return storedFingerprint === this.deviceFingerprint;
    }

    markDeviceAsTrusted() {
        try {
            localStorage.setItem('trustedDeviceFingerprint', this.deviceFingerprint);
            localStorage.setItem('trustedDeviceTimestamp', Date.now().toString());
            
        } catch (error) {
            console.error('Ê†áËÆ∞‰ø°‰ªªËÆæÂ§áÂ§±Ë¥•:', error);
        }
    }

    removeTrustedDevice() {
        try {
            localStorage.removeItem('trustedDeviceFingerprint');
            localStorage.removeItem('trustedDeviceTimestamp');
            
        } catch (error) {
            console.error('ÁßªÈô§‰ø°‰ªªËÆæÂ§áÂ§±Ë¥•:', error);
        }
    }

    // ==================== ‰ºöËØùÁõëÊéß ====================

    setupSessionMonitoring() {
        this.sessionData = {
            startTime: Date.now(),
            lastActivity: Date.now(),
            isActive: true,
            warnings: []
        };
        
        // ÂÆöÊúüÊ£ÄÊü•‰ºöËØùÁä∂ÊÄÅ
        this.sessionMonitor = setInterval(() => {
            this.checkSessionSecurity();
        }, 60000); // ÊØèÂàÜÈíüÊ£ÄÊü•‰∏ÄÊ¨°
        
        // ÁõëÂê¨Áî®Êà∑Ê¥ªÂä®
        const updateActivity = () => {
            this.sessionData.lastActivity = Date.now();
        };
        
        document.addEventListener('mousemove', updateActivity);
        document.addEventListener('keydown', updateActivity);
        document.addEventListener('click', updateActivity);
    }

    checkSessionSecurity() {
        const now = Date.now();
        const inactiveTime = now - this.sessionData.lastActivity;
        
        // Ê£ÄÊü•‰ºöËØùË∂ÖÊó∂
        if (inactiveTime > this.config.sessionTimeout) {
            this.handleSessionTimeout();
            return;
        }
        
        // Ê£ÄÊü•ËÆæÂ§áÂèòÂåñ
        if (this.deviceFingerprint !== localStorage.getItem('deviceFingerprint')) {
            this.handleDeviceChange();
            return;
        }
        
        // Ê£ÄÊü•ÂºÇÂ∏∏Ë°å‰∏∫
        if (this.securityMetrics.riskScore > this.config.riskThreshold) {
            this.handleHighRiskBehavior();
        }
    }

    handleSessionTimeout() {
        console.warn('‚ö†Ô∏è ‰ºöËØùË∂ÖÊó∂');
        this.sessionData.warnings.push({
            type: 'timeout',
            timestamp: Date.now(),
            message: '‰ºöËØùÂõ†ÈïøÊó∂Èó¥‰∏çÊ¥ªÂä®ËÄåË∂ÖÊó∂'
        });
        
        // ÂèØ‰ª•Ëß¶ÂèëÈáçÊñ∞ËÆ§ËØÅÊàñËá™Âä®ÁôªÂá∫
        this.triggerReAuthentication('session_timeout');
    }

    handleDeviceChange() {
        console.warn('‚ö†Ô∏è Ê£ÄÊµãÂà∞ËÆæÂ§áÂèòÂåñ');
        this.securityMetrics.deviceChanges++;
        this.sessionData.warnings.push({
            type: 'device_change',
            timestamp: Date.now(),
            message: 'Ê£ÄÊµãÂà∞ËÆæÂ§áÊåáÁ∫πÂèòÂåñ'
        });
        
        this.triggerReAuthentication('device_change');
    }

    handleHighRiskBehavior() {
        console.warn('‚ö†Ô∏è Ê£ÄÊµãÂà∞È´òÈ£éÈô©Ë°å‰∏∫');
        this.sessionData.warnings.push({
            type: 'high_risk',
            timestamp: Date.now(),
            message: 'Ê£ÄÊµãÂà∞ÂºÇÂ∏∏Ë°å‰∏∫Ê®°Âºè',
            riskScore: this.securityMetrics.riskScore
        });
        
        // È´òÈ£éÈô©Ë°å‰∏∫ÂèØËÉΩÈúÄË¶ÅÈ¢ùÂ§ñÈ™åËØÅ
        if (this.securityMetrics.riskScore > 0.9) {
            this.triggerReAuthentication('high_risk');
        }
    }

    triggerReAuthentication(reason) {
        
        
        // ÂèëÈÄÅÈáçÊñ∞ËÆ§ËØÅ‰∫ã‰ª∂
        window.dispatchEvent(new CustomEvent('zeroTrustReAuth', {
            detail: {
                reason,
                riskScore: this.securityMetrics.riskScore,
                timestamp: Date.now()
            }
        }));
    }

    // ==================== Êï∞ÊçÆÊåÅ‰πÖÂåñ ====================

    loadSecurityMetrics() {
        try {
            const stored = localStorage.getItem('securityMetrics');
            if (stored) {
                this.securityMetrics = { ...this.securityMetrics, ...JSON.parse(stored) };
            }
        } catch (error) {
            console.warn('Âä†ËΩΩÂÆâÂÖ®ÊåáÊ†áÂ§±Ë¥•:', error);
        }
    }

    saveSecurityMetrics() {
        try {
            localStorage.setItem('securityMetrics', JSON.stringify(this.securityMetrics));
        } catch (error) {
            console.warn('‰øùÂ≠òÂÆâÂÖ®ÊåáÊ†áÂ§±Ë¥•:', error);
        }
    }

    // ==================== ÂÖ¨ÂÖ±Êé•Âè£ ====================

    async authenticate(credentials) {
        
        
        try {
            // 1. Êõ¥Êñ∞ÂÆâÂÖ®ÊåáÊ†á
            this.securityMetrics.loginAttempts++;
            
            // 2. Ê£ÄÊü•Ë¥¶Êà∑ÈîÅÂÆö
            if (this.isAccountLocked()) {
                throw new Error('Ë¥¶Êà∑Â∑≤Ë¢´ÈîÅÂÆöÔºåËØ∑Á®çÂêéÂÜçËØï');
            }
            
            // 3. ÁîüÊàêÊàñÈ™åËØÅËÆæÂ§áÊåáÁ∫π
            if (!this.deviceFingerprint) {
                await this.generateDeviceFingerprint();
            }
            
            // 4. Ê£ÄÊü•ÊòØÂê¶ÈúÄË¶ÅMFA
            const mfaRequirement = await this.requestMFA(credentials);
            
            // 5. ÊûÑÂª∫ËÆ§ËØÅËØ∑Ê±Ç
            const authRequest = {
                ...credentials,
                deviceFingerprint: this.deviceFingerprint,
                securityMetrics: this.securityMetrics,
                behaviorMetrics: this.behaviorMetrics,
                mfaRequired: mfaRequirement.required,
                riskScore: this.securityMetrics.riskScore,
                timestamp: Date.now()
            };
            
            return {
                authRequest,
                mfaRequirement,
                securityContext: {
                    riskScore: this.securityMetrics.riskScore,
                    deviceTrusted: this.isTrustedDevice(),
                    behaviorScore: this.securityMetrics.behaviorScore
                }
            };
            
        } catch (error) {
            this.securityMetrics.failedAttempts++;
            this.saveSecurityMetrics();
            throw error;
        }
    }

    isAccountLocked() {
        const now = Date.now();
        const lastFailedAttempt = this.securityMetrics.lastFailedAttempt || 0;
        
        if (this.securityMetrics.failedAttempts >= this.config.maxFailedAttempts) {
            if (now - lastFailedAttempt < this.config.lockoutDuration) {
                return true;
            } else {
                // ÈîÅÂÆöÊúüÂ∑≤ËøáÔºåÈáçÁΩÆÂ§±Ë¥•Ê¨°Êï∞
                this.securityMetrics.failedAttempts = 0;
                this.saveSecurityMetrics();
            }
        }
        
        return false;
    }

    onAuthSuccess(authResult) {
        
        
        // ÈáçÁΩÆÂ§±Ë¥•ËÆ°Êï∞
        this.securityMetrics.failedAttempts = 0;
        this.securityMetrics.lastLoginTime = Date.now();
        
        // Â¶ÇÊûúÁî®Êà∑ÈÄâÊã©‰ø°‰ªªËÆæÂ§á
        if (authResult.trustDevice) {
            this.markDeviceAsTrusted();
        }
        
        // ‰øùÂ≠òÂÆâÂÖ®ÊåáÊ†á
        this.saveSecurityMetrics();
        
        // ÂêØÂä®‰ºöËØùÁõëÊéß
        this.sessionData.isActive = true;
    }

    onAuthFailure(error) {
        console.error('‚ùå ËÆ§ËØÅÂ§±Ë¥•:', error);
        
        this.securityMetrics.failedAttempts++;
        this.securityMetrics.lastFailedAttempt = Date.now();
        
        // Êõ¥Êñ∞È£éÈô©ËØÑÂàÜ
        this.updateRiskScore();
        
        // ‰øùÂ≠òÂÆâÂÖ®ÊåáÊ†á
        this.saveSecurityMetrics();
    }

    // ==================== ÂÆâÂÖ®Êä•Âëä ====================

    generateSecurityReport() {
        return {
            timestamp: Date.now(),
            deviceFingerprint: this.deviceFingerprint?.substring(0, 16) + '...',
            securityMetrics: { ...this.securityMetrics },
            sessionData: { ...this.sessionData },
            config: { ...this.config },
            warnings: this.sessionData.warnings || [],
            recommendations: this.generateSecurityRecommendations()
        };
    }

    generateSecurityRecommendations() {
        const recommendations = [];
        
        if (this.securityMetrics.riskScore > 0.7) {
            recommendations.push('ÂΩìÂâçÈ£éÈô©Á∫ßÂà´ËæÉÈ´òÔºåÂª∫ËÆÆÂêØÁî®È¢ùÂ§ñÁöÑÂÆâÂÖ®È™åËØÅ');
        }
        
        if (this.securityMetrics.failedAttempts > 2) {
            recommendations.push('Ê£ÄÊµãÂà∞Â§öÊ¨°ÁôªÂΩïÂ§±Ë¥•ÔºåÂª∫ËÆÆÊ£ÄÊü•Ë¥¶Êà∑ÂÆâÂÖ®');
        }
        
        if (!this.isTrustedDevice()) {
            recommendations.push('ÂΩìÂâçËÆæÂ§áÊú™Ë¢´‰ø°‰ªªÔºåÂª∫ËÆÆÂÆåÊàêËÆæÂ§áÈ™åËØÅ');
        }
        
        if (this.securityMetrics.behaviorScore < 0.6) {
            recommendations.push('Ê£ÄÊµãÂà∞ÂºÇÂ∏∏Ë°å‰∏∫Ê®°ÂºèÔºåÂª∫ËÆÆËøõË°åÂÆâÂÖ®Ê£ÄÊü•');
        }
        
        return recommendations;
    }

    // ==================== Ê∏ÖÁêÜÊñπÊ≥ï ====================

    destroy() {
        
        
        if (this.behaviorTimer) {
            clearInterval(this.behaviorTimer);
        }
        
        if (this.sessionMonitor) {
            clearInterval(this.sessionMonitor);
        }
        
        // ÁßªÈô§‰∫ã‰ª∂ÁõëÂê¨Âô®
        document.removeEventListener('mousemove', this.trackBehavior);
        document.removeEventListener('keydown', this.trackBehavior);
        document.removeEventListener('click', this.trackBehavior);
        
        this.saveSecurityMetrics();
    }
}

// ÂÖ®Â±ÄÂÆû‰æã
window.ZeroTrustAuth = ZeroTrustAuth;


