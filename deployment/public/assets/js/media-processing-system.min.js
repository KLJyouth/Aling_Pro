class MediaProcessingSystem { constructor(options = {}) { this.options = { container: options.container || '.media-processor', uploadEndpoint: options.uploadEndpoint || '/api/upload', allowedTypes: options.allowedTypes || { image: ['jpg', 'jpeg', 'png', 'gif', 'webp', 'svg'], video: ['mp4', 'avi', 'mov', 'wmv', 'flv', 'webm'], audio: ['mp3', 'wav', 'ogg', 'aac', 'flac'] }, maxFileSize: options.maxFileSize || 50 * 1024 * 1024, maxImageSize: options.maxImageSize || 10 * 1024 * 1024, maxVideoSize: options.maxVideoSize || 100 * 1024 * 1024, maxAudioSize: options.maxAudioSize || 20 * 1024 * 1024, enableDragDrop: options.enableDragDrop !== false, enablePreview: options.enablePreview !== false, enableEdit: options.enableEdit !== false, enableCompress: options.enableCompress !== false, enableMetadata: options.enableMetadata !== false, enableThumbnail: options.enableThumbnail !== false, enableWatermark: options.enableWatermark || false, imageQuality: options.imageQuality || 0.8, thumbnailSize: options.thumbnailSize || 200, videoQuality: options.videoQuality || 'medium', onUpload: options.onUpload || null, onProgress: options.onProgress || null, onComplete: options.onComplete || null, onError: options.onError || null, ...options }; this.activeUploads = new Map(); this.mediaCache = new Map(); this.isInitialized = false; this.canvas = null; this.context = null; this.init(); } init() { this.createInterface(); this.setupEventListeners(); this.setupGlobalStyles(); this.createCanvas(); this.isInitialized = true; } createInterface() { const container = typeof this.options.container === 'string' ? document.querySelector(this.options.container) : this.options.container; if (!container) { console.error('Media processor container not found'); return; } container.innerHTML = ` <div class="media-processor"> <div class="upload-area" id="uploadArea"> <div class="upload-content"> <div class="upload-icon">üìÅ</div> <div class="upload-text"> <h3>ÊãñÊãΩÊñá‰ª∂Âà∞Ê≠§Â§ÑÊàñÁÇπÂáª‰∏ä‰º†</h3> <p>ÊîØÊåÅÂõæÁâá„ÄÅËßÜÈ¢ë„ÄÅÈü≥È¢ëÊñá‰ª∂</p> </div> <input type="file" id="fileInput" multiple accept="image setupGlobalStyles() { if (document.getElementById('media-processor-styles')) return; const styles = document.createElement('style'); styles.id = 'media-processor-styles'; styles.textContent = ` .media-processor { width: 100%; max-width: 1200px; margin: 0 auto; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif; } .upload-area { border: 2px dashed rgba(100, 200, 255, 0.5); border-radius: 12px; padding: 40px 20px; text-align: center; background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05)); backdrop-filter: blur(10px); transition: all 0.3s ease; cursor: pointer; margin-bottom: 24px; } .upload-area:hover, .upload-area.drag-over { border-color: rgba(100, 200, 255, 0.8); background: linear-gradient(135deg, rgba(100, 200, 255, 0.1), rgba(100, 200, 255, 0.05)); transform: translateY(-2px); } .upload-content { max-width: 400px; margin: 0 auto; } .upload-icon { font-size: 48px; margin-bottom: 16px; opacity: 0.6; } .upload-text h3 { margin: 0 0 8px 0; color: #333; font-size: 18px; font-weight: 600; } .upload-text p { margin: 0 0 20px 0; color: #666; font-size: 14px; } .upload-btn { background: linear-gradient(135deg, #3b82f6, #2563eb); color: white; border: none; padding: 12px 24px; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s ease; } .upload-btn:hover { background: linear-gradient(135deg, #2563eb, #1d4ed8); transform: translateY(-1px); box-shadow: 0 4px 16px rgba(59, 130, 246, 0.3); } .processing-queue { background: white; border: 1px solid rgba(0,0,0,0.1); border-radius: 12px; padding: 20px; margin-bottom: 24px; } .processing-queue h4 { margin: 0 0 16px 0; color: #333; font-size: 16px; font-weight: 600; } .queue-item { display: flex; align-items: center; gap: 12px; padding: 12px; border: 1px solid rgba(0,0,0,0.1); border-radius: 8px; margin-bottom: 8px; background: #f8f9fa; } .queue-item:last-child { margin-bottom: 0; } .queue-file-info { flex: 1; min-width: 0; } .queue-file-name { font-weight: 600; color: #333; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; } .queue-file-size { font-size: 12px; color: #666; } .queue-progress { width: 200px; height: 6px; background: #e5e7eb; border-radius: 3px; overflow: hidden; } .queue-progress-bar { height: 100%; background: linear-gradient(90deg, #10b981, #059669); border-radius: 3px; transition: width 0.3s ease; } .queue-status { font-size: 12px; color: #666; width: 80px; text-align: right; } .media-preview, .media-editor { background: white; border: 1px solid rgba(0,0,0,0.1); border-radius: 12px; padding: 20px; margin-bottom: 24px; } .preview-header, .editor-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 16px; border-bottom: 1px solid rgba(0,0,0,0.1); } .preview-header h4, .editor-header h4 { margin: 0; color: #333; font-size: 16px; font-weight: 600; } .preview-actions, .editor-actions { display: flex; gap: 8px; } .btn { padding: 8px 16px; border-radius: 6px; border: none; font-size: 14px; cursor: pointer; transition: all 0.2s ease; font-weight: 500; } .btn-primary { background: #3b82f6; color: white; } .btn-primary:hover { background: #2563eb; } .btn-secondary { background: #6b7280; color: white; } .btn-secondary:hover { background: #4b5563; } .btn-danger { background: #ef4444; color: white; } .btn-danger:hover { background: #dc2626; } .preview-content { text-align: center; margin-bottom: 20px; } .preview-image { max-width: 100%; max-height: 400px; border-radius: 8px; box-shadow: 0 4px 16px rgba(0,0,0,0.1); } .preview-video { max-width: 100%; max-height: 400px; border-radius: 8px; } .preview-audio { width: 100%; max-width: 400px; } .preview-info { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 16px; background: #f8f9fa; padding: 16px; border-radius: 8px; } .info-item { display: flex; justify-content: space-between; align-items: center; } .info-label { font-weight: 600; color: #374151; } .info-value { color: #6b7280; text-align: right; } .editor-tools { display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 20px; padding: 16px; background: #f8f9fa; border-radius: 8px; } .tool-group { display: flex; gap: 4px; padding: 4px; background: white; border-radius: 6px; border: 1px solid rgba(0,0,0,0.1); } .tool-btn { width: 36px; height: 36px; border: none; background: transparent; border-radius: 4px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: background 0.2s ease; font-size: 16px; } .tool-btn:hover { background: #f3f4f6; } .tool-btn.active { background: #dbeafe; color: #2563eb; } .editor-canvas { text-align: center; background: #f8f9fa; border-radius: 8px; padding: 20px; min-height: 300px; display: flex; align-items: center; justify-content: center; } .media-gallery { background: white; border: 1px solid rgba(0,0,0,0.1); border-radius: 12px; padding: 20px; } .gallery-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 16px; border-bottom: 1px solid rgba(0,0,0,0.1); } .gallery-header h4 { margin: 0; color: #333; font-size: 16px; font-weight: 600; } .gallery-controls { display: flex; gap: 12px; } .gallery-controls select { padding: 6px 12px; border: 1px solid rgba(0,0,0,0.2); border-radius: 6px; background: white; font-size: 14px; cursor: pointer; } .gallery-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 16px; } .gallery-item { background: #f8f9fa; border: 1px solid rgba(0,0,0,0.1); border-radius: 8px; padding: 12px; cursor: pointer; transition: all 0.2s ease; } .gallery-item:hover { transform: translateY(-2px); box-shadow: 0 4px 16px rgba(0,0,0,0.1); } .gallery-thumbnail { width: 100%; height: 120px; background: #e5e7eb; border-radius: 6px; margin-bottom: 8px; display: flex; align-items: center; justify-content: center; overflow: hidden; } .gallery-thumbnail img { width: 100%; height: 100%; object-fit: cover; border-radius: 6px; } .gallery-thumbnail-icon { font-size: 32px; color: #9ca3af; } .gallery-item-name { font-weight: 600; color: #333; font-size: 14px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; margin-bottom: 4px; } .gallery-item-info { font-size: 12px; color: #6b7280; display: flex; justify-content: space-between; } @media (max-width: 768px) { .media-processor { padding: 0 16px; } .preview-actions, .editor-actions, .gallery-controls { flex-direction: column; gap: 8px; } .gallery-grid { grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); } .preview-info { grid-template-columns: 1fr; } } .media-processor.quantum-theme .upload-area { background: linear-gradient(135deg, rgba(20, 50, 120, 0.1), rgba(50, 20, 120, 0.1), rgba(120, 20, 80, 0.1) ); border-color: rgba(100, 200, 255, 0.4); } .media-processor.quantum-theme .queue-progress-bar { background: linear-gradient(90deg, rgba(100, 200, 255, 0.8), rgba(150, 100, 255, 0.8) ); } `; document.head.appendChild(styles); } setupEventListeners() { if (!this.elements.container) return; this.elements.uploadBtn.addEventListener('click', () => { this.elements.fileInput.click(); }); this.elements.fileInput.addEventListener('change', (e) => { this.handleFiles(Array.from(e.target.files)); }); if (this.options.enableDragDrop) { this.setupDragAndDrop(); } this.elements.container.addEventListener('click', (e) => { if (e.target.id === 'editBtn') { this.openEditor(); } else if (e.target.id === 'downloadBtn') { this.downloadCurrentFile(); } else if (e.target.id === 'deleteBtn') { this.deleteCurrentFile(); } else if (e.target.id === 'cancelEditBtn') { this.closeEditor(); } else if (e.target.id === 'saveEditBtn') { this.saveEditorChanges(); } }); this.elements.filterType.addEventListener('change', () => { this.filterGallery(); }); this.elements.sortBy.addEventListener('change', () => { this.sortGallery(); }); this.elements.galleryGrid.addEventListener('click', (e) => { const galleryItem = e.target.closest('.gallery-item'); if (galleryItem) { this.previewFile(galleryItem.dataset.fileId); } }); } setupDragAndDrop() { const uploadArea = this.elements.uploadArea; ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => { uploadArea.addEventListener(eventName, this.preventDefaults, false); document.body.addEventListener(eventName, this.preventDefaults, false); }); ['dragenter', 'dragover'].forEach(eventName => { uploadArea.addEventListener(eventName, () => { uploadArea.classList.add('drag-over'); }, false); }); ['dragleave', 'drop'].forEach(eventName => { uploadArea.addEventListener(eventName, () => { uploadArea.classList.remove('drag-over'); }, false); }); uploadArea.addEventListener('drop', (e) => { const files = Array.from(e.dataTransfer.files); this.handleFiles(files); }, false); } preventDefaults(e) { e.preventDefault(); e.stopPropagation(); } createCanvas() { this.canvas = document.createElement('canvas'); this.context = this.canvas.getContext('2d'); } async handleFiles(files) { if (!files || files.length === 0) return; const validFiles = this.validateFiles(files); if (validFiles.length === 0) return; this.elements.processingQueue.style.display = 'block'; for (const file of validFiles) { await this.processFile(file); } } validateFiles(files) { const validFiles = []; for (const file of files) { const fileType = this.getFileType(file); const fileExtension = this.getFileExtension(file.name); if (!this.isAllowedType(fileType, fileExtension)) { this.showError(`‰∏çÊîØÊåÅÁöÑÊñá‰ª∂Á±ªÂûã: ${file.name}`); continue; } if (!this.isAllowedSize(file, fileType)) { this.showError(`Êñá‰ª∂ËøáÂ§ß: ${file.name}`); continue; } validFiles.push(file); } return validFiles; } async processFile(file) { const fileId = this.generateFileId(); const fileType = this.getFileType(file); const queueItem = this.createQueueItem(fileId, file); this.elements.queueList.appendChild(queueItem); this.activeUploads.set(fileId, { file, type: fileType, queueItem, progress: 0 }); try { const fileData = await this.readFile(file); let thumbnail = null; if (this.options.enableThumbnail && fileType === 'image') { thumbnail = await this.generateThumbnail(fileData, file); } let processedData = fileData; if (this.options.enableCompress) { processedData = await this.compressFile(fileData, file, fileType); } let metadata = null; if (this.options.enableMetadata) { metadata = await this.extractMetadata(file, fileType); } const uploadResult = await this.uploadFile(fileId, processedData, file, metadata, thumbnail); this.addToMediaLibrary({ id: fileId, name: file.name, type: fileType, size: file.size, url: uploadResult.url, thumbnail: thumbnail, metadata: metadata, uploadDate: new Date() }); this.completeFileProcessing(fileId, uploadResult); } catch (error) { console.error('File processing error:', error); this.failFileProcessing(fileId, error.message); } } createQueueItem(fileId, file) { const div = document.createElement('div'); div.className = 'queue-item'; div.dataset.fileId = fileId; div.innerHTML = ` <div class="queue-file-info"> <div class="queue-file-name">${file.name}</div> <div class="queue-file-size">${this.formatFileSize(file.size)}</div> </div> <div class="queue-progress"> <div class="queue-progress-bar" style="width: 0%"></div> </div> <div class="queue-status">Á≠âÂæÖ‰∏≠</div> `; return div; } readFile(file) { return new Promise((resolve, reject) => { const reader = new FileReader(); reader.onload = (e) => resolve(e.target.result); reader.onerror = () => reject(new Error('Êñá‰ª∂ËØªÂèñÂ§±Ë¥•')); reader.readAsDataURL(file); }); } async generateThumbnail(imageData, file) { return new Promise((resolve) => { const img = new Image(); img.onload = () => { const size = this.options.thumbnailSize; const scale = Math.min(size / img.width, size / img.height); this.canvas.width = img.width * scale; this.canvas.height = img.height * scale; this.context.drawImage(img, 0, 0, this.canvas.width, this.canvas.height); this.canvas.toBlob((blob) => { const reader = new FileReader(); reader.onload = (e) => resolve(e.target.result); reader.readAsDataURL(blob); }, 'image/jpeg', 0.7); }; img.src = imageData; }); } async compressFile(fileData, file, fileType) { if (fileType === 'image') { return await this.compressImage(fileData, file); } return fileData; } async compressImage(imageData, file) { return new Promise((resolve) => { const img = new Image(); img.onload = () => { let { width, height } = img; const maxDimension = 1920; if (width > maxDimension || height > maxDimension) { const scale = Math.min(maxDimension / width, maxDimension / height); width *= scale; height *= scale; } this.canvas.width = width; this.canvas.height = height; this.context.drawImage(img, 0, 0, width, height); this.canvas.toBlob((blob) => { const reader = new FileReader(); reader.onload = (e) => resolve(e.target.result); reader.readAsDataURL(blob); }, 'image/jpeg', this.options.imageQuality); }; img.src = imageData; }); } async extractMetadata(file, fileType) { const metadata = { name: file.name, size: file.size, type: file.type, lastModified: new Date(file.lastModified) }; if (fileType === 'image') { const imageData = await this.readFile(file); const img = new Image(); return new Promise((resolve) => { img.onload = () => { metadata.width = img.width; metadata.height = img.height; metadata.aspectRatio = (img.width / img.height).toFixed(2); resolve(metadata); }; img.src = imageData; }); } if (fileType === 'video') { const video = document.createElement('video'); video.preload = 'metadata'; return new Promise((resolve) => { video.onloadedmetadata = () => { metadata.duration = video.duration; metadata.width = video.videoWidth; metadata.height = video.videoHeight; metadata.aspectRatio = (video.videoWidth / video.videoHeight).toFixed(2); resolve(metadata); }; video.src = URL.createObjectURL(file); }); } if (fileType === 'audio') { const audio = document.createElement('audio'); audio.preload = 'metadata'; return new Promise((resolve) => { audio.onloadedmetadata = () => { metadata.duration = audio.duration; resolve(metadata); }; audio.src = URL.createObjectURL(file); }); } return metadata; } async uploadFile(fileId, fileData, originalFile, metadata, thumbnail) { const formData = new FormData(); const blob = this.dataURLtoBlob(fileData); formData.append('file', blob, originalFile.name); if (metadata) { formData.append('metadata', JSON.stringify(metadata)); } if (thumbnail) { const thumbnailBlob = this.dataURLtoBlob(thumbnail); formData.append('thumbnail', thumbnailBlob, `thumb_${originalFile.name}`); } const xhr = new XMLHttpRequest(); return new Promise((resolve, reject) => { xhr.upload.addEventListener('progress', (e) => { if (e.lengthComputable) { const progress = (e.loaded / e.total) * 100; this.updateProgress(fileId, progress); } }); xhr.addEventListener('load', () => { if (xhr.status === 200) { try { const response = JSON.parse(xhr.responseText); resolve(response); } catch (error) { reject(new Error('Êó†ÊïàÁöÑÊúçÂä°Âô®ÂìçÂ∫î')); } } else { reject(new Error(`‰∏ä‰º†Â§±Ë¥•: ${xhr.status}`)); } }); xhr.addEventListener('error', () => { reject(new Error('ÁΩëÁªúÈîôËØØ')); }); xhr.open('POST', this.options.uploadEndpoint); xhr.send(formData); }); } updateProgress(fileId, progress) { const upload = this.activeUploads.get(fileId); if (!upload) return; upload.progress = progress; const progressBar = upload.queueItem.querySelector('.queue-progress-bar'); const statusElement = upload.queueItem.querySelector('.queue-status'); if (progressBar) { progressBar.style.width = `${progress}%`; } if (statusElement) { statusElement.textContent = `${Math.round(progress)}%`; } if (this.options.onProgress) { this.options.onProgress(fileId, progress, upload); } } completeFileProcessing(fileId, uploadResult) { const upload = this.activeUploads.get(fileId); if (!upload) return; const statusElement = upload.queueItem.querySelector('.queue-status'); if (statusElement) { statusElement.textContent = 'ÂÆåÊàê'; statusElement.style.color = '#10b981'; } setTimeout(() => { if (upload.queueItem.parentNode) { upload.queueItem.parentNode.removeChild(upload.queueItem); } this.activeUploads.delete(fileId); if (this.activeUploads.size === 0) { this.elements.processingQueue.style.display = 'none'; } }, 2000); if (this.options.onComplete) { this.options.onComplete(fileId, uploadResult, upload); } } failFileProcessing(fileId, errorMessage) { const upload = this.activeUploads.get(fileId); if (!upload) return; const statusElement = upload.queueItem.querySelector('.queue-status'); if (statusElement) { statusElement.textContent = 'Â§±Ë¥•'; statusElement.style.color = '#ef4444'; } if (this.options.onError) { this.options.onError(fileId, errorMessage, upload); } this.showError(`Êñá‰ª∂Â§ÑÁêÜÂ§±Ë¥•: ${upload.file.name} - ${errorMessage}`); } addToMediaLibrary(mediaItem) { this.mediaCache.set(mediaItem.id, mediaItem); this.renderGallery(); } renderGallery() { const items = Array.from(this.mediaCache.values()); const filteredItems = this.applyGalleryFilters(items); const sortedItems = this.sortGalleryItems(filteredItems); const html = sortedItems.map(item => this.createGalleryItemHTML(item)).join(''); this.elements.galleryGrid.innerHTML = html; } createGalleryItemHTML(item) { const thumbnailContent = item.thumbnail ? `<img src="${item.thumbnail}" alt="${item.name}">` : `<div class="gallery-thumbnail-icon">${this.getTypeIcon(item.type)}</div>`; return ` <div class="gallery-item" data-file-id="${item.id}"> <div class="gallery-thumbnail"> ${thumbnailContent} </div> <div class="gallery-item-name">${item.name}</div> <div class="gallery-item-info"> <span>${item.type}</span> <span>${this.formatFileSize(item.size)}</span> </div> </div> `; } previewFile(fileId) { const item = this.mediaCache.get(fileId); if (!item) return; this.currentPreviewItem = item; const previewContent = this.generatePreviewContent(item); this.elements.previewContent.innerHTML = previewContent; const infoContent = this.generateInfoContent(item); this.elements.previewInfo.innerHTML = infoContent; this.elements.mediaPreview.style.display = 'block'; this.elements.mediaPreview.scrollIntoView({ behavior: 'smooth' }); } generatePreviewContent(item) { switch (item.type) { case 'image': return `<img src="${item.url}" alt="${item.name}" class="preview-image">`; case 'video': return ` <video controls class="preview-video"> <source src="${item.url}" type="${item.metadata?.type || 'video/mp4'}"> ÊÇ®ÁöÑÊµèËßàÂô®‰∏çÊîØÊåÅËßÜÈ¢ëÊí≠Êîæ </video> `; case 'audio': return ` <audio controls class="preview-audio"> <source src="${item.url}" type="${item.metadata?.type || 'audio/mpeg'}"> ÊÇ®ÁöÑÊµèËßàÂô®‰∏çÊîØÊåÅÈü≥È¢ëÊí≠Êîæ </audio> `; default: return `<div class="preview-default">Êó†Ê≥ïÈ¢ÑËßàÊ≠§Êñá‰ª∂Á±ªÂûã</div>`; } } generateInfoContent(item) { const metadata = item.metadata || {}; const infoItems = [ { label: 'Êñá‰ª∂Âêç', value: item.name }, { label: 'Á±ªÂûã', value: item.type }, { label: 'Â§ßÂ∞è', value: this.formatFileSize(item.size) }, { label: '‰∏ä‰º†Êó∂Èó¥', value: this.formatDate(item.uploadDate) } ]; if (metadata.width && metadata.height) { infoItems.push({ label: 'Â∞∫ÂØ∏', value: `${metadata.width} √ó ${metadata.height}` }); } if (metadata.duration) { infoItems.push({ label: 'Êó∂Èïø', value: this.formatDuration(metadata.duration) }); } return infoItems.map(item => ` <div class="info-item"> <span class="info-label">${item.label}:</span> <span class="info-value">${item.value}</span> </div> `).join(''); } getFileType(file) { const extension = this.getFileExtension(file.name).toLowerCase(); if (this.options.allowedTypes.image.includes(extension)) return 'image'; if (this.options.allowedTypes.video.includes(extension)) return 'video'; if (this.options.allowedTypes.audio.includes(extension)) return 'audio'; return 'unknown'; } getFileExtension(filename) { return filename.split('.').pop().toLowerCase(); } isAllowedType(fileType, extension) { return this.options.allowedTypes[fileType]?.includes(extension) || false; } isAllowedSize(file, fileType) { const maxSize = { image: this.options.maxImageSize, video: this.options.maxVideoSize, audio: this.options.maxAudioSize }[fileType] || this.options.maxFileSize; return file.size <= maxSize; } formatFileSize(bytes) { if (bytes === 0) return '0 Bytes'; const k = 1024; const sizes = ['Bytes', 'KB', 'MB', 'GB']; const i = Math.floor(Math.log(bytes) / Math.log(k)); return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i]; } formatDate(date) { return date.toLocaleDateString() + ' ' + date.toLocaleTimeString(); } formatDuration(seconds) { const hours = Math.floor(seconds / 3600); const minutes = Math.floor((seconds % 3600) / 60); const secs = Math.floor(seconds % 60); if (hours > 0) { return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`; } return `${minutes}:${secs.toString().padStart(2, '0')}`; } getTypeIcon(type) { const icons = { image: 'üñºÔ∏è', video: 'üé•', audio: 'üéµ', unknown: 'üìÑ' }; return icons[type] || icons.unknown; } dataURLtoBlob(dataURL) { const arr = dataURL.split(','); const mime = arr[0].match(/:(.*?);/)[1]; const bstr = atob(arr[1]); let n = bstr.length; const u8arr = new Uint8Array(n); while (n--) { u8arr[n] = bstr.charCodeAt(n); } return new Blob([u8arr], { type: mime }); } generateFileId() { return 'media_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9); } applyGalleryFilters(items) { const filterType = this.elements.filterType.value; if (filterType === 'all') return items; return items.filter(item => item.type === filterType); } sortGalleryItems(items) { const sortBy = this.elements.sortBy.value; return items.sort((a, b) => { switch (sortBy) { case 'date': return new Date(b.uploadDate) - new Date(a.uploadDate); case 'name': return a.name.localeCompare(b.name); case 'size': return b.size - a.size; case 'type': return a.type.localeCompare(b.type); default: return 0; } }); } filterGallery() { this.renderGallery(); } sortGallery() { this.renderGallery(); } showError(message) { if (window.notifications) { window.notifications.error(message); } else { console.error(message); alert(message); } } openEditor() { this.elements.mediaEditor.style.display = 'block'; this.elements.mediaPreview.style.display = 'none'; } closeEditor() { this.elements.mediaEditor.style.display = 'none'; this.elements.mediaPreview.style.display = 'block'; } saveEditorChanges() { this.closeEditor(); } downloadCurrentFile() { if (this.currentPreviewItem) { const link = document.createElement('a'); link.href = this.currentPreviewItem.url; link.download = this.currentPreviewItem.name; link.click(); } } deleteCurrentFile() { if (this.currentPreviewItem && confirm('Á°ÆÂÆöË¶ÅÂà†Èô§Ëøô‰∏™Êñá‰ª∂ÂêóÔºü')) { this.mediaCache.delete(this.currentPreviewItem.id); this.renderGallery(); this.elements.mediaPreview.style.display = 'none'; } } destroy() { this.activeUploads.clear(); this.mediaCache.clear(); if (this.elements.container) { this.elements.container.innerHTML = ''; } } } window.MediaProcessingSystem = MediaProcessingSystem; if (typeof module !== 'undefined' && module.exports) { module.exports = MediaProcessingSystem; }